# /mnt/home2/mud/driver.py
import asyncio
import telnetlib3
import zlib
import json
import logging
import sqlite3
from typing import Dict, Callable, Any, Optional
from websockets.server import serve
import aiohttp
from ssl import create_default_context
import uvloop
import aiojobs
import cProfile, pstats
from concurrent.futures import ProcessPoolExecutor
import os
import signal
import importlib
import aiofiles
from heapq import heappush, heappop
import time
import redis  # For clustering
import hashlib

# Use uvloop for faster event loop
asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/mnt/home2/mud/logs/server.log'),
        logging.FileHandler('/mnt/home2/mud/logs/errors.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("PyMudDriver")

# Call stack for this_object(), previous_object()
call_stack = []

# Base MUD Object
class MudObject:
    def __init__(self, oid: str, name: str, euid: str = "root"):
        self.oid = oid
        self.name = name
        self.actions: Dict[str, Callable] = {}
        self.attrs: Dict[str, Any] = {}
        self.location: Optional["MudObject"] = None
        self.euid = euid

    def add_action(self, verb: str, func: Callable):
        self.actions[verb] = func

    async def call(self, verb: str, caller: "Player", arg: str = None) -> str:
        global call_stack
        call_stack.append(self)
        try:
            if verb in self.actions:
                return await self.actions[verb](self, caller, arg)
            return await driver.notify_fail(caller, f"{verb} not recognized.")
        finally:
            call_stack.pop()

    def set(self, key: str, value: Any):
        self.attrs[key] = value

    def get(self, key: str, default: Any = None) -> Any:
        return self.attrs.get(key, default)

    def clone(self) -> "MudObject":
        new_oid = f"{self.oid}_clone_{id(self)}"
        clone = MudObject(new_oid, self.name, self.euid)
        clone.actions = self.actions.copy()
        clone.attrs = self.attrs.copy()
        driver.objects[new_oid] = clone
        return clone

    def destruct(self):
        if self.oid in driver.objects:
            del driver.objects[self.oid]
            driver.save_object(self)

# Player Class
class Player:
    def __init__(self, writer, protocol: str = "telnet"):
        self.writer = writer
        self.protocol = protocol
        self.location: Optional[MudObject] = None
        self.compress = False
        self.gmcp_enabled = False
        self.msdp_enabled = False
        self.atcp_enabled = False
        self.msdp_data = {}
        self.ip_address = None
        self.last_active = time.time()
        self.pk_flagged = False

    async def send(self, msg: str):
        data = f"\033[38;2;255;255;255m{msg}\033[0m".encode("utf-8")  # RGB colors
        if self.compress:
            data = zlib.compress(data)
        if self.protocol == "telnet":
            self.writer.write(data + b"\r\n")
            await self.writer.drain()
        elif self.protocol == "websocket":
            await self.writer.send(msg)
        if self.gmcp_enabled:
            await self.send_gmcp({"event": "output", "message": msg})
        if self.msdp_enabled:
            self.msdp_data["last_message"] = msg
            await self.send_msdp(self.msdp_data)
        if self.atcp_enabled:
            await self.send_atcp({"message": msg})

    async def send_gmcp(self, data: Dict):
        if self.gmcp_enabled:
            await self.writer.write(f"\xff\xfa\x90{json.dumps(data)}\xff\xf0".encode())

    async def send_msdp(self, data: Dict):
        if self.msdp_enabled:
            await self.writer.write(f"\xff\xfa\x69{json.dumps(data)}\xff\xf0".encode())

    async def send_atcp(self, data: Dict):
        if self.atcp_enabled:
            await self.writer.write(f"\xff\xfa\xc8{json.dumps(data)}\xff\xf0".encode())

    async def prompt(self):
        await self.send("> ")

# PyMudDriver
class PyMudDriver:
    def __init__(self, db_path: str = "/mnt/home2/mud/players/mud.db"):
        self.loop = asyncio.get_event_loop()
        self.objects: Dict[str, MudObject] = {}
        self.players: Dict[Any, Player] = {}
        self.db = sqlite3.connect(db_path, check_same_thread=False)
        self.scheduler = aiojobs.Scheduler()
        self.executor = ProcessPoolExecutor(max_workers=6)  # 6 cores
        self.task_queue = []  # Priority queue for events
        self.plugins = {}
        self.redis = redis.Redis(host='localhost', port=6379, db=0)  # Clustering
        self.last_verb = None
        self.start_time = time.time()
        self.init_db()
    def load_plugins(self):
        for plugin in [
            "systems.combat", "systems.skills_handler", "systems.tactics", "systems.inventory_handler",
            "systems.soul_handler", "systems.term_handler", "systems.network_handler", "systems.quests_handler",
            "systems.crafting_handler", "systems.zones", "systems.living", "systems.parser",
            "systems.organizations", "systems.houses", "systems.pk", "systems.mounts", "systems.commands",
            "systems.terrain_handler", "systems.login_handler", "systems.ritual_handler", "systems.spell_handler",
            "efuns.core", "efuns.network", "efuns.parser", "efuns.communication", "efuns.combat",
            "efuns.skills", "efuns.tools"
        ]:
        self.load_plugin(plugin)

    def init_db(self):
        self.db.execute("CREATE TABLE IF NOT EXISTS objects (oid TEXT PRIMARY KEY, data TEXT)")
        self.db.execute("CREATE INDEX IF NOT EXISTS idx_oid ON objects (oid)")
        self.db.commit()

    def load_object(self, oid: str, cls: type, name: str, euid: str = "root") -> MudObject:
        cursor = self.db.execute("SELECT data FROM objects WHERE oid=?", (oid,))
        data = cursor.fetchone()
        obj = cls(oid, name, euid)
        if data:
            obj.attrs = json.loads(data[0])
        self.objects[oid] = obj
        return obj

    def save_object(self, obj: MudObject):
        self.db.execute("INSERT OR REPLACE INTO objects VALUES (?, ?)",
                        (obj.oid, json.dumps(obj.attrs)))
        self.db.commit()

    async def call_out(self, delay: float, func: Callable, *args):
        heappush(self.task_queue, (time.time() + delay, func, args))
        await self.scheduler.spawn(self.process_tasks())

    async def process_tasks(self):
        while self.task_queue:
            timestamp, func, args = heappop(self.task_queue)
            if time.time() < timestamp:
                await asyncio.sleep(timestamp - time.time())
            await func(*args)

    async def call_other(self, oid: str, verb: str, caller: Player, arg: str = None) -> str:
        if oid in self.objects:
            return await self.objects[oid].call(verb, caller, arg)
        return "Object not found."

    def this_object(self) -> Optional[MudObject]:
        return call_stack[-1] if call_stack else None

    def previous_object(self) -> Optional[MudObject]:
        return call_stack[-2] if len(call_stack) > 1 else None

    async def read_file(self, path: str) -> str:
        async with aiofiles.open(path, "r") as f:
            return await f.read()

    async def write_file(self, path: str, content: str):
        async with aiofiles.open(path, "w") as f:
            await f.write(content)

    def uptime(self) -> int:
        return int(time.time() - self.start_time)

    def query_verb(self) -> Optional[str]:
        return self.last_verb

    async def notify_fail(self, caller: Player, msg: str) -> str:
        return msg

    def seteuid(self, obj: MudObject, euid: str):
        obj.euid = euid

    def geteuid(self, obj: MudObject) -> str:
        return obj.euid

    def mud_status(self) -> Dict[str, Any]:
        return {
            "uptime": self.uptime(),
            "players": len(self.players),
            "objects": len(self.objects),
            "tasks": len(self.task_queue),
            "memory_usage": os.getpid()  # Approximate
        }

    async def heartbeat(self):
        while True:
            for obj in list(self.objects.values()):
                if "heart_beat" in obj.actions:
                    await obj.call("heart_beat", None)
            await asyncio.sleep(1.0)

    async def telnet_handler(self, reader, writer):
        player = Player(writer, "telnet")
        self.players[writer] = player
        player.ip_address = writer.transport.get_extra_info('peername')[0]
        writer.write(b"\xff\xfb\x01\xff\xfb\x03\033[1z<MXP>\xff\xfb\x5a\xff\xfb\xc9\xff\xfb\x90\xff\xfb\xc8")
        await writer.drain()
        await self.handle_login(player)

    async def websocket_handler(self, websocket):
        player = Player(websocket, "websocket")
        self.players[websocket] = player
        player.ip_address = websocket.remote_address[0]
        await self.handle_login(player)

    async def handle_login(self, player: Player):
        await player.send("Welcome to the Realms, traveler, under the gaze of Mystra...")
        await self.call_out(5, player.send, "A portal shimmers before you...")
        await self.call_out(10, player.send, "You emerge as a spirit in the Ethereal Veil...")
        await self.call_out(15, player.send, "Choose your path [race/class]...")
        player.location = self.objects["ethereal_veil_start"]
        await player.send(await player.location.call("look", player))
        await player.prompt()

        while True:
            try:
                if player.protocol == "telnet":
                    data = await player.writer.read(1024)
                    if not data:
                        break
                    if data.startswith(telnetlib3.IAC):
                        if data[1:3] == telnetlib3.DO + b"\x5a":
                            player.compress = True
                        elif data[1:3] == telnetlib3.DO + b"\xc9":
                            player.msdp_enabled = True
                        elif data[1:3] == telnetlib3.DO + b"\x90":
                            player.gmcp_enabled = True
                        elif data[1:3] == telnetlib3.DO + b"\xc8":
                            player.atcp_enabled = True
                        continue
                    cmd = data.decode("utf-8").strip().split()
                else:
                    message = await player.writer.recv()
                    cmd = message.strip().split()

                if cmd:
                    self.last_verb, *args = cmd
                    arg = " ".join(args) if args else None
                    response = await player.location.call(self.last_verb, player, arg)
                    await player.send(response)
                await player.prompt()
            except Exception as e:
                logger.error(f"Client error: {e}")
                break
        if player.protocol == "telnet":
            player.writer.close()
            await player.writer.wait_closed()
        del self.players[player.writer]

    async def rest_api(self):
        async with aiohttp.web.Application() as app:
            async def get_status(request):
                return aiohttp.web.json_response(self.mud_status())
            app.router.add_get("/status", get_status)
            runner = aiohttp.web.AppRunner(app)
            await runner.setup()
            site = aiohttp.web.TCPSite(runner, "0.0.0.0", 8080)
            await site.start()

    def load_plugin(self, module_name: str):
        module = importlib.import_module(module_name)
        self.plugins[module_name] = module
        if hasattr(module, "init"):
            module.init(self)

    async def profile(self, func: Callable, *args):
        profiler = cProfile.Profile()
        profiler.enable()
        await func(*args)
        profiler.disable()
        stats = pstats.Stats(profiler).sort_stats("cumulative")
        stats.print_stats()

    async def start(self):
        # Initialize world
        self.load_object("ethereal_veil_start", MudObject, "Ethereal Veil Start")
        self.objects["ethereal_veil_start"].add_action("look", lambda obj, caller, arg: "A misty expanse under Mystra's gaze...")

        # Initialize weather and events
        await importlib.import_module("systems.weather").init(self)
        await importlib.import_module("systems.events").init(self)

        # SSL Context
        ssl_context = create_default_context()
        ssl_context.load_cert_chain("cert.pem", "key.pem")

        # Servers
        telnet_server = await telnetlib3.create_server(self.telnet_handler, port=4000, host="::", ssl=ssl_context)
        ws_server = await serve(self.websocket_handler, "::", 4001, ssl=ssl_context)
        rest_task = self.loop.create_task(self.rest_api())
        heartbeat_task = self.loop.create_task(self.heartbeat())

        # Crash Recovery
        def handle_signal(sig, frame):
            logger.info("Shutting down gracefully...")
            self.db.commit()
            asyncio.get_event_loop().stop()
        signal.signal(signal.SIGINT, handle_signal)

        logger.info("PyMudDriver running: Telnet@4000, WS@4001, REST@8080")
        await asyncio.gather(telnet_server.serve_forever(), ws_server, rest_task, heartbeat_task)

# Global driver instance
driver = PyMudDriver()

if __name__ == "__main__":
    asyncio.run(driver.start())

# /mnt/home2/mud/efuns/combat.py
from ..driver import driver, Player, MudObject

async def kill(player: Player, target: str):
    """Initiate combat with a target."""
    if not player.location:
        await player.send("You are nowhere to fight!")
        return
    contents = player.location.attrs.get("contents", [])
    target_obj = None
    for oid in contents:
        if oid in driver.objects and driver.objects[oid].name.lower() == target.lower():
            target_obj = driver.objects[oid]
            break
    if not target_obj:
        await player.send(f"No {target} here to fight!")
        return
    await player.send(f"You attack {target_obj.name}!")
    await driver.call_other(target_obj.oid, "receive_attack", player, None)

async def tactics(player: Player, strategy: str):
    """Set combat tactics (offensive, defensive, balanced)."""
    valid_strategies = ["offensive", "defensive", "balanced"]
    if strategy not in valid_strategies:
        await player.send(f"Invalid tactic! Choose: {', '.join(valid_strategies)}")
        return
    player.attrs["tactics"] = strategy
    await player.send(f"You set your tactics to {strategy}.")

# /mnt/home2/mud/efuns/communication.py
from ..driver import driver, Player, MudObject

async def say(player: Player, msg: str):
    """Say a message to all in the room."""
    if not player.location:
        await player.send("You are nowhere to say anything!")
        return
    contents = player.location.attrs.get("contents", [])
    for oid in contents:
        if oid in driver.objects and oid != player.oid:
            await driver.call_other(oid, "receive_message", player, f"{player.name} says: {msg}")
    await player.send(f"You say: {msg}")

async def emote(player: Player, msg: str):
    """Perform an emote visible to all in the room."""
    if not player.location:
        await player.send("You are nowhere to emote!")
        return
    contents = player.location.attrs.get("contents", [])
    for oid in contents:
        if oid in driver.objects:
            await driver.call_other(oid, "receive_message", player, f"{player.name} {msg}")
    await player.send(f"You emote: {player.name} {msg}")

async def tell(player: Player, target: str, msg: str):
    """Send a private message to another player."""
    target_obj = None
    for p in driver.players.values():
        if p.name.lower() == target.lower():
            target_obj = p
            break
    if not target_obj:
        await player.send(f"No one named {target} is online.")
        return
    await target_obj.send(f"{player.name} tells you: {msg}")
    await player.send(f"You tell {target}: {msg}")

async def shout(player: Player, msg: str):
    """Shout a message to all players."""
    for p in driver.players.values():
        await p.send(f"{player.name} shouts: {msg}")

# /mnt/home2/mud/efuns/core.py
from typing import Any, Callable, Optional
from ..driver import driver, Player, MudObject

async def write(player: Player, msg: str):
    """Write a message to a player."""
    await player.send(msg)

async def call_out(delay: float, func: Callable, *args):
    """Schedule a function to run after a delay."""
    await driver.call_out(delay, func, *args)

def add_action(obj: MudObject, verb: str, func: Callable):
    """Bind a verb to an action on an object."""
    obj.add_action(verb, func)

def move_object(obj: MudObject, destination: Optional[MudObject]):
    """Move an object to a new location."""
    if obj.location:
        obj.location.attrs.get("contents", []).remove(obj.oid)
    obj.location = destination
    if destination:
        contents = destination.attrs.get("contents", [])
        contents.append(obj.oid)
        destination.attrs["contents"] = contents
    driver.save_object(obj)
    if destination:
        driver.save_object(destination)

async def call_other(oid: str, verb: str, caller: Player, arg: str = None) -> str:
    """Call a verb on another object."""
    return await driver.call_other(oid, verb, caller, arg)

def this_object() -> Optional[MudObject]:
    """Return the current object in the call stack."""
    return driver.this_object()

def previous_object() -> Optional[MudObject]:
    """Return the previous object in the call stack."""
    return driver.previous_object()

def clone_object(obj: MudObject) -> MudObject:
    """Clone an object."""
    return obj.clone()

def destruct(obj: MudObject):
    """Destroy an object."""
    obj.destruct()

def map_array(arr: list, func: Callable) -> list:
    """Map a function over an array."""
    return list(map(func, arr))

def filter_array(arr: list, func: Callable) -> list:
    """Filter an array with a function."""
    return list(filter(func, arr))

async def catch(func: Callable, *args) -> tuple[Any, Optional[str]]:
    """Catch errors in a function call."""
    try:
        result = await func(*args)
        return result, None
    except Exception as e:
        return None, str(e)

def shadow(obj: MudObject, func: Callable):
    """Shadow an object's method with a new function."""
    # Simplified shadowing - extend as needed
    obj.actions["shadowed"] = func

def seteuid(obj: MudObject, euid: str):
    """Set the effective user ID of an object."""
    driver.seteuid(obj, euid)

def geteuid(obj: MudObject) -> str:
    """Get the effective user ID of an object."""
    return driver.geteuid(obj)

async def read_file(path: str) -> str:
    """Read a file asynchronously."""
    return await driver.read_file(path)

async def write_file(path: str, content: str):
    """Write to a file asynchronously."""
    await driver.write_file(path, content)

def uptime() -> int:
    """Return the driver's uptime in seconds."""
    return driver.uptime()

# /mnt/home2/mud/efuns/network.py
from ..driver import driver, Player

def socket_create(mode: str, callback: Callable) -> int:
    """Create a socket (placeholder - extend for actual socket use)."""
    # Future: Implement actual socket creation
    return 0

def query_ip_number(player: Player) -> str:
    """Get the IP address of a player."""
    return player.ip_address

def query_idle(player: Player) -> int:
    """Get the idle time of a player in seconds."""
    return int(time.time() - player.last_active)

# /mnt/home2/mud/efuns/parser.py
from ..driver import driver, Player

def query_verb() -> Optional[str]:
    """Get the last verb executed."""
    return driver.query_verb()

async def notify_fail(player: Player, msg: str) -> str:
    """Notify a player of a failed action."""
    return await driver.notify_fail(player, msg)

# /mnt/home2/mud/efuns/skills.py
from ..driver import driver, Player

async def teach(player: Player, target: str, skill: str):
    """Teach a skill to another player."""
    target_obj = None
    for p in driver.players.values():
        if p.name.lower() == target.lower():
            target_obj = p
            break
    if not target_obj:
        await player.send(f"No one named {target} is online.")
        return
    if skill not in player.attrs.get("skills", {}):
        await player.send(f"You don’t know the skill {skill}!")
        return
    target_obj.attrs.setdefault("skills", {})[skill] = player.attrs["skills"][skill]
    await target_obj.send(f"{player.name} teaches you {skill}!")
    await player.send(f"You teach {target} the skill {skill}.")

async def learn(player: Player, skill: str, teacher: str):
    """Learn a skill from a teacher."""
    teacher_obj = None
    for p in driver.players.values():
        if p.name.lower() == teacher.lower():
            teacher_obj = p
            break
    if not teacher_obj:
        await player.send(f"No one named {teacher} is online.")
        return
    if skill not in teacher_obj.attrs.get("skills", {}):
        await player.send(f"{teacher} doesn’t know the skill {skill}!")
        return
    player.attrs.setdefault("skills", {})[skill] = teacher_obj.attrs["skills"][skill]
    await player.send(f"You learn {skill} from {teacher}!")
    await teacher_obj.send(f"{player.name} learns {skill} from you!")

async def advance(player: Player, skill: str, level: int):
    """Advance a skill to a new level."""
    if skill not in player.attrs.get("skills", {}):
        await player.send(f"You don’t know the skill {skill}!")
        return
    player.attrs["skills"][skill] = level
    await player.send(f"You advance your {skill} to level {level}!")

# /mnt/home2/mud/efuns/tools.py
from ..driver import driver, Player

async def profile(func: Callable, *args):
    """Profile a function’s performance."""
    await driver.profile(func, *args)

async def cluster_sync():
    """Synchronize state across a cluster (placeholder)."""
    # Future: Implement Redis pub/sub for clustering
    driver.redis.publish("mud_sync", json.dumps(driver.mud_status()))

async def mount(player: Player, mount: str):
    """Mount a creature for faster movement."""
    mount_obj = None
    for oid in player.location.attrs.get("contents", []):
        if oid in driver.objects and driver.objects[oid].name.lower() == mount.lower():
            mount_obj = driver.objects[oid]
            break
    if not mount_obj:
        await player.send(f"No {mount} here to mount!")
        return
    player.attrs["mount"] = mount_obj.oid
    await player.send(f"You mount the {mount}!")

async def flag_pk(player: Player, status: bool):
    """Flag a player for PK in raid zones."""
    player.pk_flagged = status
    await player.send(f"You are now {'PK-flagged' if status else 'not PK-flagged'}.")

async def pledge_house(player: Player, house: str):
    """Pledge allegiance to a noble house."""
    house_obj = None
    for oid in driver.objects:
        if driver.objects[oid].name.lower() == house.lower():
            house_obj = driver.objects[oid]
            break
    if not house_obj:
        await player.send(f"No house named {house} exists!")
        return
    player.attrs["house"] = house_obj.oid
    await player.send(f"You pledge allegiance to {house}!")

# /mnt/home2/mud/systems/armour_logic.py
from typing import Dict, Optional, List
from ..driver import driver, Player, MudObject
import asyncio
import random
import math

class Armour:
    def __init__(self, oid: str, name: str, ac: Dict[str, int], coverage: Dict[str, float], weight: int, condition: int = 100):
        self.oid = oid
        self.name = name
        self.attrs: Dict = {
            "ac": ac,  # Armor class by damage type (slashing, piercing, etc.)
            "coverage": coverage,  # Percentage coverage per zone (0.0-1.0)
            "weight": weight,  # In pounds, affects burden
            "condition": condition,  # 0-100, degrades with damage
            "is_armour": True,
            "is_shield": False,
            "enchantment": 0  # Bonus AC from magic (Forgotten Realms)
        }

    def query_ac(self, damage_type: str, zone: str) -> int:
        base_ac = self.attrs["ac"].get(damage_type, 0)
        enchantment_bonus = self.attrs["enchantment"]
        condition_factor = max(0, min(1, self.attrs["condition"] / 100))
        coverage = self.attrs["coverage"].get(zone, 0.0)
        return int((base_ac + enchantment_bonus) * condition_factor * coverage)

    def query_weight(self) -> int:
        return self.attrs["weight"]

    def query_condition(self) -> int:
        return self.attrs["condition"]

    def adjust_condition(self, damage_taken: int) -> bool:
        if self.attrs["condition"] <= 0:
            return False
        degradation = random.randint(1, max(1, damage_taken // 5))
        self.attrs["condition"] = max(0, self.attrs["condition"] - degradation)
        self.driver.save_object(self)
        return self.attrs["condition"] > 0

    def apply_enchantment(self, bonus: int) -> bool:
        if bonus < 0 or self.attrs["condition"] <= 0:
            return False
        self.attrs["enchantment"] = max(0, self.attrs["enchantment"] + bonus)
        self.driver.save_object(self)
        return True

class ArmourLogic:
    def __init__(self):
        self.armour: Dict[str, Armour] = {}

    async def init(self, driver_instance):
        self.driver = driver_instance
        for obj in self.driver.objects.values():
            if hasattr(obj, "attrs") and obj.attrs.get("is_armour", False):
                self.armour[obj.oid] = Armour(obj.oid, obj.name, obj.attrs.get("ac", {}),
                                             obj.attrs.get("coverage", {}), obj.attrs.get("weight", 5),
                                             obj.attrs.get("condition", 100))
                obj.add_action("judge", self.judge_armour)

    async def judge_armour(self, obj: MudObject, caller: Player, arg: str) -> str:
        if not isinstance(caller, Player) or caller.oid != obj.oid:
            return "You can only judge your own armour."
        if obj.oid not in self.armour:
            return "This is not valid armour."
        armour = self.armour[obj.oid]
        ac_summary = ", ".join(f"{dt}: {ac}" for dt, ac_dict in armour.attrs["ac"].items() for zone, ac in ac_dict.items())
        return (f"You judge {obj.name} as providing AC {ac_summary}, weighing {armour.query_weight()} lbs, "
                f"with condition {armour.query_condition()}%.")

    def query_armour(self, obj: MudObject) -> Optional[Armour]:
        return self.armour.get(obj.oid)

    def register_armour(self, obj: MudObject, name: str, ac: Dict[str, int], coverage: Dict[str, float],
                       weight: int, condition: int = 100) -> Armour:
        if obj.oid not in self.armour:
            armour = Armour(obj.oid, name, ac, coverage, weight, condition)
            self.armour[obj.oid] = armour
            obj.attrs.update(armour.attrs)
            self.driver.save_object(obj)
        return self.armour[obj.oid]

    def calculate_protection(self, armour: Armour, damage_type: str, damage: int, zone: str) -> int:
        stopped = armour.query_ac(damage_type, zone)
        effective_stopped = min(damage, stopped)
        if effective_stopped > 0:
            armour.adjust_condition(effective_stopped)
        return effective_stopped

# Initialize armour logic handler
armour_logic = ArmourLogic()

async def init(driver_instance):
    await armour_logic.init(driver_instance)

# /mnt/home2/mud/systems/chatter.py
from typing import List, Optional, Union
from ..driver import driver, MudObject
import asyncio
import random
import time

class Chatter(MudObject):
    def __init__(self, oid: str, name: str):
        super().__init__(oid, name)
        self.room: Optional[MudObject] = None
        self.chats: Optional[List] = None
        self.min_interval: int = 120
        self.max_interval: int = 240
        self.last_chat: float = 0

    def setup_chatter(self, room: MudObject, args: List):
        """Sets up the chatter with room and chat arguments."""
        self.room = room
        if len(args) >= 3 and isinstance(args[0], int) and isinstance(args[1], int) and isinstance(args[2], list):
            self.min_interval = args[0]
            self.max_interval = args[1]
            self.chats = args[2]
        driver.call_out(self.check_chat, random.randint(self.min_interval, self.max_interval))

    def set_chat_min_max(self, min: int, max: int):
        """Adjusts the minimum and maximum chat intervals."""
        self.min_interval = max(1, min)
        self.max_interval = max(max, self.min_interval)

    def add_room_chats(self, new_chats: List[str]):
        """Adds new chat messages to the existing list."""
        if self.chats:
            self.chats.extend(new_chats)
        else:
            self.chats = new_chats
        driver.call_out(self.check_chat, random.randint(self.min_interval, self.max_interval))

    def remove_room_chats(self, dead_chats: List[str]):
        """Removes specified chat messages."""
        if self.chats:
            self.chats = [chat for chat in self.chats if chat not in dead_chats]
            if not self.chats:
                self.dest_me()

    def query_room_chats(self) -> Optional[List]:
        """Returns the current chat messages."""
        return self.chats.copy() if self.chats else None

    async def check_chat(self):
        """Checks if it's time to send a chat message."""
        if not self.room or not self.chats or time.time() - self.last_chat < self.min_interval:
            return
        if random.random() < 0.5:  # Simplified probability check
            chat = random.choice(self.chats)
            if chat.startswith("#"):
                chat = getattr(self.room, chat[1:], lambda: "Unknown chat function")()
            self.room.tell_room(chat)
            self.last_chat = time.time()
        driver.call_out(self.check_chat, random.randint(self.min_interval, self.max_interval))

    def dest_me(self):
        """Destroys the chatter object."""
        self.room = None
        self.chats = None
        self.destruct()

async def init(driver_instance):
    driver = driver_instance

# /mnt/home2/mud/systems/classes.py
from typing import Dict, List, Optional, Tuple
from ..driver import driver, Player, MudObject
import asyncio

class ClassHandler:
    # Rethemed Discworld guilds to Forgotten Realms classes
    CLASSES: Dict[str, Dict] = {
        "Fighter": {
            "skill_bonuses": {"fighting.combat.melee": 10, "fighting.combat.tactics": 5},
            "description": "A master of martial combat.",
            "commands": ["strike"],
            "max_level": 300
        },
        "Rogue": {
            "skill_bonuses": {"covert.manipulation.stealing": 10, "fighting.combat.dodge": 5},
            "description": "A stealthy trickster adept at sneaking.",
            "commands": ["sneak", "steal"],
            "max_level": 300
        },
        "Mage": {
            "skill_bonuses": {"magic.spellcasting": 10, "other.perception": 5},
            "description": "A wielder of arcane magic.",
            "commands": ["cast"],
            "max_level": 300
        },
        "Cleric": {
            "skill_bonuses": {"magic.spellcasting": 5, "fighting.combat.parry": 5},
            "description": "A divine servant channeling divine power.",
            "commands": ["heal"],
            "max_level": 300
        }
    }

    def __init__(self):
        self.classes: Dict[str, List[MudObject]] = {}  # Class name to list of members

    async def init(self, driver_instance):
        self.driver = driver_instance
        for player in driver.players:
            player.add_action("class", self.class_command)
            player.add_action("party", self.party_command)

    # Class Methods (retaining Discworld guild mechanics)
    async def class_command(self, obj: MudObject, caller: Player, arg: str) -> str:
        if not isinstance(caller, Player) or caller.oid != obj.oid:
            return "Only players can manage their class."
        args = arg.lower().split()
        if not args:
            return self.display_classes(caller)
        command = args[0]
        if command == "join":
            if len(args) < 2:
                return "Syntax: class join <class_name>"
            return await self.join_class(caller, args[1])
        elif command == "leave":
            return await self.leave_class(caller)
        elif command == "info":
            return self.display_classes(caller)
        return "Syntax: class [join|leave|info] [class_name]"

    async def join_class(self, player: Player, class_name: str) -> str:
        class_name = class_name.capitalize()
        if class_name not in self.CLASSES:
            return f"Unknown class '{class_name}'. Available classes: {', '.join(self.CLASSES.keys())}"
        if player.attrs.get("class"):
            return "You must leave your current class before joining another."
        if not await self.check_join_requirements(player, class_name):
            return "You do not meet the requirements to join this class."
        self.classes.setdefault(class_name, []).append(player)
        player.attrs["class"] = class_name
        player.attrs["class_level"] = 1
        self.apply_class_bonuses(player, class_name)
        return f"You have joined the {class_name} class! {self.CLASSES[class_name]['description']}"

    async def check_join_requirements(self, player: Player, class_name: str) -> bool:
        # Placeholder for Discworld guild-style requirements (e.g., skill levels)
        return True  # Implement specific requirements as needed

    async def leave_class(self, player: Player) -> str:
        class_name = player.attrs.get("class")
        if not class_name:
            return "You are not a member of any class."
        if not await self.check_leave_conditions(player, class_name):
            return "You cannot leave this class at this time."
        self.classes[class_name].remove(player)
        if not self.classes[class_name]:
            del self.classes[class_name]
        self.remove_class_bonuses(player, class_name)
        player.attrs.pop("class")
        player.attrs["class_level"] = 0
        return f"You have left the {class_name} class."

    async def check_leave_conditions(self, player: Player, class_name: str) -> bool:
        # Placeholder for Discworld guild-style leave conditions
        return True  # Implement specific conditions as needed

    def display_classes(self, player: Player) -> str:
        current_class = player.attrs.get("class")
        level = player.attrs.get("class_level", 0)
        output = "Available classes:\n"
        for class_name, data in self.CLASSES.items():
            output += f"  {class_name}: {data['description']} (Max Level: {data['max_level']})\n"
        if current_class:
            output += f"\nYou are a level {level} {current_class}."
        else:
            output += "\nYou are not a member of any class."
        return output

    def apply_class_bonuses(self, player: Player, class_name: str):
        bonuses = self.CLASSES[class_name]["skill_bonuses"]
        for skill, bonus in bonuses.items():
            current = player.attrs["skills"].get(skill, 0)
            player.attrs["skills"][skill] = current + bonus

    def remove_class_bonuses(self, player: Player, class_name: str):
        bonuses = self.CLASSES[class_name]["skill_bonuses"]
        for skill, bonus in bonuses.items():
            current = player.attrs["skills"].get(skill, 0)
            player.attrs["skills"][skill] = max(0, current - bonus)

    def query_class(self, player: Player) -> Optional[str]:
        return player.attrs.get("class")

    def query_class_level(self, player: Player) -> int:
        return player.attrs.get("class_level", 0)

    def set_class_level(self, player: Player, level: int):
        max_level = self.CLASSES.get(player.attrs.get("class"), {}).get("max_level", 300)
        player.attrs["class_level"] = max(1, min(max_level, level))

    def advancement_restriction(self, player: Player) -> bool:
        level = self.query_class_level(player)
        max_level = self.CLASSES.get(player.attrs.get("class"), {}).get("max_level", 300)
        return level >= max_level

    # Party Methods (retaining Discworld group mechanics)
    async def party_command(self, obj: MudObject, caller: Player, arg: str) -> str:
        if not isinstance(caller, Player) or caller.oid != obj.oid:
            return "Only players can manage parties."
        args = arg.lower().split()
        if not args:
            return self.display_party(caller)
        command = args[0]
        if command == "create":
            if len(args) < 2:
                return "Syntax: party create <party_name>"
            return await self.create_party(caller, args[1])
        elif command == "join":
            if len(args) < 2:
                return "Syntax: party join <party_name>"
            return await self.join_party(caller, args[1])
        elif command == "leave":
            return await self.leave_party(caller)
        elif command == "info":
            return self.display_party(caller)
        return "Syntax: party [create|join|leave|info] [party_name]"

    async def create_party(self, player: Player, party_name: str) -> str:
        if player.attrs.get("party"):
            return "You must leave your current party before creating a new one."
        if party_name in self.parties:
            return f"A party named '{party_name}' already exists."
        if not await self.check_party_create(player, party_name):
            return "You cannot create a party at this time."
        self.parties[party_name] = [player]
        player.attrs["party"] = party_name
        return f"You have created the party '{party_name}'."

    async def check_party_create(self, player: Player, party_name: str) -> bool:
        # Placeholder for Discworld group creation restrictions
        return True  # Implement specific restrictions as needed

    async def join_party(self, player: Player, party_name: str) -> str:
        if player.attrs.get("party"):
            return "You must leave your current party before joining another."
        if party_name not in self.parties:
            return f"No party named '{party_name}' exists."
        if not await self.check_party_join(player, party_name):
            return "You cannot join this party at this time."
        self.parties[party_name].append(player)
        player.attrs["party"] = party_name
        return f"You have joined the party '{party_name}'."

    async def check_party_join(self, player: Player, party_name: str) -> bool:
        # Placeholder for Discworld group join restrictions
        return True  # Implement specific restrictions as needed

    async def leave_party(self, player: Player) -> str:
        party_name = player.attrs.get("party")
        if not party_name:
            return "You are not a member of any party."
        if not await self.check_party_leave(player, party_name):
            return "You cannot leave this party at this time."
        self.parties[party_name].remove(player)
        if not self.parties[party_name]:
            del self.parties[party_name]
        player.attrs.pop("party")
        return f"You have left the party '{party_name}'."

    async def check_party_leave(self, player: Player, party_name: str) -> bool:
        # Placeholder for Discworld group leave conditions
        return True  # Implement specific conditions as needed

    def display_party(self, player: Player) -> str:
        party_name = player.attrs.get("party")
        if not party_name:
            return "You are not a member of any party."
        members = self.parties[party_name]
        output = f"Party '{party_name}':\n"
        for member in members:
            output += f"  {member.name} (Level {self.query_class_level(member)} {self.query_class(member)})\n"
        return output

    def share_xp(self, party_name: str, xp: int):
        if party_name not in self.parties:
            return
        members = self.parties[party_name]
        xp_per_member = xp // len(members)
        for member in members:
            member.attrs["xp"] = member.attrs.get("xp", 0) + xp_per_member

    parties: Dict[str, List[MudObject]] = {}  # Party name to list of members

class_handler = ClassHandler()

async def init(driver_instance):
    await class_handler.init(driver_instance)

# /mnt/home2/mud/systems/combat.py
from typing import Dict, Optional, List, Tuple, Callable
from ..driver import driver, Player, MudObject
from .tactics import Tactics  # Import Tactics from tactics.py
import asyncio
import random
import math
import json

class CombatSpecial:
    def __init__(self, special_id: int, type_: int, events: int, callback: Callable, data: dict):
        self.id = special_id
        self.type_ = type_  # T_OFFENSIVE, T_DEFENSIVE, T_CONTINUOUS
        self.events = events  # E_OPPONENT_SELECTION, etc.
        self.callback = callback
        self.data = data

class Attack:
    def __init__(self, attacker: Player, opponent: Optional[MudObject] = None):
        self.attacker = attacker
        self.opponent = opponent
        self.defender = opponent
        self.person_hit = opponent
        self.attacker_tactics = attacker.attrs.get("tactics", Tactics())
        self.attacker_specials: List[CombatSpecial] = attacker.attrs.get("specials", [])
        self.attacker_concentrating = attacker.attrs.get("concentrating", None)
        self.attacker_defecit = attacker.attrs.get("action_defecit", 0)
        self.attacker_last_opponent = attacker.attrs.get("last_opponent", None)
        self.attacker_last_weapon = attacker.attrs.get("last_weapon", None)
        self.attacker_last_action = attacker.attrs.get("last_action", "none")
        self.attacker_last_result = attacker.attrs.get("last_result", 0)
        self.defender_tactics = Tactics()
        self.defender_specials: List[CombatSpecial] = []
        self.defender_concentrating = None
        self.defender_defecit = 0
        self.defender_last_opponent = None
        self.defender_last_action = "none"
        self.defender_last_result = 0
        self.attack_weapon = None
        self.attack_data = None
        self.attack_skill = "fighting.combat.melee"
        self.attack_modifier = 0
        self.attack_cost = 0
        self.defense_action = "none"
        self.defense_weapon = None
        self.defense_skill = "fighting.combat.dodge"
        self.defense_modifier = 0
        self.defense_cost = 0
        self.distance = 0
        self.target_zone = "chest"
        self.result = 0  # OFFWIN, OFFAWARD, DEFWIN, DEFAWARD
        self.degree = 0  # TASKER_CRITICAL, TASKER_EXCEPTIONAL, TASKER_MARGINAL
        self.damage = 0
        self.armour_stopped = 0
        self.stopped_by = None
        self.attack_messages = ["", "", "", "", ""]
        self.defense_messages = ["", "", "", "", ""]
        self.repeat = False

class CombatHandler:
    # Constants from combat.h
    T_OFFENSIVE = 1
    T_DEFENSIVE = 2
    T_CONTINUOUS = 4
    E_OPPONENT_SELECTION = 1
    E_DEFENDER_SELECTION = 2
    E_ATTACK_SELECTION = 4
    E_DEFENSE_SELECTION = 8
    E_ATTACK_MODIFIER = 16
    E_DEFENSE_MODIFIER = 32
    E_DAMAGE_CALCULATION = 64
    E_ARMOUR_CALCULATION = 128
    E_WEAPON_DAMAGE = 256
    E_WRITE_MESSAGES = 512
    E_AFTER_ATTACK = 1024
    R_CONTINUE = 0
    R_DONE = 1
    R_ABORT = 2
    R_REMOVE_ME = 4
    OFFAWARD = 1
    OFFWIN = 2
    DEFAWARD = 3
    DEFWIN = 4
    TASKER_CRITICAL = 1
    TASKER_EXCEPTIONAL = 2
    TASKER_MARGINAL = 3
    COMBAT_SPEED = 1
    INITIAL_DISTANCE = 2
    REACH = 5
    ATTACK_COST = 10
    DEFENSE_COST = 8
    MAX_ACTION_DEFECIT = 100
    MIN_ACTION_DEFECIT = -100
    HUNTING_TIME = 300
    BALANCE_MOD = 0
    OFFENSIVE_DEFECITS = {"insane": 50, "offensive": 25, "neutral": 0, "defensive": -25, "wimp": -50}
    DEFENSIVE_DEFECITS = {"insane": -50, "offensive": -25, "neutral": 0, "defensive": 25, "wimp": 50}
    DEFENSE_GP = {"insane": 5, "offensive": 3, "neutral": 2, "defensive": 1, "wimp": 0}
    USE_DISTANCE = True

    def __init__(self):
        self.combatants: Dict[str, str] = {}  # {player_oid: target_oid}
        self.hunting: Dict[str, int] = {}  # {player_oid: timestamp}
        self.surrender_to: Dict[str, List[str]] = {}  # {player_oid: [surrenderers]}
        self.surrender_from: Dict[str, List[str]] = {}  # {player_oid: [attackers]}
        self.special_id_counter = 0
        self.damage_types = ["slashing", "piercing", "bludgeoning", "magic", "blunt"]

    async def init(self, driver_instance):
        self.driver = driver_instance
        for obj in self.driver.objects.values():
            if hasattr(obj, "add_action"):
                obj.add_action("attack", self.attack)
                obj.add_action("flee", self.flee)
                obj.add_action("surrender", self.surrender)

    async def attack(self, attacker: MudObject, player: Player, target_name: str) -> str:
        if not isinstance(player, Player) or not player.location:
            return "You cannot fight from nowhere!"
        if not self.can_attack(player):
            return "You are unable to attack right now!"

        target = self.find_target(player, target_name)
        if not target:
            return f"No {target_name} here to attack!"

        if not self.attack_by(player, target):
            return "You cannot attack this target!"

        att = Attack(attacker=player, opponent=target)
        await self.do_attack(att)
        return f"You attack {target.name}!"

    async def flee(self, fleeing: MudObject, player: Player, arg: str) -> str:
        if not isinstance(player, Player) or player.oid not in self.combatants:
            return "You are not in combat!"
        target_oid = self.combatants.get(player.oid)
        if target_oid:
            self.stop_fight(player, self.driver.objects[target_oid])
            await player.send("You flee from combat!")
            return await player.location.call("move", player, "random")
        return "No combat to flee from!"

    async def surrender(self, surrendering: MudObject, player: Player, target_name: str) -> str:
        if not isinstance(player, Player) or player.oid not in self.combatants:
            return "You are not in combat!"
        target = self.find_target(player, target_name)
        if not target:
            return f"No {target_name} to surrender to!"
        await self.event_surrender(player, target)
        return f"You surrender to {target.name}."

    def find_target(self, player: Player, target_name: str) -> Optional[MudObject]:
        for oid in player.location.attrs.get("contents", []):
            if oid in self.driver.objects and self.driver.objects[oid].name.lower() == target_name.lower():
                return self.driver.objects[oid]
        return None

    def can_attack(self, obj: MudObject) -> bool:
        if (obj.attrs.get("passed_out", False) or
            obj.attrs.get("dead", False) or
            obj.attrs.get("hp", 100) < 0 or
            obj.attrs.get("casting_spell", False) or
            (isinstance(obj, Player) and not obj.connected) or
            obj.attrs.get("cannot_attack", False)):
            return False
        return True

    def can_defend(self, obj: MudObject) -> bool:
        if (obj.attrs.get("passed_out", False) or
            obj.attrs.get("dead", False) or
            obj.attrs.get("hp", 100) < 0 or
            obj.attrs.get("casting_spell", False) or
            (isinstance(obj, Player) and not obj.connected) or
            obj.attrs.get("cannot_defend", False)):
            return False
        return True

    def query_attackable(self, obj: MudObject) -> bool:
        if (obj.attrs.get("passed_out", False) or
            obj.attrs.get("dead", False) or
            obj.attrs.get("hp", 100) < 0 or
            (isinstance(obj, Player) and not obj.connected)):
            return False
        return True

    def attack_by(self, attacker: MudObject, opponent: MudObject) -> bool:
        if (not opponent or attacker.oid == opponent.oid or
            not self.query_attackable(opponent) or
            self.pk_check(attacker, opponent)):
            return False

        attacker.attrs["protectors"] = [p for p in attacker.attrs.get("protectors", []) if p != opponent.oid]
        attacker.attrs["defenders"] = [d for d in attacker.attrs.get("defenders", []) if d != opponent.oid]

        if not self.is_fighting(attacker, opponent, actively=True):
            if self.USE_DISTANCE:
                self.combatants[opponent.oid] = self.INITIAL_DISTANCE
            else:
                self.combatants[opponent.oid] = 1
            attacker.attrs["action_defecit"] = (self.MAX_ACTION_DEFECIT - self.MIN_ACTION_DEFECIT) // 3

        self.combatants[attacker.oid] = opponent.oid
        return True

    def pk_check(self, attacker: MudObject, opponent: MudObject) -> bool:
        # Simplified PK check - to be expanded based on rules
        return False

    async def do_attack(self, att: Attack):
        # Initialize combat state
        att.attacker.attrs["in_combat"] = True

        # Choose opponent
        att = self.choose_opponent(att)
        if not att.opponent or not self.attack_by(att.attacker, att.opponent):
            return

        # Main combat loop
        while True:
            # Choose defender
            att = self.choose_defender(att)

            # Choose attack
            att = self.choose_attack(att)
            if not att.attack_weapon or not att.attack_data:
                return

            # Choose defense
            att = self.choose_defense(att)

            # Calculate modifiers
            att = self.calc_attack_modifier(att)
            if att.defense_action == "none":
                att.defense_modifier -= 1000
            else:
                att = self.calc_defense_modifier(att)

            # Compare skills
            modifier = att.attack_modifier - att.defense_modifier + self.BALANCE_MOD
            if modifier > 25:
                modifier = int(math.sqrt(modifier * 25))
            elif modifier < -25:
                modifier = -int(math.sqrt(-modifier * 25))

            result = self.compare_skills(att.attacker, att.attack_skill, att.defender, att.defense_skill, modifier)
            att.result = result[0]
            att.degree = result[1]

            # Handle defender failure
            if (att.result in [self.OFFWIN, self.OFFAWARD] and att.defender != att.opponent and not att.repeat):
                att.defender.attrs["action_defecit"] = att.defender.attrs.get("action_defecit", 0) + att.defense_cost
                att.defender.attrs["gp"] = att.defender.attrs.get("gp", 100) - self.DEFENSE_GP.get(att.defender_tactics.attitude, 0)
                att.defender = att.opponent
                att.repeat = True
            else:
                att.repeat = False
                break

        # Calculate damage
        att = self.calc_damage(att)

        # Calculate armor protection
        att = self.calc_armour_protection(att)

        # Prepare messages
        att = self.prepare_messages(att)

        # Write messages
        await self.write_messages(att)

        # Apply damage
        if att.damage - att.armour_stopped > 0:
            att.person_hit.attrs["hp"] = att.person_hit.attrs.get("hp", 100) - (att.damage - att.armour_stopped)
            self.driver.save_object(att.person_hit)
            if att.person_hit.attrs["hp"] <= 0:
                await self.die(att.person_hit, att.attacker)

        # Damage weapons
        att = self.damage_weapon(att)

        # Post-attack cleanup
        await self.after_attack(att)

        # Update action defecit
        att.attacker.attrs["action_defecit"] = att.attacker.attrs.get("action_defecit", 0) + att.attack_cost
        att.defender.attrs["action_defecit"] = att.defender.attrs.get("action_defecit", 0) + att.defense_cost

    def choose_opponent(self, att: Attack) -> Attack:
        opponents = [self.driver.objects[oid] for oid in self.combatants if oid != att.attacker.oid and self.driver.objects[oid].location == att.attacker.location]
        opponents = [opp for opp in opponents if self.query_attackable(opp)]

        if not opponents:
            return att

        if att.attacker_concentrating in opponents:
            att.opponent = att.attacker_concentrating
        else:
            # Simple NPC algorithm: pick random or weakest
            choice = random.randint(0, 2)
            if choice == 0:
                att.opponent = random.choice(opponents)
            elif choice == 1:
                att.opponent = min(opponents, key=lambda opp: opp.attrs.get("hp", 100))
            else:
                att.opponent = max(opponents, key=lambda opp: opp.attrs.get("hp", 100))

        if self.USE_DISTANCE:
            att.distance = self.combatants.get(att.opponent.oid, self.INITIAL_DISTANCE)

        if len(opponents) == 1:
            att.attacker.attrs["concentrating"] = att.opponent

        return att

    def choose_defender(self, att: Attack) -> Attack:
        protectors = [self.driver.objects[p] for p in att.opponent.attrs.get("protectors", []) if p in self.driver.objects and self.driver.objects[p].location == att.attacker.location]
        protectors = [p for p in protectors if self.query_protect(p) and not self.pk_check(p, att.attacker)]

        if protectors:
            for p in protectors:
                self.attack_by(p, att.attacker)
            att.person_hit = random.choice(protectors)

        defenders = [self.driver.objects[d] for d in att.opponent.attrs.get("defenders", []) if d in self.driver.objects and self.driver.objects[d].location == att.attacker.location]
        defenders = [d for d in defenders if self.query_defend(d) and not self.pk_check(d, att.attacker)]

        if defenders:
            for d in defenders:
                self.attack_by(d, att.attacker)
            att.defender = random.choice(defenders)

        if not att.person_hit:
            att.person_hit = att.opponent
        if not att.defender:
            att.defender = att.opponent

        return att

    def query_protect(self, obj: MudObject) -> bool:
        if not self.query_attackable(obj) or obj.attrs.get("casting_spell", False) or obj.attrs.get("gp", 100) < 1:
            return False
        return obj.attrs.get("action_defecit", 0) < (self.COMBAT_ACTION_TIME * 4)

    def query_defend(self, obj: MudObject) -> bool:
        if not self.query_attackable(obj) or obj.attrs.get("casting_spell", False) or obj.attrs.get("gp", 100) < 1:
            return False
        tactics = obj.attrs.get("tactics", Tactics())
        return (tactics.response in ["parry", "both"]) and obj.attrs.get("action_defecit", 0) < (self.COMBAT_ACTION_TIME * 4)

    def choose_attack(self, att: Attack) -> Attack:
        if not self.can_attack(att.attacker):
            return att

        if att.attacker_defecit > self.OFFENSIVE_DEFECITS.get(att.attacker_tactics.attitude, 0):
            return att

        weapons = att.attacker.attrs.get("holding", [])
        limbs = att.attacker.attrs.get("limbs", ["left hand", "right hand"])
        hand = att.attacker_tactics.attack

        if hand != "both":
            idx = next((i for i, limb in enumerate(limbs) if limb.startswith(hand)), -1)
            if idx != -1:
                if not weapons[idx]:
                    weapons = []
                elif weapons[idx].attrs.get("is_weapon", False):
                    weapons = [weapons[idx]]

        if len(weapons) > 1:
            weapons = list(set(w for w in weapons if w and w.attrs.get("is_weapon", False)))

        if not weapons:
            att.attack_weapon = att.attacker
        elif len(weapons) == 1:
            att.attack_weapon = weapons[0]
        else:
            if self.USE_DISTANCE:
                att.attack_weapon = min(weapons, key=lambda w: abs(self.REACH + w.attrs.get("length", 5) - att.distance))
            else:
                att.attack_weapon = random.choice(weapons)

        perc = 75 + att.attacker.attrs.get("str", 10) + att.attacker.attrs.get("dex", 10)
        if att.attack_weapon != att.attacker:
            perc -= att.attack_weapon.attrs.get("weight", 5) // 2
        perc = max(25, perc)

        attacks = self.weapon_attacks(att.attack_weapon, perc, att.defender)
        if not attacks:
            return att

        which_attack = random.randint(0, len(attacks) // 5 - 1)
        att.attack_data = attacks[which_attack * 5:(which_attack + 1) * 5]

        if att.attack_data[0] == "hands" and not att.attacker.attrs.get("free_limbs", 0):
            att.attack_data = None
            return att

        att.attack_skill = att.attack_data[1] if att.attack_data[1] else "fighting.combat.melee"

        # Choose target zone
        zones = att.opponent.attrs.get("target_zones", ["head", "chest", "arms", "legs"])
        if att.attacker_tactics.focus_zone == "upper body":
            zone = random.choice(zones[:len(zones)//2])
        elif att.attacker_tactics.focus_zone == "lower body":
            zone = random.choice(zones[len(zones)//2:])
        elif att.attacker_tactics.focus_zone and att.attacker_tactics.focus_zone != "none":
            zone = att.attacker_tactics.focus_zone
        else:
            sz = att.attacker.attrs.get("height", 6) / att.opponent.attrs.get("height", 6)
            if att.attack_data[0] == "hands":
                sz *= 2
            elif att.attack_data[0] == "feet":
                sz /= 2
            if sz > 1.5:
                zone = zones[random.randint(0, random.randint(0, len(zones)-1))]
            elif sz < 0.75:
                idx = random.randint(0, len(zones) + 9)
                zone = zones[min(idx, len(zones)-1)]
            else:
                zone = random.choice(zones)
        att.target_zone = zone

        actions = self.ATTACK_COST
        if att.attack_weapon != att.attacker:
            limbs_count = sum(1 for w in att.attacker.attrs.get("holding", []) if w == att.attack_weapon)
            actions += int(math.sqrt(att.attack_weapon.attrs.get("weight", 5)) * 3) // (limbs_count + 1)
        if len(att.attacker.attrs.get("weapons", [])) > 1:
            actions -= self.ATTACK_COST // 4
        actions -= (att.attacker.attrs.get("skills", {}).get(att.attack_skill, 10) + att.attacker.attrs.get("skills", {}).get("fighting.combat.tactics", 10)) // 50
        att.attack_cost = max(self.ATTACK_COST // 5, min(self.ATTACK_COST * 2, actions))

        return att

    def weapon_attacks(self, weapon: MudObject, perc: int, defender: MudObject) -> List:
        if weapon == defender:
            return [["hands", "fighting.combat.unarmed", 10, "blunt", perc]]
        return [["slash", "fighting.combat.melee", weapon.attrs.get("damage", 15), weapon.attrs.get("damage_type", "slashing"), perc]]

    def choose_defense(self, att: Attack) -> Attack:
        if att.defender != att.opponent and att.defender_defecit > self.DEFENSIVE_DEFECITS.get(att.defender_tactics.attitude, 0):
            att.defense_action = "none"
            return att

        response = att.defender_tactics.response
        if att.defender != att.opponent:
            if response == "dodge":
                att.defense_action = "none"
                return att
            response = "parry"
        elif not response or response == "neutral":
            response = random.choice(["parry", "dodge"])

        if response == "parry":
            weapons = att.defender.attrs.get("holding", [])
            hand = att.defender_tactics.parry
            limbs = att.defender.attrs.get("limbs", ["left hand", "right hand"])
            which = next((i for i, limb in enumerate(limbs) if limb.startswith(hand)), -1)

            if which != -1:
                if weapons[which]:
                    att.defense_action = "parry"
                    att.defense_skill = "fighting.combat.parry"
                    att.defense_weapon = weapons[which]
                elif att.defender_tactics.parry_unarmed:
                    att.defense_action = "parry"
                    att.defense_skill = "fighting.combat.unarmed"
                    att.defense_weapon = att.defender
                    att.defense_limb = limbs[which]
            else:
                weapons = [w for w in weapons if w]
                if not weapons and att.defender_tactics.parry_unarmed:
                    att.defense_action = "parry"
                    att.defense_skill = "fighting.combat.unarmed"
                    att.defense_weapon = att.defender
                elif weapons:
                    att.defense_action = "parry"
                    att.defense_skill = "fighting.combat.parry"
                    att.defense_weapon = random.choice(weapons)
        else:
            att.defense_action = "dodge"
            att.defense_skill = "fighting.combat.dodge"
            att.defense_weapon = None

        actions = self.DEFENSE_COST
        actions -= (att.defender.attrs.get("skills", {}).get(att.defense_skill, 10) + att.defender.attrs.get("skills", {}).get("fighting.combat.tactics", 10)) // 50
        if att.defense_weapon and att.defense_weapon != att.defender:
            if att.defense_weapon.attrs.get("is_shield", False):
                actions += int(math.sqrt(att.defense_weapon.attrs.get("weight", 5) / 4))
            else:
                limbs_count = sum(1 for w in att.defender.attrs.get("holding", []) if w == att.defense_weapon)
                actions += int(math.sqrt(att.defense_weapon.attrs.get("weight", 5) * 2) // (limbs_count + 1))
            if len(att.defender.attrs.get("weapons", [])) > 1:
                actions -= self.DEFENSE_COST // 4
        elif att.defense_action == "dodge":
            actions += int(math.sqrt(att.defender.attrs.get("burden", 0)))
        att.defense_cost = max(self.DEFENSE_COST // 5, min(self.DEFENSE_COST * 2, actions))

        return att

    def calc_attack_modifier(self, att: Attack) -> Attack:
        mod = wep = hld = lght = mntd = hlth = brdn = dist = tact = targ = oth = num = 0
        dex = att.attacker.attrs.get("dex", 10)
        attack_weapon = att.attack_weapon

        if attack_weapon != att.attacker:
            holding = att.attacker.attrs.get("holding", [])
            limbs = sum(1 for w in holding if w == attack_weapon)
            tmp2 = sum(w.attrs.get("weight", 5) if not w.attrs.get("is_shield", False) else w.attrs.get("weight", 5) // 5 for w in holding if w and w != attack_weapon)

            if att.attacker_tactics.response == "both":
                tmp2 = (tmp2 * 3) // 2
            elif att.attacker_tactics.response == "dodge" and tmp2 < dex:
                tmp2 //= 2

            wep = attack_weapon.attrs.get("weight", 5) + (tmp2 // 2)
            wep //= (limbs + 1)
            wep -= att.attacker.attrs.get("str", 10)
            if wep > 0:
                wep = -int(math.pow(wep, 1.4))

            if dex < 14 and holding and holding[0] != attack_weapon:
                hld = dex - 14
        else:
            wep = (dex * 2) - att.attacker.attrs.get("burden", 0)

        light_level = att.attacker.location.attrs.get("light", 0)
        if light_level in [-2, 2]:
            lght = -50
        elif light_level in [-1, 1]:
            lght = -25

        mntd = 0  # Placeholder for mounted combat

        hlth -= (50 - (att.attacker.attrs.get("hp", 100) * 50) // att.attacker.attrs.get("max_hp", 100))
        tmp = att.attacker.attrs.get("gp", 100)
        if tmp < -50:
            hlth += -25
        elif tmp < 0:
            hlth += tmp // 2

        brdn -= att.attacker.attrs.get("burden", 0) // 3

        if self.USE_DISTANCE:
            if att.attack_weapon == att.attacker:
                dist = -3 * abs(self.REACH - att.distance)
            else:
                dist = -3 * abs(self.REACH + att.attack_weapon.attrs.get("length", 5) - att.distance)

        tact = {"insane": 25, "offensive": 15, "defensive": -25, "wimp": -50}.get(att.attacker_tactics.attitude, 0)

        if att.attacker_tactics.focus_zone in ["upper body", "lower body"]:
            targ -= 25
        elif att.attacker_tactics.focus_zone and att.attacker_tactics.focus_zone != "none":
            zones = att.opponent.attrs.get("target_zones", ["head", "chest", "arms", "legs"])
            tmp = sum(1 for zone in zones if zone == att.target_zone)
            num_zones = len(zones)
            targ -= ((num_zones - tmp) * 25 // num_zones)

        attackers = [self.driver.objects[oid] for oid in self.combatants if self.driver.objects[oid].location == att.attacker.location]
        idx = attackers.index(att.attacker) if att.attacker in attackers else -1
        if idx > 1:
            num += -25 * idx

        if att.attacker_tactics.attack == "both":
            oth += 5

        att.attack_modifier += wep + hld + lght + mntd + hlth + brdn + dist + tact + targ + oth + num
        return att

    def calc_defense_modifier(self, att: Attack) -> Attack:
        mod = wep = wght = dist = brdn = hnd = lght = hlth = tact = prot = oth = 0
        dex = att.defender.attrs.get("dex", 10)

        if att.defense_action == "parry" and att.defense_weapon:
            holding = att.defender.attrs.get("holding", [])
            limbs = sum(1 for w in holding if w == att.defense_weapon)
            if att.defense_weapon.attrs.get("is_shield", False):
                wep = att.defense_weapon.attrs.get("weight", 5) // 5
            else:
                wep = att.defense_weapon.attrs.get("weight", 5) * 2
            wep //= (limbs + 2)
            if wep > att.defender.attrs.get("str", 10):
                wep = -int(math.pow(wep - att.defender.attrs.get("str", 10), 1.3))

            if att.attack_weapon != att.attacker:
                wght = 2 * (att.defense_weapon.attrs.get("weight", 5) - att.attack_weapon.attrs.get("weight", 5))
            else:
                wght = att.defense_weapon.attrs.get("weight", 5) // 2
            wght = min(5, wght)

            if self.USE_DISTANCE:
                dist = -abs(self.REACH + att.defense_weapon.attrs.get("length", 5) - att.distance)

            brdn = -(att.defender.attrs.get("burden", 0) // 3)

            if holding:
                if dex < 14 and holding[0] != att.defense_weapon:
                    hnd = dex - 14
                holding = list(set(w for w in holding if w))
                if dex < 16 and len(holding) == 1:
                    hnd += dex - 16
        elif att.defense_action == "dodge":
            brdn = -(att.defender.attrs.get("burden", 0) // 3)
            if dex < (att.defender.attrs.get("burden", 0) // 2):
                brdn -= dex - (att.defender.attrs.get("burden", 0) // 2)
            if att.attack_weapon != att.attacker:
                wght = att.attack_weapon.attrs.get("weight", 5) // 10

        light_level = att.defender.location.attrs.get("light", 0)
        if not att.attacker.attrs.get("visible", True):
            lght = -100
        elif light_level in [-2, 2]:
            lght = -50
        elif light_level in [-1, 1]:
            lght = -25

        hlth = -(25 - (att.defender.attrs.get("hp", 100) * 25) // att.defender.attrs.get("max_hp", 100))
        tmp = att.defender.attrs.get("gp", 100)
        if tmp < -50:
            hlth += -25
        elif tmp < 0:
            hlth += tmp // 2

        tact = {"insane": -50, "offensive": -25, "defensive": 15, "wimp": 25}.get(att.defender_tactics.attitude, 0)

        if att.defender != att.opponent:
            if att.defender != att.person_hit:
                if att.defense_weapon and att.defense_weapon.attrs.get("is_shield", False):
                    prot -= 15
                prot -= 15
            prot -= 15

        if att.defender_tactics.response == "both":
            oth += 5
        if att.defender.attrs.get("casting_spell", False):
            oth -= 25

        att.defense_modifier += wep + wght + dist + brdn + hnd + lght + hlth + tact + prot + oth
        return att

    def compare_skills(self, attacker: MudObject, attack_skill: str, defender: MudObject, defense_skill: str, modifier: int) -> Tuple[int, int]:
        atk_skill = attacker.attrs.get("skills", {}).get(attack_skill, 10)
        def_skill = defender.attrs.get("skills", {}).get(defense_skill, 10)
        chance = 50 + (atk_skill - def_skill) + modifier
        chance = max(5, min(95, chance))
        roll = random.random() * 100
        if roll < chance:
            degree = self.TASKER_CRITICAL if roll < chance * 0.1 else self.TASKER_EXCEPTIONAL if roll < chance * 0.3 else self.TASKER_MARGINAL
            return (self.OFFWIN, degree)
        else:
            degree = self.TASKER_CRITICAL if roll > chance * 1.9 else self.TASKER_EXCEPTIONAL if roll > chance * 1.7 else self.TASKER_MARGINAL
            return (self.DEFWIN, degree)

    def calc_damage(self, att: Attack) -> Attack:
        damage = att.attack_data[3] if att.attack_data else 10
        weapon_damage = damage
        if att.attack_weapon != att.attacker:
            damage = int(math.sqrt(damage * att.attacker.attrs.get("skills", {}).get(att.attack_skill, 10)))
        damage = min(3 * weapon_damage, damage)
        damage *= self.COMBAT_SPEED
        att.damage = damage

        if att.result in [self.OFFAWARD, self.OFFWIN]:
            if att.degree == self.TASKER_CRITICAL:
                att.damage *= 2
            elif att.degree == self.TASKER_EXCEPTIONAL:
                att.damage = (att.damage * 3) // 2
            elif att.degree == self.TASKER_MARGINAL:
                att.damage //= 2
        else:
            if att.degree == self.TASKER_CRITICAL:
                att.defense_cost = 0
            elif att.degree == self.TASKER_EXCEPTIONAL:
                att.defense_cost //= 2
            elif att.degree == self.TASKER_MARGINAL:
                att.defense_cost *= 2
            att.damage = 0

        return att

    def calc_armour_protection(self, att: Attack) -> Attack:
        if not att.damage or att.result not in [self.OFFWIN, self.OFFAWARD]:
            return att

        armour_zone = att.person_hit.attrs.get("armour_zones", {}).get(att.target_zone, "chest")
        damage_type = att.attack_data[2] if att.attack_data else "blunt"
        if damage_type == "unarmed":
            damage_type = "blunt"

        ac = att.person_hit.attrs.get("ac", {}).get(damage_type, {}).get(armour_zone, 0)
        att.armour_stopped = min(att.damage, ac)
        att.stopped_by = att.person_hit.attrs.get("armour", {}).get(armour_zone, "leather armor")

        return att

    def damage_weapon(self, att: Attack) -> Attack:
        off_damage = def_damage = 0
        if att.result in [self.OFFAWARD, self.OFFWIN]:
            if att.armour_stopped and att.degree:
                off_damage = att.armour_stopped // att.degree
        elif att.result in [self.DEFWIN, self.DEFAWARD] and att.defense_action == "parry" and att.damage and att.degree:
            off_damage = att.damage * (att.degree - 1)
            def_damage = att.damage // att.degree

        if off_damage:
            if att.attack_weapon == att.attacker:
                if att.attack_weapon.attrs.get("hp", 100) > (off_damage // 10):
                    att.attack_weapon.attrs["hp"] -= off_damage // 10
            else:
                att.attack_weapon.attrs["hp"] = att.attack_weapon.attrs.get("hp", 100) - off_damage

        if def_damage:
            if att.defense_weapon == att.defender:
                att.defense_weapon.attrs["hp"] = att.defense_weapon.attrs.get("hp", 100) - def_damage
            else:
                att.defense_weapon.attrs["hp"] = att.defense_weapon.attrs.get("hp", 100) - def_damage

        return att

    def prepare_messages(self, att: Attack) -> Attack:
        if att.result in [self.OFFAWARD, self.OFFWIN]:
            if att.person_hit == att.opponent:
                att.attack_messages = [
                    f"You hit {att.opponent.name} in the {att.target_zone}!",
                    f"{att.attacker.name} hits you in the {att.target_zone}!",
                    f"{att.attacker.name} hits {att.opponent.name} in the {att.target_zone}!",
                    f"{att.attacker.name} hits {att.opponent.name} in the {att.target_zone}!",
                    f"{att.attacker.name} hits you in the {att.target_zone}!"
                ]
            else:
                att.attack_messages = [
                    f"You almost hit {att.opponent.name} but {att.person_hit.name} protects them!",
                    f"{att.attacker.name} almost hits you but {att.person_hit.name} protects you!",
                    f"{att.attacker.name} almost hits {att.opponent.name} but {att.person_hit.name} protects them!",
                    f"{att.attacker.name} almost hits {att.opponent.name} but {att.person_hit.name} protects them!",
                    f"You leap in and protect {att.opponent.name} from {att.attacker.name}!"
                ]
        else:
            att.attack_messages = [
                f"You try to hit {att.opponent.name} in the {att.target_zone}!",
                f"{att.attacker.name} tries to hit you in the {att.target_zone}!",
                f"{att.attacker.name} tries to hit {att.opponent.name} in the {att.target_zone}!",
                f"{att.attacker.name} tries to hit {att.opponent.name} in the {att.target_zone}!",
                f"{att.attacker.name} tries to hit {att.opponent.name} in the {att.target_zone}!"
            ]

        if att.result in [self.OFFAWARD, self.OFFWIN] and att.armour_stopped and att.armour_stopped > att.damage // 3:
            msg = f" but {att.stopped_by} absorbs "
            msg += "all of" if att.armour_stopped >= att.damage else "most of" if att.armour_stopped > (att.damage * 2 // 3) else "some of"
            msg += " the blow"
            att.defense_messages = [msg] * 5

        return att

    async def write_messages(self, att: Attack):
        await att.attacker.send(att.attack_messages[0] + att.defense_messages[0])
        await att.opponent.send(att.attack_messages[1] + att.defense_messages[1])
        for oid in att.attacker.location.attrs.get("contents", []):
            if oid not in [att.attacker.oid, att.opponent.oid, att.defender.oid, att.person_hit.oid]:
                await self.driver.call_other(oid, "receive_message", att.attacker, att.attack_messages[2] + att.defense_messages[2])
        if att.defender != att.opponent:
            await att.defender.send(att.attack_messages[3] + att.defense_messages[3])
        if att.person_hit != att.opponent:
            await att.person_hit.send(att.attack_messages[4] + att.defense_messages[4])

    async def die(self, target: MudObject, attacker: Player):
        await target.send("You have been defeated!")
        if isinstance(target, Player):
            target.attrs["hp"] = 100
            target.location = self.driver.objects["ethereal_veil_start"]
            self.driver.save_object(target)
            await target.send("You awaken in the Ethereal Veil...")
        else:
            del self.driver.objects[target.oid]
        self.stop_fight(target, attacker)

    async def after_attack(self, att: Attack):
        # Placeholder for post-attack cleanup
        pass

    def stop_fight(self, obj: MudObject, opponent: MudObject):
        if obj.oid in self.combatants:
            del self.combatants[obj.oid]
        if opponent.oid in self.combatants:
            del self.combatants[opponent.oid]
        if obj.oid in self.hunting:
            del self.hunting[obj.oid]
        if opponent.oid in self.hunting:
            del self.hunting[opponent.oid]
        self.surrender_to[obj.oid] = [s for s in self.surrender_to.get(obj.oid, []) if s != opponent.oid]
        self.surrender_from[obj.oid] = [s for s in self.surrender_from.get(obj.oid, []) if s != opponent.oid]

    async def event_surrender(self, victim: Player, attacker: MudObject):
        mercy = attacker.attrs.get("tactics", Tactics()).mercy
        self.surrender_to[victim.oid] = self.surrender_to.get(victim.oid, []) + [attacker.oid]

        if mercy == "ask":
            if isinstance(attacker, Player):
                self.surrender_from[attacker.oid] = self.surrender_from.get(attacker.oid, []) + [victim.oid]
                await attacker.send(f"{victim.name} has surrendered to you. Use 'accept {victim.name}' or 'reject {victim.name}'.")
            else:
                # NPC logic - accept for now
                await self.accepted_surrender(victim, attacker)
        elif mercy == "always":
            await self.accepted_surrender(victim, attacker)
        else:
            await self.refused_surrender(victim, attacker)

    async def accepted_surrender(self, victim: Player, attacker: MudObject):
        self.surrender_to[victim.oid] = [s for s in self.surrender_to.get(victim.oid, []) if s != attacker.oid]
        await victim.send(f"{attacker.name} accepts your surrender.")
        self.stop_fight(victim, attacker)

    async def refused_surrender(self, victim: Player, attacker: MudObject):
        self.surrender_to[victim.oid] = [s for s in self.surrender_to.get(victim.oid, []) if s != attacker.oid]
        await victim.send(f"{attacker.name} refuses your surrender.")

    def is_fighting(self, obj: MudObject, opponent: MudObject, actively: bool = False) -> bool:
        if actively:
            return obj.oid in self.combatants and self.combatants[obj.oid] == opponent.oid
        return obj.oid in self.combatants or obj.oid in self.hunting

# Initialize combat handler
combat_handler = CombatHandler()

async def init(driver_instance):
    await combat_handler.init(driver_instance)

# /mnt/home2/mud/systems/door.py
from typing import Optional, Union, Dict, List
from ..driver import driver, MudObject

class Door(MudObject):
    def __init__(self, oid: str, name: str):
        super().__init__(oid, name)
        self.attrs["state"] = "closed"  # Default state
        self.attrs["locked"] = False  # Default unlocked
        self.attrs["direction"] = ""
        self.attrs["destination"] = ""
        self.attrs["owner_room"] = None
        self.attrs["door_name"] = ""

    def setup_door(self, direc: str, owner: MudObject, dest: str, door_data: Dict, type: str):
        """Sets up the door with given configuration."""
        self.attrs["direction"] = direc
        self.attrs["destination"] = dest
        self.attrs["owner_room"] = owner
        self.attrs["state"] = door_data.get("state", "closed")
        self.attrs["locked"] = door_data.get("locked", False)
        self.attrs["door_name"] = direc  # Default door name, can be modified
        self.set_short(f"{direc} door")
        self.set_long(f"This is a {type} door leading {direc} to {dest}.")
        self.add_alias("door")

    def query_open(self) -> bool:
        """Returns whether the door is open."""
        return self.attrs["state"] == "open"

    def set_open(self, state: bool):
        """Sets the door's open/closed state."""
        self.attrs["state"] = "open" if state else "closed"

    def query_locked(self) -> bool:
        """Returns whether the door is locked."""
        return self.attrs["locked"]

    def set_locked(self, state: bool):
        """Sets the door's locked state."""
        self.attrs["locked"] = state

    def query_door_name(self) -> str:
        """Returns the door's name."""
        return self.attrs["door_name"]

    def tell_door(self, message: str, thing: MudObject):
        """Sends a message to the room via the door."""
        if self.attrs["owner_room"]:
            self.attrs["owner_room"].tell_room(message, [thing])

    def multiple_hidden(self) -> int:
        """Returns the number of rooms this door is hidden in (simplified)."""
        return 1  # Assume single room for now

    def dest_me(self):
        """Destroys the door object."""
        self.destruct()

async def init(driver_instance):
    driver = driver_instance

# /mnt/home2/mud/systems/languages.py
from typing import Dict, Optional
from ..driver import driver, Player, MudObject
import asyncio
import random
import json

class LanguageHandler:
    def __init__(self):
        self.languages = {
            "common": {"spoken": 100, "written": 100, "garble_obj": None, "native_to": ["human", "halfling", "gnome"]},
            "drow": {"spoken": 0, "written": 0, "garble_obj": "drow_garble", "native_to": ["drow"]},
            "elvish": {"spoken": 0, "written": 0, "garble_obj": "elvish_garble", "native_to": ["elf"]},
            "dwarvish": {"spoken": 0, "written": 0, "garble_obj": "dwarvish_garble", "native_to": ["dwarf"]},
            "draconic": {"spoken": 0, "written": 0, "garble_obj": "draconic_garble", "native_to": ["dragonborn"]},
            "orcish": {"spoken": 0, "written": 0, "garble_obj": "orcish_garble", "native_to": ["orc", "goblin"]},
            "abyssal": {"spoken": 0, "written": 0, "garble_obj": "abyssal_garble", "native_to": ["tiefling"]},
            "undercommon": {"spoken": 0, "written": 0, "garble_obj": "undercommon_garble", "native_to": ["drow"]},
            "giant": {"spoken": 0, "written": 0, "garble_obj": "giant_garble", "native_to": ["goliath"]}
        }
        self.grunt = {"spoken": 100, "written": 0, "garble_obj": "grunt_garble"}  # Universal but unintelligible
        self.garble_tables = {
            "drow_garble": {"A": "Z", "E": "Y", "I": "X", "O": "W", "U": "V"},
            "elvish_garble": {"A": "Q", "E": "P", "I": "O", "O": "N", "U": "M"},
            "dwarvish_garble": {"A": "R", "E": "S", "I": "T", "O": "U", "U": "V"},
            "draconic_garble": {"A": "H", "E": "J", "I": "K", "O": "L", "U": "M"},
            "orcish_garble": {"A": "G", "E": "F", "I": "D", "O": "C", "U": "B"},
            "abyssal_garble": {"A": "X", "E": "W", "I": "V", "O": "U", "U": "T"},
            "undercommon_garble": {"A": "Y", "E": "Z", "I": "W", "O": "V", "U": "U"},
            "giant_garble": {"A": "P", "E": "Q", "I": "R", "O": "S", "U": "T"},
            "grunt_garble": {"": lambda x: "".join(random.choices("grh", k=len(x)))}
        }
        self.teachers = {
            "waterdeep": {"npc": "Librarian", "teaches": ["common", "elvish", "dwarvish"]},
            "menzoberranzan": {"npc": "Drow Matron", "teaches": ["drow", "undercommon"]}
        }

    async def init(self, driver_instance):
        self.driver = driver_instance
        for player in self.driver.players.values():
            race = player.attrs.get("race", "human")
            for lang, data in self.languages.items():
                if race in data.get("native_to", []):
                    data["spoken"] = 100
                    data["written"] = 100
                    break

    async def set_language(self, player: Player, lang: str) -> bool:
        if lang in self.languages or lang == "grunt":
            player.attrs["current_lang"] = lang
            await player.send(f"You set your language to {lang}.")
            return True
        await player.send("Unknown language!")
        return False

    async def speak(self, player: Player, msg: str) -> str:
        current_lang = player.attrs.get("current_lang", "common")
        if current_lang == "grunt":
            return await self.garble_text(msg, "grunt_garble", player)
        lang_data = self.languages.get(current_lang, {"spoken": 0})
        if lang_data["spoken"] < 60:
            await player.send("Your speech is unintelligible to others!")
            return ""
        garbled = await self.garble_text(msg, current_lang, player)
        for oid in player.location.attrs.get("contents", []):
            if oid in self.driver.objects and oid != player.oid:
                await self.driver.call_other(oid, "receive_message", player, garbled)
        return f"You say in {current_lang}: {msg}"

    async def write(self, player: Player, msg: str) -> str:
        current_lang = player.attrs.get("current_lang", "common")
        lang_data = self.languages.get(current_lang, {"written": 0})
        if lang_data["written"] == 0:
            await player.send("You cannot write this language!")
            return ""
        garbled = await self.garble_text(msg, current_lang, player)
        return f"You write in {current_lang}: {garbled}"

    async def garble_text(self, text: str, lang: str, player: Player) -> str:
        if lang not in self.garble_tables:
            return text
        garble_table = self.garble_tables.get(lang, {})
        words = text.split()
        garbled_words = []
        for word in words:
            if random.random() < max(0.2, 1 - (player.attrs.get("skills", {}).get(f"{lang}_spoken", 0) / 100)):
                if callable(garble_table.get("")):
                    garbled_words.append(garble_table[""](word))
                else:
                    garbled = "".join(garble_table.get(c, c) for c in word)
                    garbled_words.append(garbled)
            else:
                garbled_words.append(word)
        return " ".join(garbled_words)

    async def learn_language(self, player: Player, lang: str, mode: str) -> bool:
        if lang not in self.languages:
            await player.send("Unknown language!")
            return False
        teacher = self.find_teacher(player.location.oid)
        if not teacher or lang not in teacher["teaches"]:
            await player.send("No teacher available for this language here!")
            return False
        current_spoken = self.languages[lang]["spoken"]
        current_written = self.languages[lang]["written"]
        if mode == "spoken" and current_spoken < 90:
            self.languages[lang]["spoken"] = min(90, current_spoken + 10)
            await player.send(f"You gain 10 spoken {lang} levels (now {self.languages[lang]['spoken']}).")
        elif mode == "written" and current_written < 90:
            self.languages[lang]["written"] = min(90, current_written + 10)
            await player.send(f"You gain 10 written {lang} levels (now {self.languages[lang]['written']}).")
        return True

    def find_teacher(self, room_oid: str) -> Optional[dict]:
        for zone, teacher in self.teachers.items():
            if zone in room_oid.lower():
                return teacher
        return None

# Initialize language handler
language_handler = LanguageHandler()

async def init(driver_instance):
    await language_handler.init(driver_instance)

# /mnt/home2/mud/systems/library.py
from typing import Dict, List, Optional
from ..driver import driver, Player, MudObject
import asyncio
import os

class Library:
    def __init__(self):
        self.SAVE_FILE = "/save/library"
        self.player_quests: Dict[str, List[str]] = {}
        self.load_library()

    def load_library(self):
        try:
            data = driver.load_object(self.SAVE_FILE)
            if data:
                self.player_quests = data.get("player_quests", {})
        except:
            self.player_quests = {}

    def save_library(self):
        data = {"player_quests": self.player_quests}
        driver.save_object(self.SAVE_FILE, data)

    def query_quest_points(self, name: str) -> int:
        if not name or not driver.player_handler.test_user(name):
            return 0
        return sum(quest_handler.query_quest_level(q) for q in self.query_quests(name) if q in quest_handler.query_quest_names())

    def query_quests(self, name: str) -> List[str]:
        if not name or not driver.player_handler.test_user(name):
            return []
        return self.player_quests.get(name, [])

    def query_quest_done(self, name: str, quest: str) -> bool:
        if not name or not driver.player_handler.test_user(name) or quest not in quest_handler.query_quest_names():
            return False
        return quest in self.player_quests.get(name, [])

    def record_quest_completion(self, name: str, quest: str):
        if not name or not driver.player_handler.test_user(name) or quest not in quest_handler.query_quest_names():
            return
        if quest not in self.player_quests.get(name, []):
            self.player_quests.setdefault(name, []).append(quest)
            self.save_library()
            quest_handler.quest_completed(name, quest, driver.previous_object())

library = Library()

async def init(driver_instance):
    driver = driver_instance
    # No player actions needed for library, handled via quest_handler

# Ensure quest_handler uses library for completions
from .quest import quest_handler
quest_handler.quest_completed = lambda name, quest, prev_ob: library.record_quest_completion(name, quest)

# /mnt/home2/mud/systems/living.py
from typing import Dict, List, Optional, Tuple, Union, Callable, ClassVar
from ..driver import driver, Player, MudObject
from .classes import class_handler, ClassHandler
from .quest import quest_handler, QuestHandler
from .library import library, Library
import asyncio
import random
import math

class living_data:
    def __init__(self):
        self.handicap = 0
        self.burden = 0
        self.followers = []
        self.it_them = None
        self.to_drop = []
        self.burden_call = None

class messages:
    def __init__(self):
        self.msgin = "$N arrive$s from $F."
        self.msgout = "$N leave$s $T."
        self.mmsgin = "$N appear$s out of the ground."
        self.mmsgout = "$N disappear$s in a puff of smoke."

# Constants from /include/living.h
MAX_AL = 10000
MAX_FAVOUR = 100
VERBOSE_TYPES = ["combat", "look", "score", "names", "htell", "finger", "errors", "quit"]
STANDING = "standing"
POSITION_ARRAY_SIZE = 3
POS_ON_OBJECT = 0
POS_MULTIPLE = 1
POS_TYPE = 2
POSITION_TYPE_INDEX = 0
POSITION_ME_MESS_INDEX = 1
POSITION_REST_MESS = 2
POSITION_ONLY_TYPE_SIZE = 1
POSITION_MESS_SIZE = 3
MAX_CREATOR_INVEN = 100
MAX_INVEN = 50
WILL_POWER = 1000
REL_DIRS = ["forward", "right forward", "right", "right backward", "backward", "left backward", "left", "left forward"]
ABS_FACING = {
    "north": 0, "northeast": 1, "east": 2, "southeast": 3,
    "south": 4, "southwest": 5, "west": 6, "northwest": 7
}
LENGTHEN = {"n": "north", "ne": "northeast", "e": "east", "se": "southeast",
            "s": "south", "sw": "southwest", "w": "west", "nw": "northwest"}

class Living(MudObject):
    def __init__(self, oid: str, name: str):
        super().__init__(oid, name)
        self.attrs: Dict = {}
        self._liv_data = living_data()
        self._messages = messages()
        self.alignment = 0
        self.facing = [0, ["north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest"], ["up", "down"]]
        self.verbose = {t: 1 for t in VERBOSE_TYPES}
        self.deity = None
        self.deity_favour = {}
        self.position = STANDING
        self.default_position = None
        self.always_use_default_position = 0
        self.position_on = None
        self.max_items = 50
        self.attrs["adjectives"] = self.attrs.get("adjectives", []) + ["living"]
        self.attrs["skills"] = {}
        self.attrs["money"] = {}
        self.attrs["max_hp"] = 100
        self.attrs["hp"] = 100
        self.attrs["max_gp"] = 100
        self.attrs["gp"] = 100
        self.attrs["drink_info"] = {"alcohol": 0, "food": 0, "drink": 0}
        self.attrs["xp"] = 0
        self.attrs["guild"] = None
        self.attrs["guild_level"] = 0
        living_handler.set_living_name(name, self)

    async def heart_beat(self):
        pass  # Placeholder for stats and combat heartbeats

    def query_pronoun(self) -> str:
        gender = self.attrs.get("gender", 0)
        return {0: "it", 1: "he", 2: "she"}.get(gender, "it")

    def query_possessive(self) -> str:
        gender = self.attrs.get("gender", 0)
        return {0: "its", 1: "his", 2: "her"}.get(gender, "its")

    def query_objective(self) -> str:
        gender = self.attrs.get("gender", 0)
        return {0: "it", 1: "him", 2: "her"}.get(gender, "it")

    def query_weight(self, actual: bool = False) -> int:
        if not actual and self.attrs.get("dead", False):
            return 0
        return self.attrs.get("weight", 0)

    def query_burden(self) -> int:
        return self._liv_data.burden

    def query_handicap(self) -> int:
        return self._liv_data.handicap

    def calc_burden(self):
        self._liv_data.burden_call = None
        burden = sum(obj.query_complete_weight() for obj in self.inventory)
        for thing in self.attrs.get("wearing", []):
            burden -= thing.query_complete_weight() // 2
        hands = {}
        for thing in self.attrs.get("holding", []):
            hands[thing] = hands.get(thing, 0) + 1
        for thing, count in hands.items():
            burden += thing.query_complete_weight() // count
        max_weight = self.query_max_weight()
        self._liv_data.burden = 50 if not max_weight else (100 * burden) // max_weight
        new_handicap = max(0, (self._liv_data.burden // 25) - 1)
        if self._liv_data.handicap != new_handicap:
            self.adjust_bonus_dex(self._liv_data.handicap - new_handicap)
            self._liv_data.handicap = new_handicap

    def burden_string(self) -> str:
        handicap = self._liv_data.handicap
        if handicap == 0:
            return "unburdened"
        elif handicap == 1:
            return "burdened"
        elif handicap == 2:
            return "heavily burdened"
        elif handicap == 3:
            return "very heavily burdened"
        return "incredibly heavily burdened"

    def eat_this(self, food: MudObject):
        asyncio.create_task(self.command(f"eat {food.oid}"))

    def test_add(self, ob: MudObject, flag: int) -> bool:
        if len(self.inventory) > self.max_items:
            return False
        return not flag

    def test_remove(self, ob: MudObject, flag: int, dest: Union[str, MudObject]) -> bool:
        if flag:
            return False
        if not self.driver.this_player() or self.driver.this_player() == self:
            return not flag
        if isinstance(dest, str):
            thing = self.driver.objects.get(dest)
        elif isinstance(dest, MudObject):
            thing = dest
            dest = thing.oid
        else:
            thing = None
        if thing and (thing.attrs.get("corpse", False) or dest == "/room/rubbish"):
            return not flag
        if self.attrs.get("passed_out", False):
            return False
        self.driver.event(self.environment, "theft", self.driver.this_player(), self, ob)
        return not flag

    def query_al(self) -> int:
        return self.alignment

    def set_al(self, number: int):
        self.alignment = number

    def adjust_al(self, number: int) -> int:
        self.alignment += number
        self.alignment = max(-MAX_AL, min(MAX_AL, self.alignment))
        return self.alignment

    def adjust_alignment(self, number: int) -> int:
        change = -(number + self.alignment // 5) // 20
        return self.adjust_al(change)

    def align_string(self) -> str:
        al = self.alignment
        if al <= -5001:
            return "extremely good"
        elif al <= -2501:
            return "very good"
        elif al <= -1251:
            return "quite good"
        elif al <= -601:
            return "good"
        elif al <= -301:
            return "barely good"
        elif al <= 300:
            return "neutral"
        elif al <= 600:
            return "barely evil"
        elif al <= 1250:
            return "evil"
        elif al <= 2500:
            return "quite evil"
        elif al <= 5000:
            return "very evil"
        return "extremely evil"

    def query_deity(self) -> Optional[str]:
        return self.deity

    def set_deity(self, word: str):
        self.deity = word

    def query_msgin(self) -> str:
        return self._messages.msgin

    def query_msgout(self) -> str:
        return self._messages.msgout

    def set_msgin(self, str_: str) -> bool:
        if "$N" not in str_ or "$F" not in str_:
            return False
        self._messages.msgin = str_
        return True

    def set_msgout(self, str_: str) -> bool:
        if "$N" not in str_ or "$T" not in str_:
            return False
        self._messages.msgout = str_
        return True

    def query_mmsgin(self) -> str:
        return self._messages.mmsgin

    def query_mmsgout(self) -> str:
        return self._messages.mmsgout

    def set_mmsgin(self, str_: str) -> bool:
        if "$N" not in str_:
            return False
        self._messages.mmsgin = str_
        return True

    def set_mmsgout(self, str_: str) -> bool:
        if "$N" not in str_:
            return False
        self._messages.mmsgout = str_
        return True

    def query_facing(self) -> List:
        return self.facing.copy()

    def set_facing(self, args: List):
        self.facing = args

    def find_rel(self, word: str, from_: int) -> str:
        i = self.facing[1].index(word)
        if i != -1:
            i = (i + 8 - self.facing[0]) % 8
            return REL_DIRS[3 * i + from_]
        i = self.facing[2].index(word)
        if i != -1:
            return ["up", "down"][i]
        return word

    def find_abs(self, word: str) -> str:
        i = REL_DIRS.index(word)
        if i != -1:
            i = (i // 3 + self.facing[0]) % 8
            return self.facing[1][i]
        i = ["up", "down"].index(word)
        if i != -1:
            return self.facing[2][i]
        return word

    def reorient_rel(self, word: str) -> str:
        i = REL_DIRS.index(word)
        if i != -1:
            i = (i // 3 + self.facing[0]) % 8
            self.facing[0] = i
            return self.facing[1][i]
        i = ["up", "down"].index(word)
        if i != -1:
            return self.facing[2][i]
        return word

    def reorient_abs(self, verb: str):
        if verb in ABS_FACING:
            self.facing[0] = ABS_FACING[verb] % 8

    def set_dragging(self, thing: MudObject):
        self.attrs["dragging"] = thing

    def query_dragging(self) -> Optional[MudObject]:
        return self.attrs.get("dragging")

    def reset_dragging(self):
        self.attrs["dragging"] = None

    async def room_look(self) -> bool:
        if self.attrs.get("unknown_move", False) or not (self.attrs.get("interactive", False) or self.attrs.get("slave", False)):
            return False
        if self.verbose.get("look", 1):
            await self.command("look")
        else:
            await self.command("glance")
        return True

    def query_verbose(self, type_: str) -> int:
        return self.verbose.get(type_, 1)

    def set_verbose(self, type_: str, val: int):
        if type_ in VERBOSE_TYPES:
            self.verbose[type_] = val

    def query_verbose_types(self) -> List[str]:
        return VERBOSE_TYPES

    async def move_with_look(self, dest: Union[str, MudObject], messin: str = "", messout: str = "") -> bool:
        self.return_to_default_position(1)
        if not await self.move(dest, messin, messout):
            return False
        await self.room_look()
        self.return_to_default_position(1)
        return True

    async def exit_command(self, word: str, verb: Union[str, List] = None, thing: MudObject = None, redirection: bool = False) -> bool:
        if not self.environment:
            return False
        if not verb:
            verb = word
            bits = word.split()
            word = " ".join(bits[1:]) if len(bits) > 1 else ""
        else:
            if isinstance(verb, list):
                special_mess, verb = verb[1], verb[0]
            bits = verb.split()
            word = " ".join(bits[1:]) if len(bits) > 1 else ""
        verb = LENGTHEN.get(verb, verb)
        exits = self.environment.attrs.get("exits", [])
        if verb not in exits:
            verb = self.find_abs(verb)
            if verb not in exits:
                return False
        if verb in ABS_FACING:
            self.facing[0] = ABS_FACING[verb] % 8
        thing = thing or self
        # Placeholder for exit_move via room_handler
        return True

    def become_flummoxed(self):
        will = self.attrs.get("int", 10) * self.attrs.get("wis", 10)
        if will < random.randint(0, WILL_POWER):
            self.attrs["interrupt_ritual"] = True
        if will < random.randint(0, WILL_POWER):
            self.attrs["interrupt_spell"] = True
        if will < random.randint(0, WILL_POWER):
            self.attrs["stop_fight"] = True

    async def run_away(self) -> bool:
        direcs = self.environment.attrs.get("dest_dir", [])
        old_env = self.environment
        while direcs:
            i = random.randint(0, len(direcs) // 2 - 1) * 2
            if await self.exit_command(direcs[i]):
                self.driver.event(old_env, "run_away", direcs[i], direcs[i + 1])
                return True
            direcs = direcs[:i] + direcs[i+2:]
        return False

    def stats(self) -> List[Tuple[str, Union[int, str]]]:
        return [
            ("max_hp", self.attrs.get("max_hp", 0)),
            ("hp", self.attrs.get("hp", 0)),
            ("max_gp", self.attrs.get("max_gp", 0)),
            ("gp", self.attrs.get("gp", 0)),
            ("alcohol", self.attrs["drink_info"].get("alcohol", 0)),
            ("food", self.attrs["drink_info"].get("food", 0)),
            ("drink", self.attrs["drink_info"].get("drink", 0)),
            ("gender", self.attrs.get("gender", 0)),
            ("alignment", self.query_al()),
            ("deity", self.deity or "None"),
            ("total money", self.attrs.get("money", {}).get("value", 0)),
            ("xp", self.attrs.get("xp", 0))
        ]

    def query_it_them(self) -> Optional[List[MudObject]]:
        return self._liv_data.it_them

    def set_it_them(self, args: List[MudObject]):
        self._liv_data.it_them = args

    def add_follower(self, ob: MudObject) -> bool:
        if ob == self or ob in self._liv_data.followers:
            return False
        self._liv_data.followers.append(ob)
        return True

    def remove_follower(self, ob: MudObject) -> bool:
        if ob in self._liv_data.followers:
            self._liv_data.followers.remove(ob)
            return True
        return False

    def check_doing_follow(self, thing: MudObject, verb: str, special: str) -> bool:
        return True

    def query_current_room(self) -> Optional[MudObject]:
        return self.environment

    def query_followers(self) -> List[MudObject]:
        return [f for f in self._liv_data.followers if f]

    def do_burden_call(self):
        if self._liv_data.burden_call:
            self.driver.remove_call_out(self._liv_data.burden_call)
        self._liv_data.burden_call = self.driver.call_out(self.calc_burden, 1)

    def query_burden_limit(self) -> int:
        return MAX_CREATOR_INVEN if self.attrs.get("creator", False) else MAX_INVEN

    async def event_enter(self, thing: MudObject, mess: str, from_: MudObject):
        if thing.environment == self:
            self.do_burden_call()
            if len(self.inventory) > self.query_burden_limit():
                self._liv_data.to_drop.append(thing)
                self.driver.call_out(self.test_number_of_items, 5 + random.randint(0, 5))

    async def event_exit(self, thing: MudObject, mess: str, to: MudObject):
        if thing.environment == self:
            self.do_burden_call()

    async def test_number_of_items(self):
        things = [obj for obj in self.inventory if obj not in self.attrs.get("armours", []) and obj not in self.attrs.get("holding", [])]
        how_many = len(things) - self.query_burden_limit()
        if how_many < 1:
            return
        self._liv_data.to_drop = [t for t in self._liv_data.to_drop if t]
        dropped = []
        while how_many > 0 and things:
            thing = self._liv_data.to_drop[random.randint(0, len(self._liv_data.to_drop)-1)] if self._liv_data.to_drop else things[random.randint(0, len(things)-1)]
            things.remove(thing)
            if thing in self._liv_data.to_drop:
                self._liv_data.to_drop.remove(thing)
            if not thing or not thing.attrs.get("short") or thing.attrs.get("cannot_fumble") or thing.attrs.get("coin") or thing.environment != self:
                continue
            if await thing.move(self.environment):
                how_many -= 1
                dropped.append(thing)
        self._liv_data.to_drop = []
        if dropped:
            await self.send(f"Whoops! You tried to carry too many things and fumbled {self.query_multiple_short([d.name for d in dropped])}.\n")
            await self.driver.tell_room(self.environment, f"{self.name.capitalize()} juggles around {self.query_possessive()} stuff and fumbles {self.query_multiple_short([d.name for d in dropped])}.\n", self)

    def force_burden_recalculate(self):
        self.do_burden_call()
        self.driver.call_out(self.test_number_of_items, 5 + random.randint(0, 5))

    def query_position(self) -> str:
        return self.position

    def set_position(self, name: str):
        self.position = name

    def set_position_on(self, ob: Union[str, MudObject]):
        if not self.position_on:
            self.position_on = [None] * POSITION_ARRAY_SIZE
        self.position_on[POS_ON_OBJECT] = ob

    def set_position_multiple(self, mult: int):
        if not self.position_on:
            self.position_on = [None] * POSITION_ARRAY_SIZE
        self.position_on[POS_MULTIPLE] = mult

    def query_position_multiple(self) -> int:
        return self.position_on[POS_MULTIPLE] if self.position_on else 0

    def set_position_type(self, type_: str):
        if not self.position_on:
            self.position_on = [None] * POSITION_ARRAY_SIZE
        self.position_on[POS_TYPE] = type_

    def query_position_type(self) -> str:
        return self.position_on[POS_TYPE] if self.position_on and self.position_on[POS_TYPE] else "on"

    def query_position_on(self) -> Optional[Union[str, MudObject]]:
        return self.position_on[POS_ON_OBJECT] if self.position_on else None

    def query_position_on_short(self) -> str:
        if not self.position_on or not self.position_on[POS_ON_OBJECT]:
            return ""
        if isinstance(self.position_on[POS_ON_OBJECT], str):
            return self.position_on[POS_ON_OBJECT]
        return self.position_on[POS_ON_OBJECT].name

    def query_position_long(self) -> str:
        if self.position != STANDING or self.position_on:
            if self.position_on:
                return f"{self.query_pronoun()} is {self.query_position_type()} {self.query_position_on_short()}.\n"
            return f"{self.query_pronoun()} is {self.position} on the floor.\n"
        return ""

    def query_position_short(self) -> str:
        if not self.position_on or not self.position_on[POS_ON_OBJECT]:
            return self.position
        return f"{self.position} {self.query_position_type()} {self.query_position_on_short()}"

    def set_always_use_default_position(self, flag: int):
        self.always_use_default_position = flag

    def query_always_use_default_position(self) -> int:
        return self.always_use_default_position

    def query_default_position(self) -> Union[str, List, Callable]:
        pos = self.default_position
        if isinstance(pos, str) or (isinstance(pos, list) and len(pos) in [POSITION_ONLY_TYPE_SIZE, POSITION_MESS_SIZE]) or callable(pos):
            return pos
        return "standing"

    def set_default_position(self, str_: Union[str, List, Callable]):
        if isinstance(str_, str) and str_ != "standing":
            self.default_position = str_
        elif not str_ or str_ == "standing":
            self.default_position = None
        elif isinstance(str_, list) and len(str_) in [POSITION_ONLY_TYPE_SIZE, POSITION_MESS_SIZE]:
            self.default_position = str_
        elif callable(str_):
            self.default_position = str_

    async def return_to_default_position(self, leaving: bool):
        pos = self.query_default_position() if self.query_always_use_default_position() else (self.environment.attrs.get("default_position", None) if self.environment else None) or self.query_default_position()
        if callable(pos):
            if not pos(self, leaving):
                pos = self.environment.attrs.get("default_position", None) if self.environment else "standing"
        if isinstance(pos, str):
            if self.position != pos or (leaving and self.query_position_on()):
                self.position = pos
                self.set_position_on(None)
                self.set_position_type(None)
                self.set_position_multiple(0)
        elif isinstance(pos, list):
            if self.position != pos[POSITION_TYPE_INDEX]:
                if len(pos) > 1:
                    if pos[POSITION_ME_MESS_INDEX]:
                        await self.send(pos[POSITION_ME_MESS_INDEX])
                    if len(pos) > 2 and pos[POSITION_REST_MESS]:
                        await self.driver.tell_room(self.environment, pos[POSITION_REST_MESS], self)
                self.set_position(pos[POSITION_TYPE_INDEX])
                self.set_position_on(None)
                self.set_position_type(None)
                self.set_position_multiple(0)

    def query_deity_favour(self, god: str) -> int:
        return self.deity_favour.get(god, 0)

    def adjust_deity_favour(self, god: str, amount: int):
        if god not in self.deity_favour:
            self.deity_favour[god] = 0
        self.deity_favour[god] += amount
        self.deity_favour[god] = max(-MAX_FAVOUR, min(MAX_FAVOUR, self.deity_favour[god]))

    def query_all_deity_favour(self) -> Dict[str, int]:
        return self.deity_favour.copy()

    def query_quest_points(self) -> int:
        return library.query_quest_points(self.name)

    # Replace guild methods with class handler calls
    def join_guild(self, guild: str):
        return asyncio.run(class_handler.class_command(self, self, f"join {guild}"))

    def leave_guild(self):
        return asyncio.run(class_handler.class_command(self, self, "leave"))

    def query_guild(self) -> Optional[str]:
        return class_handler.query_class(self)

    def query_guild_level(self) -> int:
        return class_handler.query_class_level(self)

    def set_guild_level(self, level: int):
        class_handler.set_class_level(self, level)

    def advancement_restriction(self) -> bool:
        return class_handler.advancement_restriction(self)

    # Taskmaster Methods
    def add_skill_level(self, skill: str, level: int, prev_ob: MudObject) -> bool:
        if self.advancement_restriction():
            return False
        current = self.attrs["skills"].get(skill, 0)
        self.attrs["skills"][skill] = current + level
        return True

    def stat_modify(self, upper: int, skill: str) -> int:
        # Simplified stat-based modification
        stat_bonus = (self.attrs.get("str", 10) + self.attrs.get("dex", 10)) // 20
        return max(0, upper + stat_bonus)

    # Options Methods
    def query_inform_types(self) -> List[str]:
        return ["tell", "say"]

    def query_player_clubs(self) -> List[str]:
        return ["guild"]

    def adjust_bonus_dex(self, amount: int):
        self.attrs["dex_bonus"] = self.attrs.get("dex_bonus", 0) + amount

    def query_max_weight(self) -> int:
        return self.attrs.get("max_weight", 100)

class LivingHandler:
    def __init__(self):
        self._lnames: Dict[str, List[MudObject]] = {}
        self._players: Dict[str, MudObject] = {}

    def check_lnames(self, names: List[str]):
        for key in names:
            if key in self._lnames:
                bing = [x for x in self._lnames[key] if x]
                if bing:
                    self._lnames[key] = bing
                else:
                    del self._lnames[key]
            else:
                del self._lnames[key]

    def check_players(self, names: List[str]):
        for key in names:
            if key in self._players:
                bing = [x for x in self._players[key] if x]
                if bing:
                    self._players[key] = bing
                else:
                    del self._players[key]
            else:
                del self._players[key]

    def remove_garbage(self):
        names = list(self._lnames.keys())
        for i in range(0, len(names), 50):
            self.driver.call_out(lambda n=names[i:i+50]: self.check_lnames(n), i // 25)
        names = list(self._players.keys())
        for i in range(0, len(names), 50):
            self.driver.call_out(lambda n=names[i:i+50]: self.check_players(n), i // 25)

    def set_living_name(self, name: str, ob: MudObject):
        if not name or not isinstance(ob, MudObject):
            return
        if name not in self._lnames:
            self._lnames[name] = [ob]
        else:
            self._lnames[name].append(ob)

    def named_livings(self) -> List[MudObject]:
        ret = []
        for name in self._lnames:
            ret.extend([x for x in self._lnames[name] if x])
        return ret

    def find_living(self, name: str) -> Optional[MudObject]:
        if name in self._lnames:
            self._lnames[name] = [x for x in self._lnames[name] if x]
            if self._lnames[name]:
                return self._lnames[name][-1]
        return None

    def find_player(self, name: str) -> Optional[MudObject]:
        if name in self._players:
            return self._players[name]
        players = [p for p in driver.players if p.attrs.get("name") == name]
        if players:
            self._players[name] = players[0]
            return players[0]
        if name in self._lnames:
            tmp = [x for x in self._lnames[name] if x and x.attrs.get("player", False)]
            if tmp:
                return tmp[0]
        return None

living_handler = LivingHandler()

# /mnt/home2/mud/systems/login_handler.py
from typing import Optional
from ..driver import driver, Player, MudObject
import asyncio
import hashlib
import sqlite3
import json
import os

class LoginHandler:
    def __init__(self, db_path: str = "/mnt/home2/mud/players/mud.db"):
        self.db = sqlite3.connect(db_path, check_same_thread=False)
        self.db.execute("""
            CREATE TABLE IF NOT EXISTS players (
                name TEXT PRIMARY KEY, 
                password TEXT, 
                race TEXT, 
                class TEXT, 
                data TEXT
            )
        """)
        self.db.commit()
        self.races = ["human", "elf", "drow", "dwarf", "gnome", "halfling", "orc", "goblin", "dragonborn"]
        self.classes = ["fighter", "wizard", "cleric", "thief"]

    async def init(self, driver_instance):
        self.driver = driver_instance

    async def handle_login(self, player: Player) -> bool:
        await player.send("Welcome to the Realms, traveler, under the gaze of Mystra...")
        await asyncio.sleep(5)
        await player.send("A portal shimmers before you...")
        await asyncio.sleep(5)
        await player.send("You emerge as a spirit in the Ethereal Veil...")
        await asyncio.sleep(5)

        # Check existing player
        await player.send("Enter your name (or 'new' to create, 'g' for name list): ")
        name = await self.get_input(player)
        if name.lower() == "g":
            await player.send("Generated names: Zarathar, Elendir, Kaelith...")
            await player.send("Enter your name: ")
            name = await self.get_input(player)
        elif name.lower() == "new":
            return await self.create_character(player)
        elif name:
            cursor = self.db.execute("SELECT password, data FROM players WHERE name=?", (name,))
            data = cursor.fetchone()
            if data:
                stored_pass, player_data = data
                await player.send("Enter password: ")
                password = await self.get_input(player)
                if hashlib.sha256(password.encode()).hexdigest() == stored_pass:
                    player.name = name
                    player.attrs = json.loads(player_data) if player_data else {}
                    player.location = self.driver.objects["ethereal_veil_start"]
                    await player.send(await player.location.call("look", player))
                    return True
                else:
                    await player.send("Incorrect password!")
                    return False
            else:
                await player.send(f"No player named {name} found. Create a new character? (y/n): ")
                if await self.get_input(player).lower() == "y":
                    return await self.create_character(player)
        return False

    async def create_character(self, player: Player) -> bool:
        await player.send("Choose a name (avoid offensive or book names, e.g., Elminster): ")
        name = await self.get_input(player)
        if not name or any(c in name.lower() for c in "1234567890!@#$%^&*()_+-={}[]|\\:;\"'<>?,./"):
            await player.send("Invalid name! Use letters only.")
            return False
        await player.send("Enter password: ")
        password = await self.get_input(player)
        await player.send("Confirm password: ")
        confirm = await self.get_input(player)
        if password != confirm:
            await player.send("Passwords don’t match!")
            return False
        hashed_pass = hashlib.sha256(password.encode()).hexdigest()
        await player.send("Choose race (human, elf, drow, dwarf, gnome, halfling, orc, goblin, dragonborn): ")
        race = await self.get_input(player).lower()
        if race not in self.races:
            await player.send("Invalid race!")
            return False
        await player.send("Choose class (fighter, wizard, cleric, thief): ")
        class_ = await self.get_input(player).lower()
        if class_ not in self.classes:
            await player.send("Invalid class!")
            return False
        await player.send("Terms: No profanity, no harassment. Agree? (yes/no): ")
        if await self.get_input(player).lower() != "yes":
            await player.send("You must agree to play!")
            return False

        player.name = name
        player.attrs = {"race": race, "class": class_, "skills": {}, "stats": {"hp": 100, "gp": 100}}
        self.db.execute("INSERT INTO players (name, password, race, class, data) VALUES (?, ?, ?, ?, ?)",
                        (name, hashed_pass, race, class_, json.dumps(player.attrs)))
        self.db.commit()
        player.location = self.driver.objects["ethereal_veil_start"]
        await player.send(await player.location.call("look", player))
        await player.send("Character created! Explore the Ethereal Veil to begin.")
        return True

    async def get_input(self, player: Player) -> str:
        if player.protocol == "telnet":
            data = await player.writer.read(1024)
            return data.decode("utf-8").strip() if data else ""
        else:
            return await player.writer.recv()

# Initialize login handler
login_handler = LoginHandler()

async def init(driver_instance):
    await login_handler.init(driver_instance)

# /mnt/home2/mud/systems/map_handler.py
from typing import Dict, List, Optional, Tuple
from ..driver import driver, MudObject, Player
import random

class MapHandler(MudObject):
    def __init__(self, oid: str = "map_handler", name: str = "map_handler"):
        super().__init__(oid, name)
        self.terrain_handler = driver.terrain_handler
        self.newline_mode: bool = False  # Toggle for newline in descriptions
        self.feature_chats: Dict[str, List[str]] = {}  # Feature-specific chats
        self.outside_chats: Dict[str, List[str]] = {}  # Outside-type chats
        self.room_sizes: Dict[str, int] = {}  # Cached room sizes

    def setup(self):
        """Initializes the map handler."""
        self.set_name("map handler")
        self.set_short("map handler")
        self.set_long("This object manages the mapping of vast terrains.\n")
        self.add_adjective("map")

    def query_newline_mode(self) -> bool:
        """Returns whether to use newlines in descriptions."""
        return self.newline_mode

    def set_newline_mode(self, mode: bool):
        """Sets the newline mode."""
        self.newline_mode = mode

    def query_player_map_template(self, x: int, y: int, z: int, visibility: int, size: int) -> str:
        """Generates a player-visible map template."""
        # Simplified map generation (placeholder for actual terrain data)
        map_lines = []
        center_x, center_y = x // 10, y // 10
        for i in range(center_y - size // 2, center_y + size // 2 + 1):
            line = ""
            for j in range(center_x - size // 2, center_x + size // 2 + 1):
                char = self._get_terrain_char(j * 10, i * 10, z)
                line += char if visibility >= 50 or abs(j - center_x) <= 1 and abs(i - center_y) <= 1 else "?"
            map_lines.append(line)
        return "\n".join(map_lines)

    def _get_terrain_char(self, x: int, y: int, z: int) -> str:
        """Determines the terrain character for a coordinate."""
        co_ords = [x, y, z]
        terrain = self.terrain_handler.terrain_name
        if self.terrain_handler.member_fixed_locations(co_ords):
            return "F"  # Fixed room
        locations = self.terrain_handler.member_floating_locations(co_ords)
        if locations:
            return "f" if locations[0][0] != "nothing" else " "  # Floating or nothing
        return "."  # Default terrain

    def query_feature_desc(self, title: str, direcs: Dict, visibility: int) -> List[str]:
        """Returns feature descriptions based on visibility."""
        if visibility < 50 or not direcs:
            return []
        # Placeholder: Assume handler has feature data
        return [f"You see a {title} to the {direcs.get('dir', 'unknown')}."]

    def query_distant_feature_desc(self, title: str, feature: Dict, visibility: int) -> List[str]:
        """Returns distant feature descriptions."""
        if visibility < 30:
            return []
        return [f"In the distance, you notice a {title}."]

    def query_feature_item_desc(self, title: str) -> str:
        """Returns the item description for a feature."""
        # Placeholder: Assume feature data exists
        return f"This is a {title} you can interact with."

    def get_a_feature_chat(self, title: str, index: int, direc: str) -> Optional[str]:
        """Returns a random feature chat."""
        chats = self.feature_chats.get(title, [])
        return random.choice(chats) if chats else None

    def get_an_outside_chat(self, types: str) -> Optional[str]:
        """Returns a random outside chat based on type."""
        chats = self.outside_chats.get(types, ["The wind rustles softly."])
        return random.choice(chats) if chats else None

    def query_room_size(self, bname: str) -> List[int]:
        """Returns the room size for a given base name."""
        if bname not in self.room_sizes:
            self.room_sizes[bname] = driver.terrain_handler.get_room_size(f"{bname}.c")
        return [self.room_sizes[bname]]

    def add_room_to_zone(self, room: MudObject, zone: str):
        """Adds a room to a zone (placeholder for zone management)."""
        room.add_zone(zone)

    def query_debug_map(self, x: int, y: int, size: int, center_x: int, center_y: int) -> str:
        """Generates a debug map for creators."""
        map_lines = []
        for i in range(y - size // 2, y + size // 2 + 1):
            line = ""
            for j in range(x - size // 2, x + size // 2 + 1):
                char = self._get_terrain_char(j * 10, i * 10, 0)
                line += char
            map_lines.append(line)
        return "\n".join(map_lines)

    def query_direction_distance(self, dir: str) -> int:
        """Returns the distance for a direction (simplified)."""
        return 10  # Placeholder value

async def init(driver_instance):
    driver = driver_instance
    driver.map_handler = MapHandler()

# /mnt/home2/mud/systems/options.py
from typing import Dict, Optional, List, Callable, Tuple, ClassVar
from ..driver import driver, Player, MudObject
from .tactics import TacticsHandler
import asyncio
import re

class option:
    def __init__(self, type_: mixed, restriction: int, set_func: Callable, query_func: Callable, suboptions: Dict, help: str):
        self.type = type_
        self.restriction = restriction
        self.set = set_func
        self.query = query_func
        self.suboptions = suboptions
        self.help = help

class player_options_control:
    def __init__(self):
        self.follow_everyone = 0
        self.follow_groups = 0
        self.follow_friends = 0
        self.lead_behind = 0
        self.mxp_disable = 0

# Option type constants (from /include/options.h)
OPTIONS_TYPE_BRIEF = 1
OPTIONS_TYPE_BOOLEAN = 2
OPTIONS_TYPE_INTEGER = 3
OPTIONS_TYPE_STRING = 4
OPTIONS_TYPE_PERCENTAGE = 5
OPTIONS_TYPE_COLOUR = 6
OPTIONS_TYPE_TERMINAL = 7
OPTIONS_TYPE_DYNAMIC_GROUP = 8
OPTIONS_TYPE_GROUP = 9
OPTIONS_TYPE_ALL = 0
OPTIONS_TYPE_CRE_ONLY = 1
OPTIONS_TYPE_LORD_ONLY = 2
OPTIONS_TYPE_PLAYTESTER_ONLY = 3
MONITOR_OPTIONS = ["off", "on", "slow"]

class OptionsHandler:
    _options: Dict[str, Dict] = {}
    _colours: List[str] = ["BOLD", "FLASH", "BLACK", "RED", "BLUE", "CYAN", "MAGENTA", "ORANGE", "YELLOW", "GREEN", "WHITE", "B_RED", "B_ORANGE", "B_YELLOW", "B_BLACK", "B_CYAN", "B_WHITE", "B_GREEN", "B_MAGENTA"]
    _cache_input: Dict[str, Dict] = {}
    tactics_handler = TacticsHandler()

    def __init__(self):
        pass  # Initialization handled in create()

    async def init(self, driver_instance):
        self.driver = driver_instance
        self.create()
        for obj in self.driver.objects.values():
            if isinstance(obj, Player) and hasattr(obj, "attrs"):
                self.init_options(obj)
                obj.add_action("options", self.options_command)

    def create(self):
        self._options = {}
        self._cache_input = {}

        # Output options
        self.add_option("output look", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_verbose(p, "look", v), lambda p: self.query_verbose(p, "look"),
                       "Display room descriptions briefly or in full")
        self.add_option("output combat", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_verbose(p, "combat", v), lambda p: self.query_verbose(p, "combat"),
                       "Display all combat messages or only those involving damage")
        self.add_option("output errors", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_CRE_ONLY,
                       lambda p, v: self.set_verbose(p, "errors", v), lambda p: self.query_verbose(p, "errors"),
                       "Display errors in the error handler briefly")
        self.add_option("output score", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_verbose(p, "score", v), lambda p: self.query_verbose(p, "score"),
                       "Amount of detail to be displayed by the 'score' command")
        self.add_option("output accent", ["mangle", "unadulterated"], OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs["mangle_accent"] == (v == "mangle"), lambda p: p.attrs.get("mangle_accent", False) and "mangle" or "unadulterated",
                       "Show others speech with or without regional accents")
        self.add_option("output names", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_verbose(p, "names", v), lambda p: self.query_verbose(p, "names"),
                       "Display player names with or without title and surname")
        self.add_option("output htell", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_verbose(p, "htell", v), lambda p: self.query_verbose(p, "htell"),
                       "Cause the 'htell' command to display times for tells or not")
        self.add_option("output msgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
                       lambda p, v: setattr(p.attrs, "msgout", v), lambda p: p.attrs.get("msgout", ""),
                       "The message that is displayed when you walk out of a room")
        self.add_option("output msgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
                       lambda p, v: setattr(p.attrs, "msgin", v), lambda p: p.attrs.get("msgin", ""),
                       "The message that is displayed when you walk into a room")
        self.add_option("output mmsgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
                       lambda p, v: setattr(p.attrs, "mmsgout", v), lambda p: p.attrs.get("mmsgout", ""),
                       "The message that is displayed when you trans out of a room")
        self.add_option("output mmsgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
                       lambda p, v: setattr(p.attrs, "mmsgin", v), lambda p: p.attrs.get("mmsgin", ""),
                       "The message that is displayed when you trans into a room")
        self.add_option("output usercolour", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs.setdefault("allow_coloured_souls", v), lambda p: p.attrs.get("allow_coloured_souls", 0),
                       "Display user chosen colours in souls")
        self.add_option("output plainmaps", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs.setdefault("plain_maps", v), lambda p: p.attrs.get("plain_maps", 0),
                       "Display terrain maps without colour")
        self.add_option("output lookmap", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_PLAYTESTER_ONLY,
                       lambda p, v: p.attrs.setdefault("terrain_map_in_look", v), lambda p: p.attrs.get("terrain_map_in_look", 0),
                       "Display room a map in the terrain long or not")
        self.add_option("output tabstops", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_CRE_ONLY,
                       lambda p, v: p.attrs.setdefault("tabstops", v), lambda p: p.attrs.get("tabstops", 0),
                       "Show tabstops as <TAB> or as spaces")
        self.add_option("output shorthand", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs.setdefault("shorthand_output", v), lambda p: p.attrs.get("shorthand_output", 0),
                       "Convert others shorthand text into long form")

        # Colour options
        for colour in ["tell", "say", "shout", "inform", "combat", "magic.spellcasting"]:  # Added magic.spellcasting
            self.add_option(f"colour {colour}", OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_ALL,
                           lambda p, v, c=colour: self.set_my_colours(p, c, v), lambda p, c=colour: self.colour_event(p, c),
                           f"The colour for {colour} messages")
        self.add_option("colour inform", OPTIONS_TYPE_DYNAMIC_GROUP, OPTIONS_TYPE_ALL,
                       0, lambda p: self.get_inform_colours(p),
                       "The colours of various informational messages")
        self.add_option("colour club", OPTIONS_TYPE_DYNAMIC_GROUP, OPTIONS_TYPE_ALL,
                       0, lambda p: self.get_club_colours(p),
                       "The colour for club messages")

        # Terminal options
        self.add_option("terminal type", OPTIONS_TYPE_TERMINAL, OPTIONS_TYPE_ALL,
                       lambda p, v: setattr(p.attrs, "term_type", v), lambda p: p.attrs.get("term_type", ""),
                       "The type of terminal you are using")
        self.add_option("terminal rows", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_ALL,
                       lambda p, v: setattr(p.attrs, "rows", v), lambda p: p.attrs.get("rows", 0),
                       "The number of rows in your terminal")
        self.add_option("terminal cols", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_ALL,
                       lambda p, v: setattr(p.attrs, "cols", v), lambda p: p.attrs.get("cols", 0),
                       "The number of columns in your terminal")

        # Combat options
        self.add_option("combat wimpy", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_ALL,
                       lambda p, v: setattr(p.attrs, "wimpy", v), lambda p: p.attrs.get("wimpy", 20),
                       "The percentage of your hitpoints at which you will run away")
        self.add_option("combat monitor", MONITOR_OPTIONS, OPTIONS_TYPE_ALL,
                       lambda p, v: setattr(p.attrs, "monitor", MONITOR_OPTIONS.index(v)), lambda p: MONITOR_OPTIONS[p.attrs.get("monitor", 1)],
                       "The frequency of display of your combat monitor")
        self.add_option("combat tactics attitude", ["insane", "offensive", "neutral", "defensive", "wimp"], OPTIONS_TYPE_ALL,
                       lambda p, v: self.tactics_handler.set_combat_attitude(p, v), lambda p: self.tactics_handler.query_combat_attitude(p),
                       "Your combat attitude (see help tactics)")
        self.add_option("combat tactics response", ["dodge", "neutral", "parry"], OPTIONS_TYPE_ALL,
                       lambda p, v: self.tactics_handler.set_combat_response(p, v), lambda p: self.tactics_handler.query_combat_response(p),
                       "Your combat response (see help tactics)")
        self.add_option("combat tactics parry", ["left", "right", "both"], OPTIONS_TYPE_ALL,
                       lambda p, v: self.tactics_handler.set_combat_parry(p, v), lambda p: self.tactics_handler.query_combat_parry(p),
                       "Which hand you will parry with (see help tactics)")
        self.add_option("combat tactics unarmed_parry", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: self.tactics_handler.set_unarmed_parry(p, v), lambda p: self.tactics_handler.query_unarmed_parry(p),
                       "Whether you will parry unarmed (see help tactics)")
        self.add_option("combat tactics attack", ["left", "right", "both"], OPTIONS_TYPE_ALL,
                       lambda p, v: self.tactics_handler.set_combat_attack(p, v), lambda p: self.tactics_handler.query_combat_attack(p),
                       "Which hand you will attack with (see help tactics)")
        self.add_option("combat tactics mercy", ["always", "ask", "never"], OPTIONS_TYPE_ALL,
                       lambda p, v: self.tactics_handler.set_combat_mercy(p, v), lambda p: self.tactics_handler.query_combat_mercy(p),
                       "Whether or not you will show mercy to opponents")
        self.add_option("combat tactics focus", ["upper body", "lower body", "head", "neck", "chest", "abdomen", "arms", "hands", "legs", "feet", "none"], OPTIONS_TYPE_ALL,
                       lambda p, v: self.tactics_handler.set_combat_focus(p, v), lambda p: self.tactics_handler.query_combat_focus(p),
                       "Which body part you will focus on in combat (see help tactics)")
        self.add_option("combat tactics distance", ["long", "medium", "close", "hand-to-hand", "none"], OPTIONS_TYPE_ALL,
                       lambda p, v: self.tactics_handler.set_combat_distance(p, v), lambda p: self.tactics_handler.query_combat_distance(p),
                       "Your ideal combat distance (see help tactics)")
        self.add_option("combat killer", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: setattr(p.attrs, "player_killer", v), lambda p: p.attrs.get("player_killer", 0),
                       "Whether or not you are a registered player killer")

        # Input options
        self.add_option("input ambiguous", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: self.change_bool_property(p, "ambiguous", not v), lambda p: not p.attrs.get("ambiguous", 0),
                       "Should the parser notify you of ambiguities")
        self.add_option("input andascomma", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: self.change_bool_property(p, "andascomma", not v), lambda p: not p.attrs.get("andascomma", 0),
                       "Should 'and' be treated as a comma (an inclusive list)")
        self.add_option("input editor", ["menu", "magic", "command", "ed"], OPTIONS_TYPE_ALL,
                       lambda p, v: setattr(p.attrs, "editor", v), lambda p: p.attrs.get("editor", "menu"),
                       "Your preferred editor")
        self.add_option("input shorthand", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs.setdefault("shorthand", v), lambda p: p.attrs.get("shorthand", 0),
                       "Convert your shorthand typing into long form")

        # Earmuff options
        earmuff_events = ["shout", "newbie", "cryer", "remote-soul", "multiple-soul", "multiple-tell", "teach", "tell", "remote", "multiple-remote"]
        for event in earmuff_events:
            self.add_option(f"earmuff events {event}", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                           lambda p, v, e=event: self.change_earmuffs(p, e, v), lambda p, e=event: e in p.attrs.get("earmuffs", []),
                           f"Should you be informed of {event} messages")
        self.add_option("earmuff state", ["on", "off", "allowfriends"], OPTIONS_TYPE_ALL,
                       lambda p, v: self.setup_earmuffs(p, v), lambda p: "allowfriends" if p.attrs.get("earmuffs") == "allowfriends" else "on" if p.attrs.get("earmuffs") else "off",
                       "Enable or disable earmuffs always or just for friends")
        self.add_option("earmuff cut-through", ["off", "ask", "auto"], OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs.setdefault("cut_earmuffed_tells", ["off", "ask", "auto"].index(v)), lambda p: ["off", "ask", "auto"][p.attrs.get("cut_earmuffed_tells", 0)],
                       "Cut through a players tell earmuffs")

        # Creator options
        self.add_option("command ls use_nickname", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                       lambda p, v: self.change_bool_property(p, "ls_nickname", v), lambda p: p.attrs.get("ls_nickname", 0),
                       "Should 'ls' check for nicknames")

        # Personal options
        self.add_option("personal description", OPTIONS_TYPE_STRING, OPTIONS_TYPE_ALL,
                       lambda p, v: len(v) <= 30 and setattr(p.attrs, "description", v if v != "none" else None) or 0, lambda p: p.attrs.get("description", "none"),
                       "Ain't you perdy")
        self.add_option("personal real_name", OPTIONS_TYPE_STRING, OPTIONS_TYPE_ALL,
                       lambda p, v: len(v) <= 30 and setattr(p.attrs, "real_name", v if v != "none" else None) or 0, lambda p: p.attrs.get("real_name", "none"),
                       "The real name displayed in your finger information")
        self.add_option("personal location", OPTIONS_TYPE_STRING, OPTIONS_TYPE_ALL,
                       lambda p, v: len(v) <= 30 and setattr(p.attrs, "location", v if v != "none" else None) or 0, lambda p: p.attrs.get("location", "none"),
                       "The location displayed in your finger information")
        self.add_option("personal home_page", OPTIONS_TYPE_STRING, OPTIONS_TYPE_ALL,
                       lambda p, v: len(v) <= 30 and setattr(p.attrs, "homepage", v if v != "none" else None) or 0, lambda p: p.attrs.get("homepage", "none"),
                       "The url displayed in your finger information")
        self.add_option("personal email", OPTIONS_TYPE_STRING, OPTIONS_TYPE_ALL,
                       lambda p, v: len(v) <= 30 and setattr(p.attrs, "email", v if v != "none" else None) or 0, lambda p: p.attrs.get("email", "none"),
                       "The email address displayed in your finger information")
        self.add_option("personal birthday", OPTIONS_TYPE_STRING, OPTIONS_TYPE_ALL,
                       lambda p, v: self.valid_birthday(v) and not p.attrs.get("birthday") and setattr(p.attrs, "birthday", self.convert_birthday(v) if v != "none" else None) or 0, lambda p: p.attrs.get("birthday", "none"),
                       "Your birthday")
        self.add_option("personal execinclude", OPTIONS_TYPE_STRING, OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs.setdefault("execinclude", v if v != "none" else None), lambda p: p.attrs.get("execinclude", "none"),
                       "The path of files to be included in exec commands")
        self.add_option("personal auto teach", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs.setdefault("auto_teach", v), lambda p: p.attrs.get("auto_teach", 0),
                       "Are you available to auto-teach")
        self.add_option("personal travel", ["walk", "journey"], OPTIONS_TYPE_ALL,
                       lambda p, v: p.attrs.setdefault("travel", v == "journey"), lambda p: "journey" if p.attrs.get("travel", False) else "walk",
                       "By default should you walk or journey across terrains")

        # Playtester options
        self.add_option("playtester protection", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_PLAYTESTER_ONLY,
                       lambda p, v: p.attrs.setdefault("pt_protection", v), lambda p: p.attrs.get("pt_protection", 0),
                       "Enable or disable playtester protection")
        self.add_option("personal roleplaying", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_PLAYTESTER_ONLY,
                       lambda p, v: p.attrs.setdefault("roleplaying", v), lambda p: p.attrs.get("roleplaying", 0),
                       "Enable or disable roleplaying mode")

        # Player options from /std/player/options.c
        self.add_option("player follow groups", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_auto_follow_group(p, v), lambda p: self.query_auto_follow_group(p),
                       "Should the player auto follow in groups")
        self.add_option("player follow friends", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_auto_follow_friends(p, v), lambda p: self.query_auto_follow_friends(p),
                       "Should the player auto follow friends")
        self.add_option("player follow everyone", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_auto_follow_everyone(p, v), lambda p: self.query_auto_follow_everyone(p),
                       "Should the player auto follow everyone")
        self.add_option("player lead behind", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_lead_from_behind(p, v), lambda p: self.query_lead_from_behind(p),
                       "Should the player lead from behind")
        self.add_option("player mxp disable", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_ALL,
                       lambda p, v: self.set_mxp_disable(p, v), lambda p: self.query_mxp_disable(p),
                       "Disable MXP support")

    def init_options(self, obj: Player):
        if "options" not in obj.attrs:
            obj.attrs["options"] = {
                "output": {"look": 0, "combat": 0, "errors": 0, "score": 0, "names": 0, "htell": 0},
                "combat": {"wimpy": 20, "monitor": 1, "killer": 0},
                "tactics": {},
                "colour": {},
                "terminal": {"type": "", "rows": 0, "cols": 0},
                "input": {"ambiguous": 0, "andascomma": 0, "editor": "menu", "shorthand": 0},
                "earmuff": {"state": "off", "cut-through": 0},
                "personal": {"description": "none", "real_name": "none", "location": "none", "homepage": "none", "email": "none", "birthday": "none", "execinclude": "none", "auto_teach": 0, "travel": "walk"},
                "playtester": {"protection": 0, "roleplaying": 0},
                "player": {"follow_groups": 0, "follow_friends": 0, "follow_everyone": 0, "lead_behind": 0, "mxp_disable": 0}
            }
            obj.attrs.setdefault("mangle_accent", False)
            obj.attrs.setdefault("msgout", "")
            obj.attrs.setdefault("msgin", "")
            obj.attrs.setdefault("mmsgout", "")
            obj.attrs.setdefault("mmsgin", "")
            obj.attrs.setdefault("allow_coloured_souls", 0)
            obj.attrs.setdefault("plain_maps", 0)
            obj.attrs.setdefault("terrain_map_in_look", 0)
            obj.attrs.setdefault("tabstops", 0)
            obj.attrs.setdefault("shorthand_output", 0)
            obj.attrs.setdefault("ambiguous", 0)
            obj.attrs.setdefault("andascomma", 0)
            obj.attrs.setdefault("shorthand", 0)
            obj.attrs.setdefault("earmuffs", [])
            obj.attrs.setdefault("cut_earmuffed_tells", 0)
            obj.attrs.setdefault("ls_nickname", 0)
            obj.attrs.setdefault("wimpy", 20)
            obj.attrs.setdefault("monitor", 1)
            obj.attrs.setdefault("player_killer", 0)
            obj.attrs.setdefault("editor", "menu")
            obj.attrs.setdefault("term_type", "")
            obj.attrs.setdefault("rows", 0)
            obj.attrs.setdefault("cols", 0)
            obj.attrs.setdefault("pt_protection", 0)
            obj.attrs.setdefault("roleplaying", 0)
            self.driver.save_object(obj)

    async def options_command(self, obj: MudObject, caller: Player, arg: str) -> str:
        if not isinstance(caller, Player):
            return "Only players can use the options command."
        if caller.oid != obj.oid:
            return "You can only modify your own options."

        if not arg:
            return self.display_options(caller)

        args = arg.lower().split(maxsplit=1)
        if len(args) < 1:
            return "Syntax: options [setting] [value] or options help"

        command = args[0]
        if command == "help":
            return self.help_text()
        elif len(args) == 1 and self.is_option_group(caller, command):
            return self.display_category(caller, command)
        elif len(args) == 2:
            setting, value = args
            if self.is_option(caller, setting):
                return await self.set_option(caller, setting, value)
            elif setting.endswith(" all") and self.is_option_group(caller, setting[:-4]):
                return await self.set_all(caller, setting[:-4], value)
            else:
                return f"Unknown setting '{setting}'. Use 'options help' for valid settings."
        return "Syntax: options [setting] [value] or options help"

    def display_options(self, caller: Player) -> str:
        options = caller.attrs["options"]
        output = "Your current options are:\n"
        for category, settings in options.items():
            output += f"{category.capitalize()}:\n"
            for setting, value in settings.items():
                if category == "combat" and setting == "monitor":
                    value = MONITOR_OPTIONS[value]
                output += f"  {setting}: {value}\n"
        return output

    def display_category(self, caller: Player, category: str) -> str:
        if not self.is_option_group(caller, category):
            return f"Unknown category '{category}'. Use 'options help' for valid categories."
        options = caller.attrs["options"].get(category, {})
        output = f"{category.capitalize()} options:\n"
        for setting, value in options.items():
            if category == "combat" and setting == "monitor":
                value = MONITOR_OPTIONS[value]
            output += f"  {setting}: {value}\n"
        return output

    async def set_option(self, caller: Player, option: str, value: str) -> str:
        if not self.is_option(caller, option):
            return f"There is no option {option}."
        old_value = self.query_option_value(caller, option)
        if self.set_option_value(caller, option, value):
            new_value = self.query_option_value(caller, option)
            return f"Set option {option} to {new_value} (was {old_value if old_value else 'unset'})."
        return f"Unable to set option {option} to {value}."

    async def set_all(self, caller: Player, option: str, value: str) -> str:
        if not self.is_option_group(caller, option):
            return f"The option must be an option group to use the 'all' keyword."
        sub_options = self.query_sub_options(caller, option)
        ok, bad = [], []
        for opt in sub_options:
            full_opt = f"{option} {opt}"
            if self.is_option(caller, full_opt):
                if self.set_option_value(caller, full_opt, value):
                    ok.append(full_opt)
                else:
                    bad.append(full_opt)
        if ok:
            return f"Set {self.query_multiple_short(ok)} to {value}."
        return f"Unable to set {self.query_multiple_short(bad)} to {value}."

    def edit_option(self, caller: Player, option: str) -> str:
        if not self.is_option(caller, option):
            return f"There is no option {option}."
        value = self.query_option_value(caller, option)
        caller.attrs["editing_option"] = option
        return f"Editing the option {option}.\nEnter new value (or 'abort' to cancel):"

    async def finish_edit(self, caller: Player, value: str) -> str:
        option = caller.attrs.pop("editing_option", None)
        if not option or not value or value.lower() == "abort":
            return "Aborting."
        if self.set_option_value(caller, option, value):
            return f"Set option {option} to {self.query_option_value(caller, option)}."
        return f"Unable to set the option {option}."

    def query_multiple_short(self, list_: List[str]) -> str:
        return ", ".join(list_[:-1]) + ("" if len(list_) <= 1 else " and " + list_[-1])

    def set_verbose(self, player: Player, var: str, value: int):
        player.attrs["options"]["output"][var] = value

    def query_verbose(self, player: Player, var: str) -> int:
        return player.attrs["options"]["output"].get(var, 0)

    def set_my_colours(self, player: Player, key: str, value: str):
        if key in player.attrs.get("colours", {}):
            player.attrs["colours"][key] = value

    def colour_event(self, player: Player, key: str) -> str:
        return player.attrs.get("colours", {}).get(key, "default")

    def get_inform_colours(self, player: Player) -> Dict:
        if "inform_colours" not in self._cache_input.get(player.oid, {}):
            self._cache_input[player.oid]["inform_colours"] = {
                "tell": OPTIONS_TYPE_COLOUR, "say": OPTIONS_TYPE_COLOUR
            }
        return self._cache_input[player.oid]["inform_colours"]

    def get_club_colours(self, player: Player) -> Dict:
        if "club_colours" not in self._cache_input.get(player.oid, {}):
            self._cache_input[player.oid]["club_colours"] = {
                "guild": OPTIONS_TYPE_COLOUR
            }
        return self._cache_input[player.oid]["club_colours"]

    def change_bool_property(self, player: Player, prop: str, value: int):
        player.attrs[prop] = value

    def setup_earmuffs(self, player: Player, value: str):
        if value == "on" and not player.attrs.get("earmuffs"):
            player.attrs["earmuffs"] = True
        elif value == "off" and player.attrs.get("earmuffs"):
            player.attrs.pop("earmuffs", None)
        elif value == "allowfriends":
            player.attrs["earmuffs"] = "allowfriends"

    def change_earmuffs(self, player: Player, ear: str, value: int):
        earmuffs = player.attrs.get("earmuffs", [])
        if value and ear not in earmuffs:
            earmuffs.append(ear)
        elif not value and ear in earmuffs:
            earmuffs.remove(ear)
        player.attrs["earmuffs"] = earmuffs

    def valid_birthday(self, str_: str) -> bool:
        if len(str_) != 4 or not str_.isdigit():
            return False
        tot = int(str_)
        month, day = tot % 100, tot // 100
        lengths = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        return 1 <= month <= 12 and 1 <= day <= lengths[month]

    def convert_birthday(self, str_: str) -> str:
        tot = int(str_)
        day, month = tot // 100, tot % 100
        months = ["January", "February", "March", "April", "May", "June",
                  "July", "August", "September", "October", "November", "December"]
        suffix = "th"
        if day in [11, 12, 13]:
            suffix = "th"
        elif day % 10 == 1:
            suffix = "st"
        elif day % 10 == 2:
            suffix = "nd"
        elif day % 10 == 3:
            suffix = "rd"
        return f"{day}{suffix} of {months[month-1]}"

    def set_auto_follow_group(self, player: Player, flag: int):
        options = player.attrs.get("player_options", player_options_control())
        options.follow_groups = flag
        player.attrs["player_options"] = options

    def query_auto_follow_group(self, player: Player) -> int:
        options = player.attrs.get("player_options", player_options_control())
        return options.follow_groups

    def set_auto_follow_friends(self, player: Player, flag: int):
        options = player.attrs.get("player_options", player_options_control())
        options.follow_friends = flag
        player.attrs["player_options"] = options

    def query_auto_follow_friends(self, player: Player) -> int:
        options = player.attrs.get("player_options", player_options_control())
        return options.follow_friends

    def set_auto_follow_everyone(self, player: Player, flag: int):
        options = player.attrs.get("player_options", player_options_control())
        options.follow_everyone = flag
        player.attrs["player_options"] = options

    def query_auto_follow_everyone(self, player: Player) -> int:
        options = player.attrs.get("player_options", player_options_control())
        return options.follow_everyone

    def set_lead_from_behind(self, player: Player, flag: int):
        options = player.attrs.get("player_options", player_options_control())
        options.lead_behind = flag
        player.attrs["player_options"] = options

    def query_lead_from_behind(self, player: Player) -> int:
        options = player.attrs.get("player_options", player_options_control())
        return options.lead_behind

    def set_mxp_disable(self, player: Player, flag: int):
        options = player.attrs.get("player_options", player_options_control())
        options.mxp_disable = flag
        player.attrs["player_options"] = options

    def query_mxp_disable(self, player: Player) -> int:
        options = player.attrs.get("player_options", player_options_control())
        return options.mxp_disable

    def is_mxp_enabled(self, player: Player) -> bool:
        return not self.query_mxp_disable(player)  # Simplified, no has_mxp efun

    def add_option(self, name: str, type_: mixed, cre_only: int, set_func: Callable, query_func: Callable, help: str) -> int:
        path = name.split()
        stuff = self._options
        for option in path[:-1]:
            if option not in stuff or stuff[option].type != OPTIONS_TYPE_GROUP:
                stuff[option] = option({"type": OPTIONS_TYPE_GROUP, "restriction": cre_only, "suboptions": {}, "help": help})
            stuff = stuff[option].suboptions
        stuff[path[-1]] = option(type_, cre_only, set_func, query_func, {}, help)
        return 1

    def add_option_to_mapping(self, array: Dict, name: str, type_: mixed, cre_only: int, set_func: Callable, query_func: Callable, help: str):
        array[name] = option(type_, cre_only, set_func, query_func, {}, help)

    def query_sub_option(self, player: Player, name: str, tree: Dict) -> Optional[Dict]:
        if name in tree and isinstance(tree[name], dict):
            return tree[name]
        if name in tree and isinstance(tree[name], option):
            if tree[name].restriction == OPTIONS_TYPE_CRE_ONLY and not player.attrs.get("creator", False):
                return 0
            if tree[name].restriction == OPTIONS_TYPE_PLAYTESTER_ONLY and not player.attrs.get("playtester", False):
                return 0
            if tree[name].type == OPTIONS_TYPE_DYNAMIC_GROUP:
                return self.get_inform_colours(player) if name == "inform" else self.get_club_colours(player) if name == "club" else tree[name].suboptions
            if tree[name].type == OPTIONS_TYPE_GROUP:
                return tree[name].suboptions
            return tree[name]
        return 0

    def query_bottom_sub_option(self, player: Player, path: List[str]) -> Optional[Dict]:
        if not path:
            return self._options
        stuff = self._options
        for option in path[:-1]:
            stuff = self.query_sub_option(player, option, stuff) or {}
            if not isinstance(stuff, dict):
                return 0
        return self.query_sub_option(player, path[-1], stuff)

    def is_option(self, player: Player, name: str) -> bool:
        stuff = self.query_bottom_sub_option(player, name.split())
        return isinstance(stuff, option)

    def is_option_group(self, player: Player, name: str) -> bool:
        stuff = self.query_bottom_sub_option(player, name.split())
        return isinstance(stuff, dict) and stuff

    def query_sub_options(self, player: Player, name: str) -> List[str]:
        stuff = self.query_bottom_sub_option(player, name.split())
        if isinstance(stuff, dict):
            return [k for k in stuff.keys() if self.query_bottom_sub_option(player, (name + " " + k).split())]
        return []

    def query_option_values(self, player: Player, name: str) -> List[str]:
        stuff = self.query_bottom_sub_option(player, name.split())
        if isinstance(stuff, option):
            if isinstance(stuff.type, list):
                return stuff.type
            return {
                OPTIONS_TYPE_BRIEF: ["brief", "verbose"],
                OPTIONS_TYPE_BOOLEAN: ["on", "off"],
                OPTIONS_TYPE_INTEGER: ["integer"],
                OPTIONS_TYPE_STRING: ["string"],
                OPTIONS_TYPE_PERCENTAGE: ["0..100"],
                OPTIONS_TYPE_COLOUR: ["none", "default", "colour"]
            }.get(stuff.type, [])
        return []

    def query_option_value(self, player: Player, path: str) -> str:
        stuff = self.query_bottom_sub_option(player, path.split())
        if isinstance(stuff, option):
            value = stuff.query(player)
            if isinstance(stuff.type, int):
                if stuff.type == OPTIONS_TYPE_BRIEF:
                    return "verbose" if value else "brief"
                elif stuff.type == OPTIONS_TYPE_BOOLEAN:
                    return "on" if value else "off"
                elif stuff.type == OPTIONS_TYPE_COLOUR:
                    return "[none]" if value == "" else "[default]" if value == "default" else f"[{value}%^RESET%^]"
            return str(value)
        return ""

    def query_option_help(self, player: Player, path: str) -> str:
        stuff = self.query_bottom_sub_option(player, path.split())
        return stuff.help if isinstance(stuff, option) else ""

    def set_option_value(self, player: Player, path: str, value: str) -> bool:
        stuff = self.query_bottom_sub_option(player, path.split())
        if not isinstance(stuff, option):
            return False
        set_value = value
        if isinstance(stuff.type, list):
            if value not in stuff.type:
                return False
        elif isinstance(stuff.type, int):
            if stuff.type == OPTIONS_TYPE_BRIEF:
                set_value = 1 if value == "verbose" else 0 if value == "brief" else None
            elif stuff.type == OPTIONS_TYPE_BOOLEAN:
                set_value = 1 if value in ["on", "true"] else 0 if value in ["off", "false"] else None
            elif stuff.type == OPTIONS_TYPE_INTEGER or stuff.type == OPTIONS_TYPE_PERCENTAGE:
                if not re.match(r"^\d+$", value):
                    return False
                set_value = int(value)
                if stuff.type == OPTIONS_TYPE_PERCENTAGE and (set_value < 0 or set_value > 100):
                    return False
            elif stuff.type == OPTIONS_TYPE_COLOUR:
                if value in ["none", "default"]:
                    set_value = value
                else:
                    colours = [upper_case(c) for c in value.split()]
                    bad = [c for c in colours if c not in self._colours]
                    if bad:
                        return False
                    set_value = "%^" + "%^ %^".join(colours) + "%^"
        return stuff.set(player, set_value) if set_value is not None else False

    def help_text(self) -> str:
        output = "Options help:\n"
        for category in ["output", "combat", "colour", "terminal", "input", "earmuff", "command", "personal", "playtester", "player"]:
            output += f"{category.capitalize()} settings:\n"
            sub_options = self.query_sub_options(None, category)
            for opt in sub_options:
                full_opt = f"{category} {opt}"
                values = self.query_option_values(None, full_opt)
                help_text = self.query_option_help(None, full_opt)
                output += f"  {opt}: {', '.join(values) if values else 'variable'} - {help_text}\n"
        output += "Syntax: options [setting] [value] or options help\nExample: options combat monitor on"
        return output

# Initialize options handler
options_handler = OptionsHandler()

async def init(driver_instance):
    await options_handler.init(driver_instance)

# /mnt/home2/mud/systems/quest.py
from typing import Dict, List, Optional, Tuple, Union
from ..driver import driver, Player, MudObject
import asyncio
import time
import os

class QuestHandler:
    def __init__(self):
        self.quest_name: List[str] = []
        self.quest_level: List[int] = []
        self.quest_title: List[str] = []
        self.quest_story: List[str] = []
        self.last_done_by: List[str] = []
        self.num_times_done: List[int] = []
        self.quest_status: List[int] = []
        self.total_qp: int = 0
        self.SAVE_FILE = "/save/quests"
        self.BACKUP_FILE = "/save/quests/quests"
        self.TEXTS_DIR = "/save/quests/"
        self.load_quests()

    def load_quests(self):
        try:
            data = driver.load_object(self.SAVE_FILE)
            if data:
                self.quest_name = data.get("quest_name", [])
                self.quest_level = data.get("quest_level", [])
                self.quest_title = data.get("quest_title", [])
                self.quest_story = data.get("quest_story", [])
                self.last_done_by = data.get("last_done_by", [])
                self.num_times_done = data.get("num_times_done", [])
                self.quest_status = data.get("quest_status", [])
                self.total_qp = data.get("total_qp", 0)
            if not self.quest_name:
                self.quest_name = []
            if not self.quest_level:
                self.quest_level = []
            if not self.quest_title:
                self.quest_title = []
            if not self.quest_story:
                self.quest_story = []
            if not self.last_done_by:
                self.last_done_by = []
            if not self.num_times_done:
                self.num_times_done = []
            if not self.quest_status and self.quest_name:
                self.quest_status = [1] * len(self.quest_name)
            self.total_qp = sum(level for level, status in zip(self.quest_level, self.quest_status) if status)
        except:
            pass

    def save_quests(self):
        data = {
            "quest_name": self.quest_name,
            "quest_level": self.quest_level,
            "quest_title": self.quest_title,
            "quest_story": self.quest_story,
            "last_done_by": self.last_done_by,
            "num_times_done": self.num_times_done,
            "quest_status": self.quest_status,
            "total_qp": self.total_qp
        }
        driver.save_object(self.SAVE_FILE, data)
        driver.unguarded(lambda: os.system(f"cp {self.SAVE_FILE}.o {self.BACKUP_FILE}.{time.time()}"))

    def query_total_qp(self) -> int:
        return self.total_qp

    def add_quest(self, name: str, level: int, title: str, story: str) -> bool:
        if name in self.quest_name:
            return False
        self.quest_name.append(name)
        self.quest_level.append(level)
        self.quest_title.append(title)
        self.quest_story.append(story)
        self.last_done_by.append("nobody")
        self.num_times_done.append(0)
        self.quest_status.append(1)
        log_name = driver.this_player().name if driver.this_player() else driver.previous_object().oid
        driver.log_file("QUESTS", f"{log_name} added: {name}, {level}, {title}, {story}\n")
        self.save_quests()
        self.total_qp += level
        return True

    def change_quest_status(self, name: str) -> int:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        if temp == -1:
            return -1
        self.quest_status[temp] = 1 - self.quest_status[temp]
        self.total_qp += self.quest_level[temp] if self.quest_status[temp] else -self.quest_level[temp]
        self.save_quests()
        return self.quest_status[temp]

    def query_quest_status(self, name: str) -> int:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        return -1 if temp == -1 else self.quest_status[temp]

    def query_quest_level(self, name: str) -> int:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        return -1 if temp == -1 else self.quest_level[temp]

    def set_quest_level(self, name: str, level: int) -> bool:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        if temp == -1:
            return False
        log_name = driver.this_player().name if driver.this_player() else driver.previous_object().oid
        driver.log_file("QUESTS", f"{log_name} : level set for {name} to {level}\n")
        self.total_qp += level - self.quest_level[temp] if self.quest_status[temp] else 0
        self.quest_level[temp] = level
        self.save_quests()
        return True

    def query_quest_story(self, name: str) -> str:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        return "did nothing" if temp == -1 else self.quest_story[temp]

    def set_quest_story(self, name: str, story: str) -> bool:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        if temp == -1:
            return False
        log_name = driver.this_player().name if driver.this_player() else driver.previous_object().oid
        driver.log_file("QUESTS", f"{log_name} : story set for {name} to {story}\n")
        self.quest_story[temp] = story
        self.save_quests()
        return True

    def query_quest_title(self, name: str) -> str:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        return "Unknown Quester" if temp == -1 or not self.quest_title[temp] else self.quest_title[temp]

    def set_quest_title(self, name: str, title: str) -> bool:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        if temp == -1:
            return False
        log_name = driver.this_player().name if driver.this_player() else driver.previous_object().oid
        driver.log_file("QUESTS", f"{log_name} : title set for {name} to {title}\n")
        self.quest_title[temp] = title
        self.save_quests()
        return True

    def query_quest_times(self, name: str) -> int:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        return -1 if temp == -1 else self.num_times_done[temp]

    def query_quest_done(self, name: str) -> Union[str, int]:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        return -1 if temp == -1 else self.last_done_by[temp]

    def delete_quest(self, name: str) -> bool:
        temp = self.quest_name.index(name) if name in self.quest_name else -1
        if temp == -1:
            return False
        log_name = driver.this_player().name if driver.this_player() else driver.previous_object().oid
        driver.log_file("QUESTS", f"{log_name} removed : {name}\n")
        self.total_qp -= self.quest_level[temp]
        for attr in [self.quest_name, self.quest_level, self.quest_title, self.quest_story, self.last_done_by, self.num_times_done, self.quest_status]:
            attr.pop(temp)
        self.save_quests()
        return True

    def query_quest_names(self) -> List[str]:
        return self.quest_name.copy()

    def query_quest_levels(self) -> List[int]:
        return self.quest_level.copy()

    def query_quest_titles(self) -> List[str]:
        return self.quest_title.copy()

    def query_quest_stories(self) -> List[str]:
        return self.quest_story.copy()

    def quest_completed(self, name: str, quest: str, prev_ob: MudObject):
        driver.log_file("QUESTS", f"{time.ctime()} {name} completed {quest}\n")
        driver.user_event("inform", f"{name} completes {quest}", "quest")
        word = prev_ob.name if prev_ob.name else prev_ob.oid
        driver.log_file("QUESTS", f"given by {word}\n")
        temp = self.quest_name.index(quest) if quest in self.quest_name else -1
        if temp == -1:
            driver.log_file("QUESTS", "non existent quest\n")
            return
        self.last_done_by[temp] = name
        self.num_times_done[temp] += 1
        self.save_quests()

    def query_player_fame(self, name: str) -> int:
        if not name or not driver.player_handler.test_user(name):
            return 0
        player_qp = driver.library.query_quest_points(name)
        return (player_qp * 125) // self.query_total_qp()

    def query_fame_str(self, name: str) -> str:
        fame = self.query_player_fame(name)
        ranges = [(0, 4, "completely unknown"), (5, 14, "unknown"), (15, 24, "unknown"),
                  (25, 34, "moderately well known"), (35, 44, "well known"), (45, 54, "very well known"),
                  (55, 64, "known throughout the region"), (65, 74, "famous"), (75, 84, "renowned"),
                  (85, 94, "Disc renowned"), (95, 100, "so renowned that no introduction is needed")]
        for low, high, desc in ranges:
            if low <= fame <= high:
                return desc
        return "so renowned that no introduction is needed"

    def query_player_story(self, name: str) -> List[str]:
        if not name or not driver.player_handler.test_user(name):
            return []
        quests = self.query_quest_names()
        story = ["Is an under achiever."] if len(quests) == 1 else []
        for quest in quests:
            if driver.library.query_quest_done(name, quest):
                story.insert(0, self.query_quest_story(quest))
        return story

    def print_some_stats(self):
        for i in range(len(self.quest_name)):
            print(f"{self.quest_name[i]}: {self.num_times_done[i]}, {self.quest_level[i]}")

quest_handler = QuestHandler()

class QuestCommand:
    def __init__(self):
        self.names: List[str] = []
        self.makers: Dict[Player, Tuple[int, List]] = {}

    async def cmd(self, player: str = None, sorted: bool = False) -> int:
        quests = quest_handler.query_quest_names() if not player else driver.library.query_quests(player)
        if not quests:
            driver.add_failed_mess("That player has not done any quests.\n")
            return 0
        if sorted:
            quests.sort()
        text = f"$P$Quest list$P$\n{'Total quests on Discworld' if not player else f'Quests done for player {player}'} :-\n\n"
        for i, quest in enumerate(quests):
            text += f"{i+1}. {quest} ({quest_handler.query_quest_title(quest)}) {quest_text(quest)}\n"
        await driver.tell_object(driver.this_player(), text)
        return 1

    def quest_text(self, quest: str) -> str:
        status = quest_handler.query_quest_status(quest)
        return "(inactive)" if status == 0 else "" if status == 1 else "(broken)"

    def query_patterns(self) -> List[Tuple[str, Callable]]:
        return [
            ("", lambda: asyncio.run(self.cmd(0, 0))),
            ("<string'player'>", lambda p: asyncio.run(self.cmd(p, 0))),
            ("<string'player'> sorted", lambda p: asyncio.run(self.cmd(p, 1)))
        ]

quest_command = QuestCommand()

async def init(driver_instance):
    driver = driver_instance
    for player in driver.players:
        player.add_action("quests", lambda obj, caller, arg: asyncio.run(quest_command.cmd(arg.split()[0] if arg else None, "sorted" in arg)))

def quest_text(quest: str) -> str:
    return quest_command.quest_text(quest)

# /mnt/home2/mud/systems/rooftop.py
from typing import Optional, List, Dict, Union
from ..driver import driver, MudObject, Player
import math
import random

# Constants from rooftop.c
TOO_SOON = "too soon to proceed from rooftop"
ROCK = "other.movement.climbing.rock"

class Rooftop(MudObject):
    def __init__(self, oid: str, name: str):
        super().__init__(oid, name)
        self.room: Optional[MudObject] = None
        self.wall: Optional[MudObject] = None
        self.damages: Dict[str, int] = {}
        self.damage_types: List[str] = ["weak", "slope", "step", "jump"]
        self.roof_max_weight: int = 0  # Max weight in units (20 units = 1 kg)
        self.gradient: int = 0  # Percentage grade (converted from degrees)
        self.weak_roof_dest: Optional[str] = None
        self.slope_dest: Optional[str] = None
        self.place: str = "roof"
        self.death_reason: Optional[str] = None
        self.jump_info: Dict[str, List[Union[str, int]]] = {}
        self.translations: Dict[str, str] = {}
        # Message arrays
        self.weak_messages: List[str] = [
            "The roof collapses! This is going to be painful...\n",
            "$short$ crashes down through a weak spot in the roof.",
            "$short$ comes crashing to the ground, landing in a rain of debris.",
            "You hear an ominous creak.\n"
        ]
        self.slope_messages: List[str] = [
            "The roof is too steep for you to stand on! It's time to make friends with the floor...\n",
            "$short$ gets in touch with gravity and slides over the edge of the roof.",
            "$short$ comes crashing to the ground, landing in a heap."
        ]
        self.step_messages: List[str] = [
            "You step off the edge of the roof into midair.\n",
            "$short$ steps off the edge of the roof and plummets earthwards.",
            "$short$ comes crashing to the ground, landing in a heap."
        ]
        self.jump_tm_messages: List[str] = [
            "You leap more gracefully through the air.",
            "You feel more able to leap tall buildings in a single bound.",
            "You jump like a mountain goat."
        ]
        self.jump_success_messages: List[str] = [
            "You launch yourself off the edge of the roof and land gracefully on the other side.\n",
            "$short$ jumps gracefully across the gap to the $dir$.",
            "$short$ jumps in from across the gap to the $opp_dir$."
        ]
        self.jump_failure_messages: List[str] = [
            "You launch yourself off the edge of the roof!\nUnfortunately you misjudge the distance and plummet earthwards. This is going to hurt...\n",
            "$short$ jumps off to the $dir$, but misjudges and plummets earthwards.",
            "$short$ plummets to the ground, landing in a heap."
        ]
        self.ghost_fall_messages: List[str] = [
            "You find your consciousness drifting earthwards.\n",
            "$the_short$ drifts earthwards.",
            "$the_short$ drifts in from above, looking somewhat dazed."
        ]
        self.item_slope_messages: List[str] = [
            "$the_short$ tumbles over the edge and plummets to the ground.\n",
            "Hearing a noise, you look up just as $a_short$ falls off the edge of the roof and hits the ground.\n"
        ]
        self.corpse_slope_messages: List[str] = [
            "$the_short$ tumbles over the edge and plummets to the ground with a sickening thud.\n",
            "Hearing a noise, you look up just as $the_short$ tumbles over the edge of the roof and hits the ground with a sickening thud.\n"
        ]

    def setup_shadow(self, room: MudObject):
        """Sets up the rooftop shadow on the given room."""
        self.room = room
        self.wall = driver.clone_object("/systems/wall")
        self.wall.setup_shadow(room)
        self.room.add_command("jump", "<word'direction'>", lambda dir: self.do_roofjump(dir))

    def destruct_shadow(self):
        """Destroys the rooftop shadow and cleans up."""
        if self.room and self.wall:
            self.wall.destruct_shadow()
        self.room = None
        self.wall = None
        self.destruct()

    def set_fall_damage(self, type: str, damage: int):
        """Sets the fall damage for a specific type."""
        damage = abs(damage)
        if type == "all":
            for t in self.damage_types:
                self.damages[t] = damage
        elif type in self.damage_types:
            self.damages[type] = damage

    def query_fall_damage(self, type: str) -> Union[int, Dict[str, int]]:
        """Queries the fall damage for a type."""
        if type == "all":
            return self.damages.copy()
        return self.damages.get(type, 0)

    def calc_fall_damage(self, type: str) -> int:
        """Calculates randomized fall damage."""
        if type == "all":
            return 0
        return self.query_fall_damage(type) + random.randint(0, self.query_fall_damage(type))

    def set_weak_roof(self, maxweight: int, dest: str):
        """Sets the maximum weight capacity and collapse destination."""
        self.roof_max_weight = maxweight
        self.weak_roof_dest = dest

    def set_slope(self, angle: int, loc: str, dest: str):
        """Sets the roof gradient and slip destination."""
        self.gradient = (angle * 100) // 90
        self.place = loc
        self.slope_dest = dest

    def set_jump(self, dir: Union[str, List[str]], dest: str, fall_dest: str, distance: int) -> int:
        """Sets up a jumping exit with skill check."""
        dirs = [dir] if isinstance(dir, str) else dir
        if not all(isinstance(d, str) for d in dirs):
            return 0
        dirs.sort()
        if any(d in self.translations for d in dirs):
            return -1

        key = dirs[0]
        self.jump_info[key] = [dest, fall_dest, distance]
        for d in dirs:
            self.translations[d] = key

        if not self.room.query_exit(key):
            self.room.add_exit(key, dest, "roof")
        self.room.modify_exit(key, [
            "closed", 1,
            "function", lambda verb, ob, special: self.silly_move(verb, ob, special, self.jump_info[self.translations[verb]][1], "step", self.step_messages),
            "look", "You'll have to jump across to see what's on the other side."
        ])
        return 1

    def set_weak_messages(self, player: str, from_: str, to: str, warn: str):
        """Sets messages for weak roof collapse."""
        self.weak_messages = [player, from_, to, warn]

    def set_slope_messages(self, player: str, from_: str, to: str):
        """Sets messages for slipping off a slope."""
        self.slope_messages = [player, from_, to]

    def set_step_messages(self, player: str, from_: str, to: str):
        """Sets messages for stepping off the edge."""
        self.step_messages = [player, from_, to]

    def set_jump_tm_messages(self, messages: List[str]):
        """Sets messages for skill improvement during jumps."""
        self.jump_tm_messages = messages

    def set_jump_success_messages(self, player: str, from_: str, to: str):
        """Sets messages for successful jumps."""
        self.jump_success_messages = [player, from_, to]

    def set_jump_failure_messages(self, player: str, from_: str, to: str):
        """Sets messages for failed jumps."""
        self.jump_failure_messages = [player, from_, to]

    def set_ghost_fall_messages(self, player: str, from_: str, to: str):
        """Sets messages for ghost falls."""
        self.ghost_fall_messages = [player, from_, to]

    def set_corpse_slope_messages(self, from_: str, to: str):
        """Sets messages for corpses sliding off."""
        self.corpse_slope_messages = [from_, to]

    def set_item_slope_messages(self, from_: str, to: str):
        """Sets messages for items sliding off."""
        self.item_slope_messages = [from_, to]

    def set_death_reason(self, reason: str):
        """Sets the death reason for falling."""
        self.death_reason = reason
        driver.call_out(lambda: setattr(self, "death_reason", None), 2)

    def query_death_reason(self) -> str:
        """Returns the death reason."""
        reason = self.death_reason or f"a rooftop ({self.room.oid}) with an incorrectly set death message"
        return driver.convert_message(reason)

    def process_mess(self, msg: str, obj: MudObject, direction: Optional[str] = None) -> str:
        """Processes messages with substitutions."""
        if not msg:
            return ""
        directions = ["north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest"]
        opp_dir = None
        if direction and direction in directions:
            opp_idx = (directions.index(direction) + 4) % 8
            opp_dir = directions[opp_idx]

        transforms = {
            "$dir$": direction,
            "$opp_dir$": opp_dir,
            "$short$": obj.query_short(),
            "$poss$": obj.query_possessive(),
            "$pronoun$": obj.query_pronoun(),
            "$obj$": obj.query_objective(),
            "$a_short$": obj.a_short(),
            "$the_short$": obj.the_short(),
            "$one_short$": obj.one_short()
        }
        for key, val in transforms.items():
            if val:
                msg = msg.replace(key, val)
        return msg

    def do_fall(self, obj: MudObject, dest: Union[str, MudObject], dam_type: str, messages: List[str], dir: Optional[str]):
        """Handles falling mechanics."""
        obj.remove_property(TOO_SOON)
        messages = [self.process_mess(m, obj, dir) for m in messages]
        if isinstance(dest, str):
            destob = driver.load_object(dest)
            if not destob:
                obj.tell(f"Cannot find {dest}.\nMoving you to the void - Please contact a creator.\n")
                obj.move_with_look("/room/void", "Poof. $N appears.\n", "$N plummets earthwards.\n")
                return
        else:
            destob = dest

        obj.tell(messages[0])
        obj.move_with_look(destob, messages[2], messages[1])
        if obj.query_property("dead"):
            return

        damage = self.calc_fall_damage(dam_type)
        if damage >= obj.query_hp():
            self.set_death_reason("plummeting from the rooftops")
            obj.attack_by(self.room)
            obj.do_death()
        else:
            obj.adjust_hp(-damage)

    def silly_move(self, verb: str, ob: MudObject, special: str, dest: str, dam_type: str, messages: List[str]) -> int:
        """Handles stepping off the edge."""
        self.do_fall(ob, dest, dam_type, messages, None)
        return 0  # Notify fail

    def event_enter(self, obj: MudObject, from_room: Optional[MudObject]):
        """Handles entering the rooftop with skill checks."""
        if not obj or obj.query_property("demon") or obj.query_property("floating"):
            return

        obj.add_property(TOO_SOON, 1, 5)

        if self.roof_max_weight:
            contents = self.room.all_inventory()
            total_weight = 0
            for item in contents:
                object_weight = item.query_weight() + item.query_loc_weight()
                total_weight += object_weight

            if total_weight > self.roof_max_weight:
                self.room.tell_room(self.weak_messages[3])
                destob = driver.load_object(self.weak_roof_dest)
                if not destob:
                    self.room.tell_room(f"Error loading room {self.weak_roof_dest}, moving to the void.\nPlease contact a creator.\n")
                    for item in contents:
                        item.move_with_look("/room/void")
                    return
                for item in contents:
                    driver.call_out(lambda o=item: self.do_fall(o, destob, "weak", self.weak_messages, None), 1)
                return

        if self.gradient:
            if obj.query_living():
                if obj.query_property("dead") or not obj.query_max_weight():
                    driver.call_out(lambda o=obj: self.do_fall(o, self.slope_dest, "step", self.ghost_fall_messages, None), 1)
                    return
                encum = (100 * obj.query_loc_weight()) / obj.query_max_weight()
                diff = int(math.sin(math.radians(self.gradient)) * (encum * 10))
                driver.call_out(lambda o=obj: self.gradient_check(o, self.slope_dest, int(diff + (self.gradient * 2))), 1)
            else:
                if obj.query_name() in ["death", "binky"]:
                    return
                if self.gradient > 3:
                    messages = self.corpse_slope_messages if obj.query_corpse() else self.item_slope_messages
                    obj.move(self.slope_dest, self.process_mess(messages[1], obj, None), self.process_mess(messages[0], obj, None))
            return

        obj.remove_property(TOO_SOON)

    def gradient_check(self, obj: MudObject, destination: str, diff: int):
        """Performs a skill check for sloping roofs."""
        obj.remove_property(TOO_SOON)
        result = driver.tasker.perform_task(obj, ROCK, diff + 1, "TM_FIXED")
        if result == "AWARD":
            obj.tell(f"YELLOW: {random.choice(['You balance more confidently on the {self.place}.', 'Climbing becomes easier.'])}\n")
        if result in ["AWARD", "SUCCEED"]:
            obj.tell(f"The {self.place} is steep, but you manage not to fall.\n")
        elif result == "FAIL":
            destob = driver.load_object(destination)
            if not destob:
                obj.tell(f"Error loading room {destination}, moving you to the void.\nPlease contact a creator.\n")
                obj.move_with_look("/room/void")
            else:
                self.do_fall(obj, destob, "slope", self.slope_messages, None)
        else:
            obj.tell("Gnaaaaaaaaaaaah! You should not be getting this message. Please contact a creator.\n")

    def do_roofjump(self, dir: str) -> int:
        """Handles the jump command with skill check."""
        key = self.translations.get(dir)
        if not key or key not in self.jump_info:
            self.room.add_failed_mess("You can't jump there!\n")
            return 0

        info = self.jump_info[key]
        destination = driver.load_object(info[0])
        if not destination:
            self.room.add_failed_mess(f"Error! The file {info[0]} does not exist or does not load. Please contact a creator.\n")
            return 0

        fall_destination = driver.load_object(info[1])
        if not fall_destination:
            self.room.add_failed_mess(f"Error! The file {info[1]} does not exist or does not load. Please contact a creator.\n")
            return 0

        distance = info[2]
        if distance:
            weight = driver.this_player().query_loc_weight()
            max_weight = driver.this_player().query_max_weight()
            distance = int(distance * ((weight * 7) / max_weight + 15))
            result = driver.tasker.perform_task(driver.this_player(), ROCK, distance, "TM_FIXED")
            if result == "AWARD":
                driver.this_player().tell(f"YELLOW: {random.choice(self.jump_tm_messages)}\n")
            if result in ["AWARD", "SUCCEED"]:
                driver.this_player().tell(self.process_mess(self.jump_success_messages[0], driver.this_player(), dir))
                driver.this_player().move_with_look(
                    destination,
                    self.process_mess(self.jump_success_messages[2], driver.this_player(), dir),
                    self.process_mess(self.jump_success_messages[1], driver.this_player(), dir)
                )
            elif result == "FAIL":
                driver.this_player().tell(self.process_mess(self.jump_failure_messages[0], driver.this_player(), dir))
                self.do_fall(driver.this_player(), fall_destination, "jump", self.jump_failure_messages, dir)
            else:
                driver.this_player().tell("Oh dear. Something is broken. Please inform a creator.\n")
            return 1
        return 0

    def test_remove(self, ob: MudObject, flag: int, dest: Union[str, MudObject]) -> bool:
        """Prevents removal if balance hasn’t been caught."""
        if not ob.query_living():
            return self.room.test_remove(ob, flag, dest)

        if isinstance(dest, MudObject):
            dest = dest.oid
        if not isinstance(dest, str) or dest == "/room/rubbish":
            return True

        if ob.query_property(TOO_SOON):
            ob.tell("You haven't quite caught your balance yet.\n")
            return False
        return self.room.test_remove(ob, flag, dest)

async def init(driver_instance):
    driver = driver_instance

# /mnt/home2/mud/systems/room.py
from typing import Dict, List, Optional, Tuple, Union, Callable
from ..driver import driver, Player, MudObject
import asyncio
import math
import time
import random
from . import desc, extra_look, light, property, export_inventory, help_files, effects

# Constants (from includes like room.h, situations.h)
ENCHANT_HALF = 3600  # From room.h (assumed value for decay half-life)
ROOM_DEST = 0
ROOM_EXIT = 1
ROOM_MESS = 2
ROOM_OBV = 3
ROOM_REL = 4
ROOM_FUNC = 5
ROOM_SIZE = 6
ROOM_GRADE = 7
ROOM_DELTA = 8
ROOM_LOOK = 9
ROOM_LOOK_FUNC = 10
ROOM_LINK_MESS = 11
ROOM_DEFAULT_INDEX = 0
ROOM_DAY_INDEX = 1
ROOM_NIGHT_INDEX = 2
ROOM_VOID = "/room/void"
SHORTEN = {
    "north": "n", "northeast": "ne", "east": "e", "southeast": "se",
    "south": "s", "southwest": "sw", "west": "w", "northwest": "nw",
    "up": "u", "down": "d"
}
STD_ORDERS = [
    "north", [0, 1, 0], "northeast", [1, 1, 0], "east", [1, 0, 0],
    "southeast", [1, -1, 0], "south", [0, -1, 0], "southwest", [-1, -1, 0],
    "west", [-1, 0, 0], "northwest", [-1, 1, 0], "up", [0, 0, 1],
    "down", [0, 0, -1]
]
WHEN_ANY_TIME = 0xFFFFFF  # From situations.h (assumed all hours)

class Room(MudObject, desc.Desc, extra_look.ExtraLook, light.Light, property.Property,
           export_inventory.ExportInventory, help_files.HelpFiles, effects.Effects):
    def __init__(self, oid: str, name: str):
        super().__init__(oid, name)
        self.do_setup: bool = False
        self.co_ord: Optional[List[int]] = None
        self.co_ord_calculated: bool = False
        self.long_exit: Optional[str] = None
        self.long_exit_mxp: Optional[str] = None
        self.short_exit: Optional[str] = None
        self.theft_handler: Optional[str] = None
        self.aliases: List[str] = []
        self._exits: List[str] = []
        self.item: Optional[MudObject] = None
        self.chatter: Optional[MudObject] = None
        self.sitchanger: Optional[MudObject] = None
        self.linker: Optional[MudObject] = None
        self.terrain: Optional[MudObject] = None
        self.wall: Optional[MudObject] = None
        self.hidden_objects: List[MudObject] = []
        self._use_internal_objects: List[MudObject] = []
        self.door_control: Dict[str, Union[str, MudObject]] = {}
        self.dest_other: List[Union[str, List]] = []
        self.enchant_time: int = time.time()
        self.background_enchant: int = 0
        self.dynamic_enchant: float = 0.0
        self.last_visited: int = 0
        self.variablelongs: Optional[List[str]] = None
        self.variablechats: Optional[List[Union[List, None]]] = None
        self.variableitems: Optional[List[List]] = None
        self.is_day: int = -1
        self.not_replaceable: bool = False
        self.attrs["location"] = "inside"
        self.attrs["here"] = "on the floor"
        if not self.do_setup:
            self.setup()
            self.reset()

    def query_is_room(self) -> bool:
        return True

    def query_enchant(self) -> int:
        enchant_level = int(0.5 + self.dynamic_enchant * math.exp(-0.693 * (time.time() - self.enchant_time) / ENCHANT_HALF) + self.background_enchant)
        return min(enchant_level, 5000)

    def set_enchant(self, number: int) -> int:
        number = max(0, number)
        if driver.previous_object() == self:
            self.background_enchant = number
            self.dynamic_enchant = 0.0
        else:
            self.dynamic_enchant = number - self.background_enchant
        self.enchant_time = time.time()
        return number

    def add_enchant(self, number: int) -> int:
        self.dynamic_enchant = self.dynamic_enchant * math.exp(-0.693 * (time.time() - self.enchant_time) / ENCHANT_HALF) + number
        self.enchant_time = time.time()
        return int(0.5 + self.dynamic_enchant) + self.background_enchant

    def set_background_enchant(self, number: int):
        self.background_enchant = number

    def set_dynamic_enchant(self, number: float):
        self.dynamic_enchant = number
        self.enchant_time = time.time()

    def query_background_enchant(self) -> int:
        return self.background_enchant

    def query_dynamic_enchant(self) -> float:
        self.dynamic_enchant = self.dynamic_enchant * math.exp(-0.693 * (time.time() - self.enchant_time) / ENCHANT_HALF)
        self.enchant_time = time.time()
        return self.dynamic_enchant

    def query_co_ord(self) -> Optional[List[int]]:
        return self.co_ord.copy() if self.co_ord else None

    def set_co_ord(self, new_co_ord: List[int]):
        if not isinstance(new_co_ord, list):
            print("Warning: Co-ordinate must be an array.")
            return
        if len(new_co_ord) != 3:
            print("Warning: The co-ordinate must have three elements.")
            return
        self.co_ord = new_co_ord
        self.co_ord_calculated = driver.previous_object() != self

    def flush_co_ord(self):
        self.co_ord = None
        self.co_ord_calculated = False

    def query_co_ord_calculated(self) -> bool:
        return self.co_ord_calculated

    def query_long_exit(self) -> Optional[str]:
        return self.long_exit

    def query_long_exit_mxp(self) -> Optional[str]:
        return self.long_exit_mxp

    def calc_long_exit(self):
        words = []
        for i in range(0, len(self.dest_other), 2):
            tmp = self.dest_other[i + 1][ROOM_OBV]
            if not tmp:
                continue
            add = False
            if isinstance(tmp, int) and tmp:
                add = True
            elif isinstance(tmp, str):
                add = getattr(self, tmp)(self.dest_other[i])
            elif isinstance(tmp, list):
                add = getattr(tmp[0], tmp[1])(self.dest_other[i])
            if add:
                words.append(f"$R$-{self.dest_other[i]}$R$" if self.dest_other[i + 1][ROOM_REL] else self.dest_other[i])
        if not words:
            self.long_exit = "There are no obvious exits."
            self.long_exit_mxp = "There are no obvious exits."  # Simplified MXP handling
        elif len(words) == 1:
            self.long_exit = f"There is one obvious exit: {words[0]}."
            self.long_exit_mxp = f"There is one obvious exit: {words[0]}."
        else:
            self.long_exit = f"There are {self.query_num(len(words), 0)} obvious exits: {self.query_multiple_short(words)}."
            self.long_exit_mxp = f"There are {self.query_num(len(words), 0)} obvious exits: {self.query_multiple_short(words)}."

    def query_theft_handler(self) -> Optional[str]:
        return self.theft_handler

    def set_theft_handler(self, word: str):
        self.theft_handler = word

    def query_aliases(self) -> List[str]:
        return self.aliases.copy()

    def add_alias(self, names: Union[str, List[str]], word: str):
        if not self.aliases:
            self.aliases = []
        if isinstance(names, list):
            for name in names:
                self.add_alias(name, word)
            return
        self.aliases.extend([word, names])
        driver.call_out(self.calc_exits, 1)

    def remove_alias(self, names: Union[str, List[str]], word: str):
        if not self.aliases:
            return
        if isinstance(names, list):
            for name in names:
                self.remove_alias(name, word)
            return
        i = len(self.aliases) - 2
        while i >= -1:
            if self.aliases[i] == word and self.aliases[i + 1] == names:
                self.aliases = self.aliases[:i] + self.aliases[i + 2:]
            i -= 2
        driver.call_out(self.calc_exits, 1)

    def query_exits(self) -> List[str]:
        return self._exits.copy()

    def reset_exits(self):
        self._exits = []

    def query_item(self) -> Optional[MudObject]:
        return self.item

    def query_chatter(self) -> Optional[MudObject]:
        return self.chatter

    def query_situation_changer(self) -> Optional[MudObject]:
        return self.sitchanger

    def query_linker(self) -> Optional[MudObject]:
        return self.linker

    def query_terrain(self) -> Optional[MudObject]:
        return self.terrain

    def query_wall(self) -> Optional[MudObject]:
        return self.wall

    def query_hidden_objects(self) -> List[MudObject]:
        return self.hidden_objects.copy()

    def add_hidden_object(self, thing: MudObject) -> bool:
        if thing in self.hidden_objects:
            return False
        self.hidden_objects.append(thing)
        return True

    def remove_hidden_object(self, thing: MudObject) -> bool:
        if thing not in self.hidden_objects:
            return False
        self.hidden_objects.remove(thing)
        return True

    def add_use_internal_object(self, thing: MudObject):
        if thing not in self._use_internal_objects:
            self._use_internal_objects.append(thing)

    def remove_use_internal_object(self, thing: MudObject):
        if thing in self._use_internal_objects:
            self._use_internal_objects.remove(thing)

    def query_use_internal_objects(self) -> List[MudObject]:
        return self._use_internal_objects.copy()

    def query_door_control(self, direc: str = None, name: str = None) -> Union[Dict, Optional[Union[str, MudObject]]]:
        if not direc:
            return self.door_control.copy()
        key = f"{direc} {name}" if name else direc
        return self.door_control.get(key)

    def query_dest_other(self, direc: str = None) -> Union[List, Optional[List]]:
        if not direc:
            return self.dest_other.copy()
        i = self.dest_other.index(direc) if direc in self.dest_other else -1
        return self.dest_other[i + 1].copy() if i != -1 else None

    def query_dest_dir(self, thing: MudObject = None) -> List[str]:
        ret = []
        for i in range(0, len(self.dest_other), 2):
            direc = self.dest_other[i]
            if not self.dest_other[i + 1][ROOM_REL] or not thing:
                ret.extend([direc, self.dest_other[i + 1][ROOM_DEST]])
            else:
                ret.extend([thing.find_rel(direc), self.dest_other[i + 1][ROOM_DEST]])
        return ret

    def query_direc(self, thing: MudObject = None) -> List[str]:
        ret = []
        for i in range(0, len(self.dest_other), 2):
            direc = self.dest_other[i]
            if not self.dest_other[i + 1][ROOM_REL] or not thing:
                ret.append(direc)
            else:
                ret.append(thing.find_rel(direc))
        return ret

    def query_destination(self, exit: str) -> str:
        i = self.dest_other.index(exit) if exit in self.dest_other else -1
        if i == -1 and driver.this_player():
            i = self.dest_other.index(driver.this_player().reorient_rel(exit)) if driver.this_player().reorient_rel(exit) in self.dest_other else -1
        return self.dest_other[i + 1][ROOM_DEST] if i != -1 else ROOM_VOID

    def test_add(self, thing: MudObject, flag: int) -> bool:
        return True

    def test_remove(self, thing: MudObject, flag: int, dest: Union[str, MudObject]) -> bool:
        return True

    def add_weight(self, number: int) -> bool:
        return True

    def query_no_writing(self) -> bool:
        return True

    def query_decay(self) -> int:
        return 10

    def query_day(self) -> int:
        return self.is_day

    def attack_speed(self) -> int:
        return 15

    def query_dark_mess(self) -> str:
        return self.attrs.get("dark mess", "It's dark here, isn't it?")

    def set_dark_mess(self, word: str):
        self.attrs["dark mess"] = word

    def query_bright_mess(self) -> str:
        return self.attrs.get("bright mess", "It's too bright to see anything!")

    def set_bright_mess(self, word: str):
        self.attrs["bright mess"] = word

    def query_room_size(self) -> Union[int, List[int]]:
        return self.attrs.get("room size", 10)

    def query_room_size_array(self) -> List[int]:
        room_size = self.query_room_size()
        return room_size if isinstance(room_size, list) else [room_size] * 3

    def set_room_size(self, number: Union[int, List[int]]):
        if isinstance(number, int):
            self.attrs["room size"] = number
        elif isinstance(number, list) and len(number) == 3:
            self.attrs["room size"] = number
        else:
            print("Room size must be an integer or an array of three integers.")

    def id(self, word: str) -> bool:
        return False

    def expand_alias(self, word: str) -> str:
        if not self.aliases or not len(self.aliases):
            return word
        i = self.aliases.index(word) if word in self.aliases else -1
        if i == -1:
            return word
        return self.aliases[i - 1] if i % 2 else word

    def calc_short_exit_string(self) -> str:
        words = []
        for i in range(0, len(self.dest_other), 2):
            tmp = self.dest_other[i + 1][ROOM_OBV]
            if not tmp:
                continue
            add = False
            if isinstance(tmp, int) and tmp:
                add = True
            elif isinstance(tmp, str):
                add = getattr(self, tmp)(self.dest_other[i])
            elif isinstance(tmp, list):
                add = getattr(tmp[0], tmp[1])(self.dest_other[i])
            if add:
                short_form = SHORTEN.get(self.dest_other[i])
                if short_form:
                    words.append(f"$r$-{short_form}$r$" if self.dest_other[i + 1][ROOM_REL] else short_form)
                else:
                    if self.dest_other[i + 1][ROOM_REL]:
                        words.append(f"$r$-{self.dest_other[i]}$r$")
                    else:
                        pos = self.dest_other[i].find(" ")
                        if pos != -1:
                            tmp_dir = self.dest_other[i][pos + 1:]
                            tmp = SHORTEN.get(tmp_dir, tmp_dir)
                            words.append(f"{self.dest_other[i][:pos]}{tmp}")
                        else:
                            words.append(self.dest_other[i])
        return " [none]" if not words else f" [{', '.join(words)}]"

    def query_short_exit_string(self) -> str:
        if self.short_exit:
            return f"\033[32m{self.short_exit}\033[0m"  # Simplified color handling
        tmp = self.calc_short_exit_string()
        if not self.attrs.get("no exit cache"):
            self.short_exit = tmp
        return f"\033[32m{tmp}\033[0m"

    def enchant_string(self) -> str:
        words = self.attrs.get("octarine_mess")
        if words:
            return words + "\n"
        enchant = self.query_enchant()
        if 0 <= enchant <= 49:
            return ""
        elif 50 <= enchant <= 149:
            return "There is the residual taste of magic in this place.\n"
        elif 150 <= enchant <= 299:
            return "This place has seen some use of magic.\n"
        elif 300 <= enchant <= 499:
            return "A considerable amount of magic has been used here.\n"
        elif 500 <= enchant <= 749:
            return "A very large quantity of magic has been manipulated here.\n"
        elif 750 <= enchant <= 1000:
            return "You can feel the Forgotten Realms' Weave straining here.\n"  # Adapted for Forgotten Realms
        elif 1001 <= enchant <= 1500:
            return "Little sparks of arcane energy flicker around you.\n"
        elif 1501 <= enchant <= 2000:
            return "Visions of creatures from the Far Realm haunt your periphery.\n"
        else:
            return "So much magic has been expended here that the Weave risks unraveling.\n"

    async def long(self, word: str = "", dark: int = 0) -> str:
        if not self.long_exit:
            self.calc_long_exit()
        ret = ""
        if dark:
            if dark < 0:
                ret = f"{self.query_dark_mess()}\n"
            else:
                ret = f"{self.query_bright_mess()}\n"
            if self.attrs.get("location") == "outside":
                ret += "$weather$"
            if dark in [1, -1]:
                ret = f"$C${self.a_short()}.  {ret}\033[32m{self.long_exit}\033[0m\n"
                if self.query_contents("") != "":
                    ret += "Some objects you can't make out are here.\n"
        else:
            ret = "$long$" if self.attrs.get("location") == "outside" else self.query_long()
            if not ret:
                ret = "Erk, this room seems to be broken.\n"
            extra = self.calc_extra_look()
            if extra:
                ret += extra
            if driver.this_player() and driver.this_player().attrs.get("see_octarine", False):
                ret += self.enchant_string()
            if self.attrs.get("location") == "outside":
                ret += "$weather$"
            ret += f"\033[32m{self.long_exit}\033[0m\n{self.query_contents('')}"
        if self.attrs.get("no exit cache"):
            self.long_exit = None
        return ret

    def pretty_short(self, thing: MudObject = None) -> str:
        dark = thing.check_dark(self.query_light()) if thing else 0
        return self.short(dark)

    def query_visibility(self) -> int:
        return 100

    def can_use_for_co_ords(self, other: str) -> bool:
        return True

    def calc_co_ord(self):
        if self.co_ord:
            return
        std_orders = STD_ORDERS
        for i in range(0, len(self.dest_other), 2):
            other = self.dest_other[i + 1][ROOM_DEST]
            if not driver.find_object(other):
                continue
            other_obj = driver.objects.get(other)
            if not other_obj or other_obj.attrs.get("do_not_use_coords", False):
                continue
            if other.startswith("/w/"):
                continue
            other_co_ord = other_obj.query_co_ord()
            if not other_co_ord or (other_co_ord[0] == 0 and other_co_ord[1] == 0 and other_co_ord[2] == 0):
                continue
            if not self.can_use_for_co_ords(other):
                continue
            j = -1
            delta = self.dest_other[i + 1][ROOM_DELTA]
            if delta:
                self.co_ord = other_co_ord.copy()
                if isinstance(delta, list):
                    for k in range(3):
                        self.co_ord[k] -= delta[k]
                    continue
                else:
                    j = std_orders.index(delta)
            if j == -1:
                j = std_orders.index(self.dest_other[i]) if self.dest_other[i] in std_orders else -1
                if j == -1:
                    continue
            self.co_ord = other_co_ord.copy()
            delta = self.query_room_size_array() + other_obj.query_room_size_array()
            for k in range(3):
                self.co_ord[k] += std_orders[j + 1][k] * (delta[k] + delta[k + 3])
            if j < 16 and self.dest_other[i + 1][ROOM_GRADE]:
                shift = (delta[0] + delta[3]) if j in [0, 1] else (delta[1] + delta[4]) if j in [2, 3] else (delta[0] + delta[1] + delta[3] + delta[4])
                self.co_ord[2] -= (self.dest_other[i + 1][ROOM_GRADE] * shift) // 100
            self.co_ord_calculated = True

    def calc_exits(self):
        self._exits = []
        for i in range(0, len(self.dest_other), 2):
            exit = self.dest_other[i]
            if exit not in self._exits:
                self._exits.append(exit)
                word = SHORTEN.get(exit)
                if word:
                    self._exits.append(word)
            tmp_al = self.aliases.copy()
            j = tmp_al.index(exit) if exit in tmp_al else -1
            while j != -1:
                if j % 2:
                    j -= 1
                else:
                    word = tmp_al[j + 1]
                    if word not in self._exits:
                        self._exits.append(word)
                tmp_al = tmp_al[:j] + tmp_al[j + 2:]
                j = tmp_al.index(exit) if exit in tmp_al else -1

    async def init(self):
        player = driver.this_player()
        if player and player.attrs.get("interactive", False):
            if (not self.last_visited and driver.uptime() > 1800 + random.randint(0, 3600)) or (self.last_visited and (time.time() - self.last_visited > random.randint(0, 900) + 900)):
                xp = random.randint(0, random.randint(0, 50)) if self.attrs.get("clone", False) else random.randint(0, random.randint(0, 500))
                player.adjust_xp(xp, 0)
            self.last_visited = time.time()

        if self.is_day != -1:
            new_day = driver.weather_handler.query_day() > 0
            if new_day != self.is_day:
                self.is_day = new_day
                if self.variablelongs and self.variablelongs[self.is_day]:
                    self.set_long(self.variablelongs[self.is_day])
                if self.variableitems:
                    for i in range(0, len(self.variableitems[1 - self.is_day]), 2):
                        self.remove_item(self.variableitems[1 - self.is_day][i])
                    for i in range(0, len(self.variableitems[self.is_day]), 2):
                        self.add_item(self.variableitems[self.is_day][i], self.variableitems[self.is_day][i + 1])
                self.setup_room_chat()

        if self.chatter:
            self.chatter.check_chat()

        if self.sitchanger:
            self.sitchanger.check_situations()

        if not self._exits:
            self.calc_exits()

        if not self.co_ord:
            self.calc_co_ord()

        self.hidden_objects = [ob for ob in self.hidden_objects if ob]
        for ob in self.hidden_objects:
            ob.init()

        if player and player.attrs.get("player", False):
            for ob in self._use_internal_objects:
                if ob:
                    for inv in ob.find_inv_match("all", player):
                        inv.init()

        if self.item:
            self.item.init()

    def query_zones(self) -> List[str]:
        zones = self.attrs.get("room zone", [])
        return zones if zones else ["nowhere"]

    def add_zone(self, zone: str):
        zones = self.attrs.get("room zone", [])
        zones.append(zone)
        self.attrs["room zone"] = zones

    def remove_zone(self, zone: str):
        zones = self.attrs.get("room zone", [])
        if zone in zones:
            zones.remove(zone)
            self.attrs["room zone"] = zones

    def set_zone(self, zone: str):
        self.add_zone(zone)

    def query_exit(self, direc: str) -> bool:
        return direc in self.dest_other

    def add_exit(self, direc: str, dest: Union[str, MudObject], type: str) -> bool:
        if direc in self.dest_other:
            return False
        if isinstance(dest, MudObject):
            dest = dest.oid
        if not dest.startswith("/"):
            dest = f"/{dest}"
        stuff = [dest] + driver.room_handler.query_exit_type(type, direc)
        self.dest_other.extend([direc, stuff])
        door_stuff = driver.room_handler.query_door_type(type, direc, dest)
        if door_stuff:
            door = MudObject(f"door_{direc}", "door")
            door.setup_door(direc, self, dest, door_stuff, type)
            self.door_control[direc] = door
            self.hidden_objects.append(door)
            key = f"{dest} {door.attrs.get('door_name', '')}" if door.attrs.get("door_name") else dest
            self.door_control[key] = direc
        driver.call_out(self.calc_exits, 1)
        self.long_exit = None
        self.short_exit = None
        return True

    def modify_exit(self, direc: Union[str, List[str]], data: List):
        if isinstance(direc, list):
            for d in direc:
                self.modify_exit(d, data)
            return 0
        i = self.dest_other.index(direc) if direc in self.dest_other else -1
        if i == -1:
            return 0
        for j in range(0, len(data), 2):
            key = data[j].lower()
            if key in ["message", "exit mess", "exit_mess"]:
                self.dest_other[i + 1][ROOM_EXIT] = data[j + 1]
            elif key == "move mess":
                self.dest_other[i + 1][ROOM_MESS] = data[j + 1]
            elif key == "linker mess":
                self.dest_other[i + 1][ROOM_LINK_MESS] = data[j + 1]
            elif key == "obvious":
                self.dest_other[i + 1][ROOM_OBV] = data[j + 1]
                if not isinstance(data[j + 1], int):
                    self.attrs["no exit cache"] = 1
                self.long_exit = None
                self.short_exit = None
            elif key == "function":
                self.dest_other[i + 1][ROOM_FUNC] = data[j + 1]
            elif key == "size":
                self.dest_other[i + 1][ROOM_SIZE] = data[j + 1]
            elif key == "upgrade":
                self.dest_other[i + 1][ROOM_GRADE] = data[j + 1]
            # Add more cases as needed from truncated code
        return 1

    def query_door_open(self, direc: str) -> int:
        door = self.door_control.get(direc)
        if not isinstance(door, MudObject):
            return -1
        return door.query_open()

    def query_relative(self, direc: str) -> bool:
        i = self.dest_other.index(direc) if direc in self.dest_other else -1
        return self.dest_other[i + 1][ROOM_REL] if i != -1 else False

    def query_look(self, direc: str) -> Optional[str]:
        i = self.dest_other.index(direc) if direc in self.dest_other else -1
        if i == -1 or not self.dest_other[i + 1]:
            return None
        return self.dest_other[i + 1][ROOM_LOOK]

    def query_look_func(self, direc: str) -> Optional[List]:
        i = self.dest_other.index(direc) if direc in self.dest_other else -1
        if i == -1 or not self.dest_other[i + 1]:
            return None
        return self.dest_other[i + 1][ROOM_LOOK_FUNC]

    def query_size(self, direc: str) -> int:
        i = self.dest_other.index(direc) if direc in self.dest_other else -1
        if i == -1:
            return 0
        size = self.dest_other[i + 1][ROOM_SIZE]
        if isinstance(size, str):
            return getattr(self, size)()
        elif isinstance(size, list):
            return getattr(size[0], size[1])()
        return size

    def event_magic(self, channel: MudObject, amount: int, caster: MudObject):
        self.add_enchant(amount // 5)

    def event_theft(self, command_ob: MudObject, thief: MudObject, victim: MudObject, stolen: List[MudObject]):
        if thief.attrs.get("caster"):
            thief = driver.find_player(thief.attrs["caster"])
        elif thief.attrs.get("owner"):
            thief = thief.attrs["owner"]
        stolen_shorts = [s.short() for s in stolen]
        driver.log_file("THEFT", f"{time.ctime()[4:19]}: {thief.short()} stole {', '.join(stolen_shorts)} from {victim.short()} in {self.oid}\n")
        handler = self.theft_handler if self.theft_handler and self.theft_handler != "none" else "/obj/handlers/theft_handler"
        driver.call_handler(handler, "handle_theft", self, command_ob, thief, victim, stolen)

    def query_last_visited(self) -> int:
        return self.last_visited

    def add_item(self, shorts: Union[str, List[str]], desc: Union[str, List, Callable], no_plural: bool = False) -> bool:
        if not desc:
            print(f"Error! In {self.oid} add_item({shorts}, 0), not added.")
            return False
        if not self.item:
            self.item = MudObject(f"item_{self.oid}", "item")
        self.item.setup_item(shorts, desc, no_plural)
        return True

    def remove_item(self, word: str) -> bool:
        if not self.item:
            return True
        return self.item.remove_item(word)

    def modify_item(self, word: str, new_desc: Union[str, List]) -> bool:
        if not self.item:
            return False
        return self.item.modify_item(word, new_desc)

    def set_linker(self, rooms: List[str], d_prep: str = "into", s_prep: str = "in", r_name: str = "") -> bool:
        if self.linker:
            return False
        self.linker = MudObject(f"linker_{self.oid}", "linker")
        self.linker.setup_shadow(self, rooms, d_prep, s_prep, r_name)
        return True

    def set_terrain(self, terrain_name: str) -> bool:
        if self.terrain:
            return False
        self.terrain = MudObject(f"terrain_{self.oid}", "terrain")
        self.terrain.setup_shadow(self, terrain_name)
        self.set_not_replaceable(True)
        return True

    def set_wall(self, args: List):
        if not self.wall:
            self.wall = MudObject(f"wall_{self.oid}", "wall")
            self.wall.setup_shadow(self)
        self.wall.set_wall(args)

    def set_default_position(self, stuff: Union[str, List, Callable]):
        self.attrs["default_position"] = stuff

    def query_default_position(self) -> Union[str, List, Callable, None]:
        return self.attrs.get("default_position")

    def is_allowed_position(self, poss: str) -> bool:
        return poss in ["sitting", "standing", "kneeling", "lying", "meditating", "crouching"]

    def dest_me(self):
        if self.oid != ROOM_VOID:
            for thing in self.inventory:
                if thing.attrs.get("player", False):
                    thing.move_with_look(ROOM_VOID, "$N fall$s into the void.")
                else:
                    thing.dest_me()
        if self.chatter:
            self.chatter.dest_me()
        if self.sitchanger:
            self.sitchanger.dest_me()
        if self.linker:
            self.linker.destruct_shadow()
        if self.terrain:
            self.terrain.destruct_shadow()
        if self.wall:
            self.wall.destruct_shadow()
        if self.item:
            self.item.dest_me()
        for thing in self.door_control.values():
            if isinstance(thing, MudObject):
                thing.dest_me()
        for thing in self.hidden_objects:
            if thing and thing.multiple_hidden() == 0:
                thing.dest_me()
        self.destruct()

    def set_keep_room_loaded(self, flag: int):
        self.attrs["room_keep"] = flag

    def query_keep_room_loaded(self) -> bool:
        return self.attrs.get("room_keep", False)

    def clean_up(self, parent: int) -> bool:
        if parent:
            return False
        if self.query_keep_room_loaded():
            return False
        driver.call_out(self.real_clean, 30 + random.randint(0, 120))
        return True

    def real_clean(self) -> bool:
        for thing in self.inventory:
            if thing.attrs.get("transient", False):
                hospital = thing.attrs.get("hospital")
                thing.move(hospital if hospital else "/room/rubbish", "$N wander$s in.", "$N wander$s out.")
            if (thing.attrs.get("player", False) or
                (thing.attrs.get("unique", False) and self.last_visited > time.time() - 3600) or
                thing.attrs.get("slave", False) or
                thing.name == "corpse"):
                return False
        self.dest_me()
        return True

    def filter_inventory(self, item: MudObject, looker: MudObject) -> bool:
        return item and item.short(0) and (not looker or item.query_visible(looker))

    def find_inv_match(self, words: str, looker: MudObject) -> List[MudObject]:
        things = self.inventory.copy()
        if self.hidden_objects:
            things.extend(self.hidden_objects)
        if looker and looker.attrs.get("player", False):
            things = [t for t in things if self.filter_inventory(t, looker)]
        if self.item:
            things.append(self.item)
        return things

    def add_sign(self, sign_long: str, sign_read_mess: Union[str, List] = None, sign_short: str = None,
                 sign_name: Union[str, List[str]] = None, sign_language: str = "common") -> MudObject:
        sign = MudObject(f"sign_{self.oid}", "sign")
        sign_name = sign_name or "sign"
        if isinstance(sign_name, list):
            bits = sign_name[0].split()
            sign.set_name(bits[-1])
            sign.add_adjective(bits[:-1])
            sign.add_alias([s.split()[-1] for s in sign_name[1:]])
            sign.add_plural([self.pluralize(s.split()[-1]) for s in sign_name[1:]])
            sign.add_adjective([s.split()[:-1] for s in sign_name[1:]])
        else:
            bits = sign_name.split()
            sign.set_name(bits[-1])
            sign.add_adjective(bits[:-1])
        sign.set_long(sign_long)
        sign.set_read_mess(sign_read_mess, sign_language)
        sign.reset_get()
        if sign_short and sign_short != "":
            sign.set_short(sign_short)
            sign.set_main_plural(self.pluralize(sign_short))
            sign.move(self)
            sign.attrs["there"] = "here"
        else:
            self.hidden_objects.append(sign)
            adj = sign.query_adjectives()
            sign.set_short(f"{' '.join(adj)} {sign.name}" if adj else sign.name)
        return sign

    def tell_door(self, direc: str, message: str, thing: MudObject):
        door = self.door_control.get(direc)
        if isinstance(door, MudObject):
            door.tell_door(message, thing)

    def call_door(self, direc: str, func: str, *args) -> Optional[Union[int, str]]:
        door = self.door_control.get(direc)
        if isinstance(door, MudObject):
            return getattr(door, func)(*args)
        return None

    def query_door(self, dest: Union[str, MudObject], name: str = None) -> Optional[str]:
        if isinstance(dest, MudObject):
            dest = dest.oid
        if not isinstance(dest, str):
            return None
        key = f"{dest} {name}" if name else dest
        bing = self.door_control.get(key)
        direc = bing if isinstance(bing, str) else None
        if not direc:
            return None
        door = self.door_control.get(direc)
        if isinstance(door, MudObject):
            return direc
        door = MudObject(f"door_{direc}", "door")
        i = self.dest_other.index(direc)
        door.setup_door(direc, self, dest, self.dest_other[i + 1])
        self.hidden_objects.append(door)
        self.door_control[direc] = door
        return direc

    def stop_room_chats(self):
        if self.chatter:
            self.chatter.dest_me()

    def set_chat_min_max(self, min: int, max: int):
        if self.chatter:
            self.chatter.set_chat_min_max(min, max)

    def add_room_chats(self, new_chats: List[str]):
        if self.chatter:
            self.chatter.add_room_chats(new_chats)

    def remove_room_chats(self, dead_chats: List[str]):
        if self.chatter:
            self.chatter.remove_room_chats(dead_chats)

    def query_room_chats(self) -> Optional[List]:
        return self.chatter.query_room_chats() if self.chatter else None

    def setup_room_chat(self):
        if not self.chatter:
            self.chatter = MudObject(f"chatter_{self.oid}", "chatter")
        if self.is_day == -1:
            self.is_day = driver.weather_handler.query_day() > 0
        chats = (self.variablechats[self.is_day] if self.is_day else self.variablechats[ROOM_NIGHT_INDEX]) if self.variablechats else None
        if not chats:
            chats = self.variablechats[ROOM_DEFAULT_INDEX] if self.variablechats else None
        elif self.variablechats and self.variablechats[ROOM_DEFAULT_INDEX]:
            chats[2].extend(self.variablechats[ROOM_DEFAULT_INDEX][2])
        if chats:
            self.chatter.setup_chatter(self, chats)

    def room_chat(self, args: List, chatobj: MudObject = None):
        if not args or not isinstance(args[2], list):
            print("Error: second argument of room_chat args is not an array.")
            return
        if not self.chatter and chatobj:
            self.chatter = chatobj
        if not self.variablechats:
            self.variablechats = [None] * 3
        self.variablechats[ROOM_DEFAULT_INDEX] = args
        self.setup_room_chat()

    def set_situation_changer(self, changer: Union[str, MudObject] = None) -> MudObject:
        if isinstance(changer, str):
            self.sitchanger = MudObject(f"sitchanger_{self.oid}", changer)
        elif isinstance(changer, MudObject):
            self.sitchanger = changer
        else:
            self.sitchanger = MudObject(f"sitchanger_{self.oid}", "situation_changer")
        return self.sitchanger.set_room(self)

    def add_situation(self, label: Union[str, int], sit: dict):
        if not self.sitchanger:
            self.sitchanger = MudObject(f"sitchanger_{self.oid}", "situation_changer")
            self.sitchanger.set_room(self)
        self.sitchanger.add_situation(label, sit)

    def make_situation_seed(self, xval: int, yval: int):
        if self.sitchanger:
            self.sitchanger.set_seed(xval, yval)

    def start_situation(self, label: int, do_start_mess: int):
        if self.sitchanger:
            self.sitchanger.start_situation(label, do_start_mess)

    def end_situation(self, label: Union[str, int]):
        if self.sitchanger:
            self.sitchanger.end_situation(label)

    def change_situation(self, label: Union[str, int, List], duration: Union[int, List], words: Union[int, List] = None) -> Optional[int]:
        if self.sitchanger:
            return self.sitchanger.change_situation(label, duration, words, 0)
        return 0

    def automate_situation(self, label: Union[str, int, List], duration: Union[int, List], when: int = WHEN_ANY_TIME,
                           chance: int = 1000, category: str = None):
        if self.sitchanger:
            self.sitchanger.automate_situation(label, duration, when, chance, category)

    def shutdown_all_situations(self):
        if self.sitchanger:
            self.sitchanger.shutdown_all_situations()

    def shutdown_situation(self, call: int, label: Union[str, int, List]):
        if self.sitchanger:
            self.sitchanger.shutdown_situation(call, label)

    def query_not_replaceable(self) -> bool:
        return self.attrs.get("not_replaceable", False)

    def set_not_replaceable(self, replace: bool):
        self.attrs["not_replaceable"] = replace

    def stats(self) -> List[Tuple[str, Union[int, str]]]:
        stuff = []
        for i in range(0, len(self.dest_other), 2):
            stuff.append((self.dest_other[i], self.dest_other[i + 1][ROOM_DEST]))
        if self.co_ord:
            stuff.extend([("co-ord x", self.co_ord[0]), ("co-ord y", self.co_ord[1]), ("co-ord z", self.co_ord[2])])
        return (light.Light.stats(self) + property.Property.stats(self) + effects.Effects.stats(self) + stuff +
                [("short", self.short(0)), ("enchantment", self.query_enchant()),
                 ("background enchantment", self.background_enchant),
                 ("dynamic enchantment", self.dynamic_enchant),
                 ("enchantment time", self.enchant_time),
                 ("theft handler", self.theft_handler)])

    def set_day_long(self, str: str):
        if not self.variablelongs:
            self.variablelongs = [""] * 2
        self.variablelongs[ROOM_DAY_INDEX] = str
        if self.is_day == -1:
            self.is_day = driver.weather_handler.query_day() > 0
        if self.is_day == ROOM_DAY_INDEX:
            self.set_long(str)

    def query_day_long(self) -> str:
        if self.variablelongs and self.variablelongs[ROOM_DAY_INDEX]:
            return self.variablelongs[ROOM_DAY_INDEX]
        return self.query_long()

    def set_night_long(self, str: str):
        if not self.variablelongs:
            self.variablelongs = [""] * 2
        self.variablelongs[ROOM_NIGHT_INDEX] = str
        if self.is_day == -1:
            self.is_day = driver.weather_handler.query_day() > 0
        if self.is_day == ROOM_NIGHT_INDEX:
            self.set_long(str)

    def query_night_long(self) -> str:
        if self.variablelongs and self.variablelongs[ROOM_NIGHT_INDEX]:
            return self.variablelongs[ROOM_NIGHT_INDEX]
        return self.query_long()

    def return_long(self, desc: Union[str, List]) -> str:
        if not isinstance(desc, list):
            return desc
        ma = desc.index("long") if "long" in desc else -1
        return desc[ma + 1] if ma >= 0 else "Error: No long found."

    def add_day_item(self, shorts: Union[str, List[str]], desc: Union[str, List], no_plural: bool = False) -> bool:
        the_item = shorts[0] if isinstance(shorts, list) else shorts
        if not self.variableitems:
            self.variableitems = [[], []]
        self.variableitems[ROOM_DAY_INDEX].extend([the_item, self.return_long(desc)])
        if self.is_day == -1:
            self.is_day = driver.weather_handler.query_day() > 0
        if self.is_day == ROOM_DAY_INDEX:
            return self.add_item(shorts, desc, no_plural)
        return True

    def add_night_item(self, shorts: Union[str, List[str]], desc: Union[str, List], no_plural: bool = False) -> bool:
        the_item = shorts[0] if isinstance(shorts, list) else shorts
        if not self.variableitems:
            self.variableitems = [[], []]
        self.variableitems[ROOM_NIGHT_INDEX].extend([the_item, self.return_long(desc)])
        if self.is_day == -1:
            self.is_day = driver.weather_handler.query_day() > 0
        if self.is_day == ROOM_NIGHT_INDEX:
            return self.add_item(shorts, desc, no_plural)
        return True

    def room_day_chat(self, args: List):
        if not self.variablechats:
            self.variablechats = [None] * 3
        self.variablechats[ROOM_DAY_INDEX] = args
        if self.is_day == -1:
            self.is_day = driver.weather_handler.query_day() > 0
        if self.is_day == ROOM_DAY_INDEX:
            self.setup_room_chat()

    def room_night_chat(self, args: List):
        if not self.variablechats:
            self.variablechats = [None] * 3
        self.variablechats[ROOM_NIGHT_INDEX] = args
        if self.is_day == -1:
            self.is_day = driver.weather_handler.query_day() > 0
        if self.is_day == ROOM_NIGHT_INDEX:
            self.setup_room_chat()

    def query_help_file_directory(self) -> str:
        return "/doc/room_help"

    def query_room_night_chats(self) -> List:
        return self.variablechats[ROOM_NIGHT_INDEX] if self.variablechats else []

    def query_room_day_chats(self) -> List:
        return self.variablechats[ROOM_DAY_INDEX] if self.variablechats else []

    def query_room_default_chats(self) -> List:
        return self.variablechats[ROOM_DEFAULT_INDEX] if self.variablechats else []

    def query_day_items(self) -> List:
        return self.variableitems[ROOM_DAY_INDEX] if self.variableitems else []

    def query_night_items(self) -> List:
        return self.variableitems[ROOM_NIGHT_INDEX] if self.variableitems else []

async def init(driver_instance):
    driver = driver_instance

# /mnt/home2/mud/systems/room_handler.py
from typing import Dict, List, Tuple, Optional
from ..driver import driver, MudObject

# Constants based on Discworld room.h and room_handler.c
EXIT_TYPES = {
    "road": {"size": 10, "obvious": 1, "relative": 0},
    "path": {"size": 5, "obvious": 1, "relative": 0},
    "door": {"size": 3, "obvious": 1, "relative": 0, "door": True},
    "secret": {"size": 2, "obvious": 0, "relative": 0, "door": True},
    "corridor": {"size": 4, "obvious": 1, "relative": 0},
    "hidden": {"size": 2, "obvious": 0, "relative": 0}
}

DOOR_TYPES = {
    "door": {"default_state": "closed", "default_locked": False},
    "secret": {"default_state": "closed", "default_locked": False}
}

class RoomHandler:
    def __init__(self):
        self.exit_types: Dict[str, dict] = EXIT_TYPES
        self.door_types: Dict[str, dict] = DOOR_TYPES

    def query_exit_type(self, type: str, direc: str) -> List:
        """Returns exit configuration based on type."""
        config = self.exit_types.get(type.lower(), {"size": 0, "obvious": 0, "relative": 0})
        return [
            config.get("size", 0),  # ROOM_SIZE
            "",  # ROOM_EXIT (empty message)
            "",  # ROOM_MESS (empty move message)
            config.get("obvious", 0),  # ROOM_OBV
            config.get("relative", 0),  # ROOM_REL
            "",  # ROOM_FUNC (empty function)
            config.get("size", 0),  # ROOM_SIZE (repeated for consistency)
            0,  # ROOM_GRADE (no upgrade/downgrade by default)
            None,  # ROOM_DELTA (no delta by default)
            "",  # ROOM_LOOK (empty look)
            None  # ROOM_LOOK_FUNC (no look function)
        ]

    def query_door_type(self, type: str, direc: str, dest: str) -> Optional[dict]:
        """Returns door configuration based on type."""
        door_config = self.door_types.get(type.lower())
        if not door_config:
            return None
        return {
            "state": door_config["default_state"],
            "locked": door_config["default_locked"],
            "direction": direc,
            "destination": dest
        }

room_handler = RoomHandler()

async def init(driver_instance):
    driver = driver_instance

# /mnt/home2/mud/systems/situation_changer.py
from typing import Dict, List, Optional, Union, Callable
from ..driver import driver, MudObject
import asyncio
import random
import time

# Constants from situations.h
WHEN_ANY_TIME = 0xFFFFFF
WHEN_WEE_HOURS = 0x000001  # 1 AM
WHEN_EARLY_MORNING = 0x00001E  # 5-6 AM
WHEN_LATE_MORNING = 0x0001E0  # 8-10 AM
WHEN_AFTERNOON = 0x01E000  # 1-5 PM
WHEN_EVENING = 0x1E0000  # 6-9 PM
WHEN_LATENIGHT = 0xE00000  # 10 PM-12 AM

class Situation:
    def __init__(self):
        self.start_func: Optional[Callable] = None
        self.end_func: Optional[Callable] = None
        self.start_mess: str = ""
        self.end_mess: str = ""
        self.extra_look: str = ""
        self.chat_rate: List[int] = [120, 240]
        self.chats: List[str] = []
        self.add_items: List[Tuple] = []
        self.random_words: List[List[str]] = []

class SituationChanger(MudObject):
    def __init__(self, oid: str, name: str):
        super().__init__(oid, name)
        self.room: Optional[MudObject] = None
        self.situations: Dict[Union[str, int], Situation] = {}
        self.active_situations: Dict[Union[str, int], dict] = {}
        self.automated_situations: Dict[Union[str, int], dict] = {}
        self.seed: int = hash(str(oid))  # Default seed from file_name

    def set_room(self, room: MudObject) -> 'SituationChanger':
        """Associates the changer with a room."""
        self.room = room
        return self

    def set_seed(self, xval: int, yval: int):
        """Sets a custom random seed for situation timing."""
        self.seed = hash(f"{xval}{yval}")

    def add_situation(self, label: Union[str, int], sit: Situation):
        """Adds a situation to the changer."""
        self.situations[label] = sit

    def start_situation(self, label: Union[str, int], do_start_mess: int):
        """Starts a specified situation."""
        if label not in self.situations or label in self.active_situations:
            return
        sit = self.situations[label]
        if sit.start_func:
            sit.start_func(label, do_start_mess, self.room)
        if do_start_mess and sit.start_mess:
            self.room.tell_room(sit.start_mess)
        if sit.extra_look:
            self.room.add_extra_look(sit.extra_look)
        if sit.chats:
            self.room.add_room_chats(sit.chats)
            if sit.chat_rate:
                self.room.set_chat_min_max(sit.chat_rate[0], sit.chat_rate[1])
        for item, desc in sit.add_items:
            self.room.add_item(item, desc)
        self.active_situations[label] = {"start_time": time.time()}

    def end_situation(self, label: Union[str, int]):
        """Ends a specified situation."""
        if label not in self.active_situations:
            return
        sit = self.situations[label]
        if sit.end_func:
            sit.end_func(label, self.room)
        if sit.end_mess:
            self.room.tell_room(sit.end_mess)
        if sit.extra_look:
            self.room.remove_extra_look(sit.extra_look)
        if sit.chats:
            self.room.remove_room_chats(sit.chats)
        for item, _ in sit.add_items:
            self.room.remove_item(item)
        del self.active_situations[label]

    def change_situation(self, label: Union[str, int, List], duration: Union[int, List], words: Union[int, List] = None, start: bool = True) -> Optional[int]:
        """Changes a situation with a specified duration."""
        labels = label if isinstance(label, list) else [label]
        durations = duration if isinstance(duration, list) else [duration] * len(labels)
        total_duration = sum(d for d in durations if d > 0)
        if total_duration <= 0:
            return None

        handle = driver.call_out(self._handle_situation_change, total_duration, labels, durations, words)
        if start:
            self._start_next_situation(labels, durations, words, 0)
        return handle

    def _start_next_situation(self, labels: List, durations: List, words: Union[int, List], index: int):
        """Starts the next situation in a sequence."""
        if index >= len(labels):
            return
        label = labels[index]
        if label not in self.situations:
            return
        sit = self.situations[label]
        if words and isinstance(words, list):
            for i, word_set in enumerate(sit.random_words):
                if i < len(words) // 2:
                    replacement = words[i * 2 + 1]
                    sit.start_mess = sit.start_mess.replace(f"#{i+1}", replacement)
                    sit.end_mess = sit.end_mess.replace(f"#{i+1}", replacement)
                    sit.extra_look = sit.extra_look.replace(f"#{i+1}", replacement)
                    for j, (item, desc) in enumerate(sit.add_items):
                        sit.add_items[j] = (item, desc.replace(f"#{i+1}", replacement))
                    sit.chats = [c.replace(f"#{i+1}", replacement) for c in sit.chats]
        self.start_situation(label, 1)
        if index + 1 < len(labels) and durations[index] > 0:
            driver.call_out(self._handle_situation_change, durations[index], labels, durations, words, index + 1)

    def _handle_situation_change(self, labels: List, durations: List, words: Union[int, List], next_index: int = 0):
        """Handles the transition between situations."""
        current_label = labels[next_index - 1] if next_index > 0 else labels[0]
        self.end_situation(current_label)
        if next_index < len(labels):
            self._start_next_situation(labels, durations, words, next_index)

    def automate_situation(self, label: Union[str, int, List], duration: Union[int, List], when: int = WHEN_ANY_TIME,
                          chance: int = 1000, category: str = None):
        """Automates situation start/end based on time and chance."""
        labels = label if isinstance(label, list) else [label]
        durations = duration if isinstance(duration, list) else [duration] * len(labels)
        total_duration = sum(d for d in durations if d > 0)
        if total_duration <= 0:
            return
        self.automated_situations[label] = {
            "duration": durations,
            "when": when,
            "chance": chance,
            "category": category,
            "last_check": 0
        }
        driver.call_out(self._check_automated_situation, 60, label)

    def _check_automated_situation(self, label: Union[str, int, List]):
        """Checks if an automated situation should start."""
        if label not in self.automated_situations:
            return
        config = self.automated_situations[label]
        if time.time() - config["last_check"] < 60:
            driver.call_out(self._check_automated_situation, 60, label)
            return
        hour = time.localtime().tm_hour
        if (1 << hour) & config["when"] and random.randint(0, 1000) < config["chance"]:
            if not any(s["category"] == config["category"] for s in self.active_situations.values()):
                self.change_situation(label, config["duration"])
        config["last_check"] = time.time()
        driver.call_out(self._check_automated_situation, 60, label)

    def shutdown_all_situations(self):
        """Shuts down all active and automated situations."""
        for label in list(self.active_situations.keys()):
            self.end_situation(label)
        self.automated_situations.clear()

    def shutdown_situation(self, call: int, label: Union[str, int, List]):
        """Shuts down a specific situation based on call_out handle."""
        if call:
            driver.remove_call_out(call)
        if isinstance(label, list):
            for l in label:
                self.end_situation(l)
        else:
            self.end_situation(label)

    def check_situations(self):
        """Checks and updates active situations."""
        for label, data in list(self.active_situations.items()):
            if time.time() - data["start_time"] >= sum(d for d in self.situations[label].chat_rate if d > 0):
                self.end_situation(label)

    def dest_me(self):
        """Destroys the situation changer object."""
        self.shutdown_all_situations()
        self.room = None
        self.situations.clear()
        self.active_situations.clear()
        self.automated_situations.clear()
        self.destruct()

async def init(driver_instance):
    driver = driver_instance

# /mnt/home2/mud/systems/tactics.py
from typing import Dict, Optional
from ..driver import driver, Player, MudObject
import asyncio

class Tactics:
    def __init__(self):
        self.attitude: str = "neutral"  # insane, offensive, defensive, wimp
        self.response: str = "neutral"  # parry, dodge, both
        self.parry: str = "both"  # left, right, both
        self.attack: str = "both"  # left, right, both
        self.parry_unarmed: bool = False
        self.mercy: str = "ask"  # always, never, ask
        self.focus_zone: str = "none"  # upper body, lower body, specific zone
        self.ideal_distance: int = 0  # For USE_DISTANCE

class TacticsHandler:
    ATTITUDE_OPTIONS = ["insane", "offensive", "neutral", "defensive", "wimp"]
    RESPONSE_OPTIONS = ["parry", "dodge", "both", "neutral"]
    PARRY_OPTIONS = ["left", "right", "both"]
    ATTACK_OPTIONS = ["left", "right", "both"]
    MERCY_OPTIONS = ["always", "never", "ask"]
    FOCUS_OPTIONS = ["none", "upper body", "lower body", "head", "chest", "arms", "legs"]

    def __init__(self):
        self.tactics: Dict[str, Tactics] = {}

    async def init(self, driver_instance):
        self.driver = driver_instance
        for obj in self.driver.objects.values():
            if isinstance(obj, (Player, MudObject)) and hasattr(obj, "attrs"):
                self.init_tactics(obj)
                obj.add_action("tactics", self.tactics_command)

    def init_tactics(self, obj: MudObject):
        if "tactics" not in obj.attrs or not isinstance(obj.attrs["tactics"], Tactics):
            obj.attrs["tactics"] = Tactics()
            self.tactics[obj.oid] = obj.attrs["tactics"]
            self.driver.save_object(obj)

    async def tactics_command(self, obj: MudObject, caller: Player, arg: str) -> str:
        if not isinstance(caller, Player):
            return "Only players can use the tactics command."
        if caller.oid != obj.oid:
            return "You can only modify your own tactics."

        if not arg:
            tactics = obj.attrs["tactics"]
            return (f"Your current tactics are:\n"
                    f"Attitude: {tactics.attitude}\n"
                    f"Response: {tactics.response}\n"
                    f"Parry: {tactics.parry}\n"
                    f"Attack: {tactics.attack}\n"
                    f"Parry Unarmed: {tactics.parry_unarmed}\n"
                    f"Mercy: {tactics.mercy}\n"
                    f"Focus Zone: {tactics.focus_zone}\n"
                    f"Ideal Distance: {tactics.ideal_distance}")

        args = arg.lower().split()
        if len(args) != 2:
            return ("Syntax: tactics <setting> <value>\n"
                    "Settings: attitude, response, parry, attack, parry_unarmed, mercy, focus, distance\n"
                    "Use 'tactics help' for more information.")

        setting, value = args
        tactics = obj.attrs["tactics"]

        if setting == "help":
            return ("Tactics settings:\n"
                    f"attitude [{', '.join(self.ATTITUDE_OPTIONS)}]: How aggressively you fight.\n"
                    f"response [{', '.join(self.RESPONSE_OPTIONS)}]: How you defend.\n"
                    f"parry [{', '.join(self.PARRY_OPTIONS)}]: Which hand to parry with.\n"
                    f"attack [{', '.join(self.ATTACK_OPTIONS)}]: Which hand to attack with.\n"
                    "parry_unarmed [yes|no]: Whether to parry unarmed if no weapon.\n"
                    f"mercy [{', '.join(self.MERCY_OPTIONS)}]: How you handle surrender.\n"
                    f"focus [{'|'.join(self.FOCUS_OPTIONS)}]: Where to aim attacks.\n"
                    "distance [number]: Ideal combat distance (0 for none).")

        if setting == "attitude":
            if value not in self.ATTITUDE_OPTIONS:
                return f"Invalid attitude. Options: {', '.join(self.ATTITUDE_OPTIONS)}"
            tactics.attitude = value
        elif setting == "response":
            if value not in self.RESPONSE_OPTIONS:
                return f"Invalid response. Options: {', '.join(self.RESPONSE_OPTIONS)}"
            tactics.response = value
        elif setting == "parry":
            if value not in self.PARRY_OPTIONS:
                return f"Invalid parry. Options: {', '.join(self.PARRY_OPTIONS)}"
            tactics.parry = value
        elif setting == "attack":
            if value not in self.ATTACK_OPTIONS:
                return f"Invalid attack. Options: {', '.join(self.ATTACK_OPTIONS)}"
            tactics.attack = value
        elif setting == "parry_unarmed":
            if value not in ["yes", "no"]:
                return "Invalid parry_unarmed. Options: yes, no"
            tactics.parry_unarmed = (value == "yes")
        elif setting == "mercy":
            if value not in self.MERCY_OPTIONS:
                return f"Invalid mercy. Options: {', '.join(self.MERCY_OPTIONS)}"
            tactics.mercy = value
        elif setting == "focus":
            if value not in self.FOCUS_OPTIONS:
                return f"Invalid focus. Options: {'|'.join(self.FOCUS_OPTIONS)}"
            tactics.focus_zone = value
        elif setting == "distance":
            try:
                distance = int(value)
                if distance < 0:
                    return "Distance must be a non-negative number."
                tactics.ideal_distance = distance
            except ValueError:
                return "Distance must be a number."
        else:
            return "Unknown setting. Use 'tactics help' for options."

        self.tactics[obj.oid] = tactics
        self.driver.save_object(obj)
        return f"Tactics updated: {setting} set to {value}."

    def query_tactics(self, obj: MudObject) -> Tactics:
        self.init_tactics(obj)
        return self.tactics[obj.oid]

    def set_tactics(self, obj: MudObject, tactics: Tactics):
        self.tactics[obj.oid] = tactics
        obj.attrs["tactics"] = tactics
        self.driver.save_object(obj)

    def query_combat_attitude(self, obj: MudObject) -> str:
        return self.query_tactics(obj).attitude

    def set_combat_attitude(self, obj: MudObject, attitude: str):
        if attitude not in self.ATTITUDE_OPTIONS:
            return
        tactics = self.query_tactics(obj)
        tactics.attitude = attitude
        self.set_tactics(obj, tactics)

    def query_combat_response(self, obj: MudObject) -> str:
        return self.query_tactics(obj).response

    def set_combat_response(self, obj: MudObject, response: str):
        if response not in self.RESPONSE_OPTIONS:
            return
        tactics = self.query_tactics(obj)
        tactics.response = response
        self.set_tactics(obj, tactics)

    def query_combat_parry(self, obj: MudObject) -> str:
        return self.query_tactics(obj).parry

    def set_combat_parry(self, obj: MudObject, parry: str):
        if parry not in self.PARRY_OPTIONS:
            return
        tactics = self.query_tactics(obj)
        tactics.parry = parry
        self.set_tactics(obj, tactics)

    def query_combat_attack(self, obj: MudObject) -> str:
        return self.query_tactics(obj).attack

    def set_combat_attack(self, obj: MudObject, attack: str):
        if attack not in self.ATTACK_OPTIONS:
            return
        tactics = self.query_tactics(obj)
        tactics.attack = attack
        self.set_tactics(obj, tactics)

    def query_unarmed_parry(self, obj: MudObject) -> bool:
        return self.query_tactics(obj).parry_unarmed

    def set_unarmed_parry(self, obj: MudObject, parry_unarmed: bool):
        tactics = self.query_tactics(obj)
        tactics.parry_unarmed = parry_unarmed
        self.set_tactics(obj, tactics)

    def query_combat_mercy(self, obj: MudObject) -> str:
        return self.query_tactics(obj).mercy

    def set_combat_mercy(self, obj: MudObject, mercy: str):
        if mercy not in self.MERCY_OPTIONS:
            return
        tactics = self.query_tactics(obj)
        tactics.mercy = mercy
        self.set_tactics(obj, tactics)

    def query_combat_focus(self, obj: MudObject) -> str:
        return self.query_tactics(obj).focus_zone

    def set_combat_focus(self, obj: MudObject, focus: str):
        if focus not in self.FOCUS_OPTIONS:
            return
        tactics = self.query_tactics(obj)
        tactics.focus_zone = focus
        self.set_tactics(obj, tactics)

    def query_combat_distance(self, obj: MudObject) -> int:
        return self.query_tactics(obj).ideal_distance

    def set_combat_distance(self, obj: MudObject, distance: int):
        if distance < 0:
            return
        tactics = self.query_tactics(obj)
        tactics.ideal_distance = distance
        self.set_tactics(obj, tactics)

# Initialize tactics handler
tactics_handler = TacticsHandler()

async def init(driver_instance):
    await tactics_handler.init(driver_instance)

# /mnt/home2/mud/systems/taskmaster.py
from typing import Dict, Optional, Tuple, ClassVar
from ..driver import driver, Player, MudObject
import asyncio
import random
import math

class tasker_result:
    def __init__(self, result: int, degree: int, raw: int):
        self.result = result
        self.degree = degree
        self.raw = raw

class Taskmaster:
    # Task types from /include/tasks.h
    TM_CONTINUOUS = 1
    TM_FREE = 2
    TM_FIXED = 4
    TM_COMMAND = 8
    TM_RITUAL = 16
    TM_SPELL = 32
    TM_NONE = 64

    # Task outcomes
    AWARD = 1
    SUCCEED = 2
    FAIL = 3
    BARF = 0  # Error code

    # Degree constants (inferred from mudlib)
    TASKER_MARGINAL = 1
    TASKER_NORMAL = 2
    TASKER_EXCEPTIONAL = 3
    TASKER_CRITICAL = 4
    TASKER_MARGINAL_UPPER = 10
    TASKER_NORMAL_UPPER = 30

    # Skill categories and caps (from wiki and mudlib context)
    SKILL_CATEGORIES: ClassVar[Dict[str, int]] = {
        "fighting.combat.melee": 300,
        "fighting.combat.dodge": 300,
        "fighting.combat.parry": 300,
        "fighting.combat.unarmed": 300,
        "fighting.combat.tactics": 300,
        "other.perception": 200,
        "magic.spellcasting": 250  # Forgotten Realms adaptation
    }

    BASE = 100  # Base skill level for exponential decay (inferred)
    DECAY = 50  # Decay constant for upper limit (inferred)
    MODIFIER = 10  # Modifier for upper limit (inferred)
    E_MODIFIER = 10  # Modifier for attempt_task_e (inferred)

    def __init__(self):
        self.skills: Dict[str, Dict[str, int]] = {}  # {oid: {skill: level}}
        self.stats: Dict[str, Dict] = {}  # {skill: {level: {name: count}}}
        self.critical_chances: List[int] = []  # Precomputed critical chances
        self.last_save = 0
        self.control: Optional[Tuple[object, str]] = None
        self.last = 0
        self.skill = ""

    async def init(self, driver_instance):
        self.driver = driver_instance
        seteuid("Root")  # Simulate LPC seteuid for persistence
        self.precompute_critical_chances()
        for obj in self.driver.objects.values():
            if isinstance(obj, (Player, MudObject)) and hasattr(obj, "attrs"):
                self.init_skills(obj)
                obj.add_action("skills", self.skills_command)

    def precompute_critical_chances(self):
        a = 0.93260  # Constants from create() for y = a*e^(b*i)
        b = 0.06978
        self.critical_chances = [int(a * math.exp(b * (i + 1))) for i in range(100)]

    def init_skills(self, obj: MudObject):
        if obj.oid not in self.skills:
            self.skills[obj.oid] = {skill: 10 for skill in self.SKILL_CATEGORIES.keys()}
            obj.attrs["skills"] = self.skills[obj.oid]
            self.driver.save_object(obj)

    async def skills_command(self, obj: MudObject, caller: Player, arg: str) -> str:
        if not isinstance(caller, Player) or caller.oid != obj.oid:
            return "Only players can view their own skills."
        skills = self.skills.get(caller.oid, {})
        output = "Your skills:\n"
        for skill, level in skills.items():
            output += f"  {skill}: {level} (Cap: {self.SKILL_CATEGORIES[skill]})\n"
        return output

    def query_skill_bonus(self, obj: MudObject, skill: str) -> int:
        return self.skills.get(obj.oid, {}).get(skill, 1)

    def set_control(self, args: Tuple[object, str]):
        self.control = args

    def reset_control(self):
        self.control = None

    def query_stats(self, s_name: str) -> Dict:
        if self.skill != s_name:
            self.skill = s_name
            save_file = f"/save/tasks/{s_name}.o"
            if self.driver.file_exists(save_file):
                self.stats = self.driver.load_object(save_file) or {}
            else:
                self.stats = {}
        return self.stats.copy()

    def award_made(self, p_name: str, o_name: str, s_name: str, level: int):
        if isinstance(self.driver.objects.get(p_name), Player):
            await self.driver.call_other(p_name, "inform", f"{p_name} gains a level in {s_name} from {o_name} at level {level}", "skill")

    def compare_skills(self, offob: MudObject, offskill: str, defob: MudObject,
                      defskill: str, modifier: int, off_tm_type: int = TM_CONTINUOUS,
                      def_tm_type: int = TM_CONTINUOUS, degree: int = 0) -> Tuple[int, int] | tasker_result:
        if not offob or not defob or not offskill or not defskill:
            return self.BARF

        offbonus = self.query_skill_bonus(offob, offskill)
        defbonus = self.query_skill_bonus(defob, defskill)
        if not defbonus:
            defbonus = 1
        if not offbonus:
            offbonus = 1

        perc = (50 * offbonus * offbonus) / (offbonus * defbonus) if offbonus > defbonus else 100 - (50 * defbonus * defbonus) / (offbonus * defbonus)
        perc += modifier
        perc = max(1, min(99, perc))

        chance = random.randint(0, 99)
        success_margin = perc - chance
        if success_margin > 0:
            res = self.AWARD if off_tm_type & self.TM_CONTINUOUS and chance < perc * 0.1 else self.SUCCEED
            if degree:
                deg = self.TASKER_CRITICAL if self.is_critical(success_margin) else \
                      self.TASKER_MARGINAL if success_margin < self.TASKER_MARGINAL_UPPER else \
                      self.TASKER_NORMAL if success_margin < self.TASKER_NORMAL_UPPER else self.TASKER_EXCEPTIONAL
                return tasker_result(res, deg, success_margin)
            perform_result = self.perform_task(offob, offskill, defbonus - modifier, off_tm_type, 0)
            return self.OFFAWARD if perform_result == self.AWARD else self.OFFWIN
        else:
            res = self.AWARD if def_tm_type & self.TM_CONTINUOUS and chance > perc * 0.9 else self.SUCCEED
            if degree:
                deg = self.TASKER_CRITICAL if self.is_critical(success_margin) else \
                      self.TASKER_MARGINAL if -success_margin < self.TASKER_MARGINAL_UPPER else \
                      self.TASKER_NORMAL if -success_margin < self.TASKER_NORMAL_UPPER else self.TASKER_EXCEPTIONAL
                return tasker_result(res, deg, success_margin)
            perform_result = self.perform_task(defob, defskill, offbonus - modifier, def_tm_type, 0)
            return self.DEFAWARD if perform_result == self.AWARD else self.DEFWIN

    def perform_task(self, person: MudObject, skill: str, difficulty: int,
                    tm_type: int = TM_FREE, degree: int = 0) -> int | tasker_result:
        if not person or not skill:
            return self.BARF

        bonus = self.query_skill_bonus(person, skill)
        if bonus < difficulty:
            return self.FAIL if not degree else tasker_result(self.FAIL, self.TASKER_EXCEPTIONAL, -100)

        upper = 100
        extra = 0
        if tm_type == self.TM_FIXED:
            result = self.attempt_task(difficulty, bonus, 100, 0, degree)
        elif tm_type == self.TM_FREE:
            result = self.attempt_task(difficulty, bonus, 25, 0, degree)
        elif tm_type == self.TM_CONTINUOUS:
            result = self.attempt_task(difficulty, bonus, 50, 0, degree)
        elif tm_type == self.TM_COMMAND:
            if skill.startswith("covert"):
                result = self.attempt_task_e(difficulty, bonus, 60, 40, degree)
            else:
                result = self.attempt_task(difficulty, bonus, 100, 0, degree)
        elif tm_type == self.TM_RITUAL:
            result = self.attempt_task_e(difficulty, bonus, 50, 25, degree)
        elif tm_type == self.TM_SPELL:
            result = self.attempt_task_e(difficulty, bonus, 60, 40, degree)
        elif tm_type == self.TM_NONE:
            result = self.attempt_task_e(difficulty, bonus, 1, 0, degree)
            if isinstance(result, tasker_result) and result.result == self.AWARD:
                result.result = self.SUCCEED
            elif result == self.AWARD:
                result = self.SUCCEED
        else:
            upper = tm_type if tm_type else 100
            result = self.attempt_task(difficulty, bonus, upper, 0, degree)

        if isinstance(result, tasker_result) and result.result == self.AWARD or result == self.AWARD:
            if hasattr(person, "advancement_restriction") and person.advancement_restriction() or \
               not hasattr(person, "add_skill_level") or not person.add_skill_level(skill, 1, self):
                if isinstance(result, tasker_result):
                    result.result = self.SUCCEED
                else:
                    result = self.SUCCEED
        return result

    def attempt_task(self, difficulty: int, bonus: int, upper: int, extra: int, degree: int = 0) -> int | tasker_result:
        if bonus < difficulty:
            return self.FAIL if not degree else tasker_result(self.FAIL, self.TASKER_EXCEPTIONAL, -100)

        margin = 3 * math.sqrt(difficulty) if not extra else extra if isinstance(extra, int) else extra[0] + extra[1] * math.sqrt(difficulty)
        if not margin:
            return self.BARF

        if bonus > difficulty + margin:
            return self.SUCCEED if not degree else tasker_result(self.SUCCEED, self.TASKER_EXCEPTIONAL, 100)

        success_margin = ((100 * (bonus - difficulty)) // margin) - random.randint(0, 99)
        if success_margin <= 0:
            if degree:
                deg = self.TASKER_CRITICAL if self.is_critical(success_margin) else \
                      self.TASKER_MARGINAL if -success_margin < self.TASKER_MARGINAL_UPPER else \
                      self.TASKER_NORMAL if -success_margin < self.TASKER_NORMAL_UPPER else self.TASKER_EXCEPTIONAL
                return tasker_result(self.FAIL, deg, success_margin)
            return self.FAIL

        adjusted_upper = upper
        if self.control:
            adjusted_upper = int(person.stat_modify(upper, skill))  # Placeholder for stat_modify
            tmp = math.exp((self.query_skill_bonus(person, skill) - self.BASE) / self.DECAY)
            adjusted_upper = int(adjusted_upper / tmp) - self.MODIFIER
            adjusted_upper = max(0, adjusted_upper)

        if random.randint(0, 99) < (adjusted_upper * (difficulty + margin - bonus)) // margin:
            res = self.AWARD
        else:
            res = self.SUCCEED

        if degree:
            deg = self.TASKER_CRITICAL if self.is_critical(success_margin) else \
                  self.TASKER_MARGINAL if success_margin < self.TASKER_MARGINAL_UPPER else \
                  self.TASKER_NORMAL if success_margin < self.TASKER_NORMAL_UPPER else self.TASKER_EXCEPTIONAL
            return tasker_result(res, deg, success_margin)
        return res

    def attempt_task_e(self, difficulty: int, bonus: int, upper: int, half: int, degree: int = 0) -> int | tasker_result:
        if bonus < difficulty:
            return self.FAIL if not degree else tasker_result(self.FAIL, self.TASKER_EXCEPTIONAL, -100)

        half = 6 * math.sqrt(difficulty) if not half else half
        if not half:
            half = 1
        fail_chance = math.exp(-0.693 * (bonus - difficulty) / half)
        success_margin = (random.randint(0, 999) - (1000 * fail_chance)) // 10

        if success_margin < 0:
            if degree:
                deg = self.TASKER_CRITICAL if self.is_critical(success_margin) else \
                      self.TASKER_MARGINAL if -success_margin < self.TASKER_MARGINAL_UPPER else \
                      self.TASKER_NORMAL if -success_margin < self.TASKER_NORMAL_UPPER else self.TASKER_EXCEPTIONAL
                return tasker_result(self.FAIL, deg, success_margin)
            return self.FAIL

        adjusted_upper = upper
        if self.control:
            adjusted_upper = int(person.stat_modify(upper, skill))  # Placeholder
            tmp = math.exp((self.query_skill_bonus(person, skill) - self.BASE) / self.DECAY)
            adjusted_upper = int(adjusted_upper / tmp) - self.E_MODIFIER
            adjusted_upper = max(0, adjusted_upper)

        if random.randint(0, 999) < (adjusted_upper * fail_chance * 10) and bonus < difficulty + (half * 5):
            res = self.AWARD
        else:
            res = self.SUCCEED

        if degree:
            deg = self.TASKER_CRITICAL if self.is_critical(success_margin) else \
                  self.TASKER_MARGINAL if success_margin < self.TASKER_MARGINAL_UPPER else \
                  self.TASKER_NORMAL if success_margin < self.TASKER_NORMAL_UPPER else self.TASKER_EXCEPTIONAL
            return tasker_result(res, deg, success_margin)
        return res

    def is_critical(self, margin: int) -> int:
        if margin < 0:
            margin = -margin
        if margin > 100:
            margin = 100
        if margin == 0:
            return 0
        return 1 if random.randint(0, 9999) < self.critical_chances[margin - 1] else 0

# Initialize taskmaster handler
taskmaster = Taskmaster()

async def init(driver_instance):
    await taskmaster.init(driver_instance)

# /mnt/home2/mud/systems/terrain.py
from typing import Dict, List, Optional, Tuple
from ..driver import driver, MudObject, Player
import asyncio
import random
import time
import hashlib

# Terrain types and properties based on DWWiki and Discworld sources
TERRAIN_TYPES = {
    "moorland": {"move_speed": 0.7, "visibility": 70, "track_difficulty": 0.6, "weather_factor": 1.2, "extra_look": "The moor stretches endlessly, shrouded in mist."},
    "plains": {"move_speed": 1.0, "visibility": 100, "track_difficulty": 0.8, "weather_factor": 1.0, "extra_look": "Vast plains roll out before you."},
    "deciduous_forest": {"move_speed": 0.8, "visibility": 60, "track_difficulty": 0.4, "weather_factor": 1.1, "extra_look": "Tall trees cast dappled shadows."},
    "meadow": {"move_speed": 0.9, "visibility": 90, "track_difficulty": 0.7, "weather_factor": 1.0, "extra_look": "A serene meadow sways in the breeze."},
    "seashore": {"move_speed": 0.6, "visibility": 70, "track_difficulty": 0.5, "weather_factor": 1.3, "extra_look": "The sound of waves fills the air."},
    "sandy_beach": {"move_speed": 0.5, "visibility": 70, "track_difficulty": 0.6, "weather_factor": 1.4, "extra_look": "Soft sand shifts underfoot."},
    "underdark": {"move_speed": 0.7, "visibility": 50, "track_difficulty": 0.3, "weather_factor": 0.9, "extra_look": "The air is thick with ancient stone."}
}

class Terrain(MudObject):
    def __init__(self, oid: str, name: str):
        super().__init__(oid, name)
        self.room: Optional[MudObject] = None
        self.terrain_name: str = ""
        self.x_coord: int = -1
        self.y_coord: int = -1
        self.z_coord: int = -1
        self.zones: List[str] = []
        self.features: Dict[str, dict] = {}
        self.dist_features: Dict[str, dict] = {}
        self.extra_long: str = ""
        self.random_desc: str = ""
        self.variable_exits: List[str] = []
        self.default_exits: Dict[str, str] = {}
        self.terrain_handler: str = "/systems/terrain_handler"  # Default handler
        self.terrain_chatter: Optional[MudObject] = None
        self.weather_handler = driver.weather_handler
        self.track_handler = driver.terrain_track_handler
        self.last_weather_update: float = 0
        self.blocking_flag: int = 0
        self.installed_flag: int = 0
        self.terrain_char: str = "."

    def setup_shadow(self, room: MudObject, terrain_name: str):
        """Sets up the terrain shadow with coordinates and effects."""
        self.room = room
        self.terrain_name = terrain_name.lower()
        self.zones = self._determine_zones()
        self.apply_terrain_effects()
        self.set_terrain_coords(0, 0, 0)  # Default coords, overrideable
        driver.event_handler.add_listener("weather_change", self._on_weather_change)
        driver.call_out(self._update_weather_effects, 300)
        self.room.add_property("terrain_map", 1)
        self.setup_room_chat()

    def _determine_zones(self) -> List[str]:
        """Determines zones based on terrain type."""
        zone_map = {
            "moorland": ["wilderness", "open"],
            "plains": ["wilderness", "open"],
            "deciduous_forest": ["wilderness", "forest"],
            "meadow": ["wilderness", "open"],
            "seashore": ["wilderness", "coastal"],
            "sandy_beach": ["wilderness", "coastal"],
            "underdark": ["underdark", "subterranean"]
        }
        return zone_map.get(self.terrain_name, ["wilderness"])

    def set_terrain_coords(self, x: int, y: int, z: int):
        """Sets the terrain coordinates."""
        self.x_coord = x
        self.y_coord = y
        self.z_coord = z
        self.room.set_co_ord([x, y, z])

    def apply_terrain_effects(self):
        """Applies terrain-specific effects."""
        if not self.room or self.terrain_name not in TERRAIN_TYPES:
            return
        effects = TERRAIN_TYPES[self.terrain_name]
        self.room.attrs["move_speed"] = effects["move_speed"]
        self.room.attrs["visibility"] = effects["visibility"]
        self.room.attrs["track_difficulty"] = effects["track_difficulty"]
        if "extra_look" in effects:
            self.room.add_extra_look(effects["extra_look"])
        for zone in self.zones:
            self.room.add_zone(zone)

    def _update_weather_effects(self):
        """Updates terrain effects based on weather."""
        if not self.room or time.time() - self.last_weather_update < 300:
            driver.call_out(self._update_weather_effects, 300)
            return
        weather = self.weather_handler.query_weather(self.room.attrs.get("co_ord", [0, 0, 0]))
        factor = TERRAIN_TYPES.get(self.terrain_name, {}).get("weather_factor", 1.0)
        visibility_adjust = max(10, self.room.attrs["visibility"] * (weather["visibility"] / 100) * factor)
        self.room.attrs["visibility"] = min(visibility_adjust, 100)
        self.last_weather_update = time.time()
        driver.call_out(self._update_weather_effects, 300)

    def tell_zones(self, player: Player):
        """Tells the player about the terrain zones."""
        if not self.zones:
            return
        player.tell(f"This area is part of the {', '.join(self.zones)} zones.")

    def query_track_difficulty(self) -> float:
        """Returns the difficulty of tracking in this terrain."""
        return self.room.attrs.get("track_difficulty", 0.5)

    def add_track(self, tracker: Player, target: str):
        """Adds a track record."""
        if not self.track_handler:
            return
        difficulty = self.query_track_difficulty()
        self.track_handler.add_track(self.room, tracker.name, target, difficulty)

    def query_visibility(self) -> int:
        """Returns the room's visibility, adjusted by terrain."""
        return self.room.attrs.get("visibility", 100)

    def long(self, word: str = "", dark: int = 0) -> str:
        """Returns the long description with terrain map and features."""
        base_long = self.room.query_long(word, dark)
        if self.x_coord >= 0 and self.y_coord >= 0:
            map_template = driver.terrain_handler.query_player_map_template(self.x_coord, self.y_coord, self.z_coord, self.query_visibility(), 9)
            map_lines = [line + "   " for line in map_template.split("\n")]
            base_long = f"$COLUMN$12={''.join(map_lines)}$COLUMN${base_long}"
        return base_long + self.extra_look()

    def hash(self, mod: int) -> int:
        """Generates a deterministic hash based on coordinates."""
        coord_str = f"{self.x_coord}:{self.y_coord}:{self.z_coord}"
        val = int(hashlib.md5(coord_str.encode()).hexdigest(), 16) % mod
        return val if val >= 0 else -val

    def hash_time(self, mod: int, period: int) -> int:
        """Generates a time-based deterministic hash."""
        coord_str = f"{self.x_coord}:{self.y_coord}:{self.z_coord}:{time.time() // period}"
        val = int(hashlib.md5(coord_str.encode()).hexdigest(), 16) % mod
        return val if val >= 0 else -val

    def set_terrain_handler(self, handler: str):
        """Sets the terrain handler path."""
        self.terrain_handler = handler

    def query_terrain_handler(self) -> str:
        """Returns the terrain handler path."""
        return self.terrain_handler

    def query_terrain_coords(self) -> List[int]:
        """Returns the terrain coordinates."""
        return [self.x_coord, self.y_coord, self.z_coord]

    def setup_room_chat(self):
        """Sets up terrain-specific chats."""
        if self.room.do_outside_chats():
            self.room.terrain_chat([60, 120, ["#do_a_feature_chat", "#do_an_outside_chat"]])

    def terrain_chat(self, args: List, chatobj: Optional[MudObject] = None):
        """Handles terrain chat setup."""
        if not args or not isinstance(args[2], list):
            print("Error: second argument of room_chat args is not an array.")
            return
        if self.terrain_chatter:
            self.terrain_chatter.setup_chatter(self.room, args)
            return
        self.terrain_chatter = MudObject(f"chatter_{self.room.oid}", "chatter")
        self.terrain_chatter.setup_chatter(self.room, args)
        driver.log_file("CHATTER", f"{time.ctime()[4:19]}: {self.room.oid} cloned terrain chatter: {self.terrain_chatter}\n")

    def do_a_feature_chat(self):
        """Generates a feature-based chat."""
        if self.x_coord < 0 or self.y_coord < 0:
            return
        chats = []
        for title, feature in self.features.items():
            feature_chat = driver.terrain_handler.get_a_feature_chat(title, feature["index"], feature["direc"])
            if feature_chat:
                chats.append(feature_chat)
        if chats:
            self.room.tell_room(random.choice(chats) + "\n")

    def do_an_outside_chat(self):
        """Generates an outside-type chat."""
        chat = driver.terrain_handler.get_an_outside_chat(self.room.attrs.get("outside_types", ""))
        if chat and len(chat):
            self.room.tell_room(chat + "\n")

    def add_feature(self, title: str, direcs: dict, items: Union[str, List], sentence: int = 0):
        """Adds a visible feature to the room."""
        self.features[title] = {"direcs": direcs, "items": items, "sentence": sentence, "index": 0, "visible": 1}
        if items:
            self.room.add_item(items, lambda t=title: self.query_feature_item_desc(t))

    def add_distant_feature(self, title: str, bits: dict):
        """Adds a distant feature to the room."""
        self.dist_features[title] = bits

    def remove_feature(self, title: str):
        """Removes a feature from the room."""
        if title in self.features:
            feature = self.features[title]
            if feature["items"]:
                self.room.remove_item(feature["items"] if isinstance(feature["items"], str) else feature["items"][0])
            del self.features[title]

    def query_feature_item_desc(self, title: str) -> str:
        """Returns the item description for a feature."""
        if self.features.get(title, {}).get("visible", 0):
            return driver.terrain_handler.query_feature_item_desc(title)
        return ""

    def extra_look(self) -> str:
        """Returns extra look description with features."""
        result = self.extra_long
        descs = []
        visibility = self.query_visibility()
        for title, feature in self.features.items():
            tmp = driver.terrain_handler.query_feature_desc(title, feature["direcs"], visibility)
            if tmp:
                descs.extend(tmp)
        for title, feature in self.dist_features.items():
            tmp = driver.terrain_handler.query_distant_feature_desc(title, feature, visibility)
            if tmp:
                descs.extend(tmp)
        if descs:
            result += "  " + self.room.query_multiple_short(descs) + "."
        if self.random_desc:
            result += self.random_desc
        return result + "\n" if driver.terrain_handler.query_newline_mode() else result

    def set_extra_long(self, extra: str):
        """Sets the extra long description."""
        self.extra_long = extra

    def set_outside_types(self, types: str):
        """Sets the outside types for chats."""
        self.room.attrs["outside_types"] = types

    def add_random_desc(self, desc: str):
        """Adds a random description to the terrain."""
        self.random_desc += desc + " "

    def add_zone(self, zone: str):
        """Adds a zone to the room."""
        self.room.add_zone(zone)
        driver.terrain_handler.add_room_to_zone(self.room, zone)

    def query_dest_other(self, exit: str, data: List) -> List:
        """Modifies exit destinations based on terrain logic."""
        if not isinstance(exit, str) or not self.default_exits:
            return data
        if exit in self.default_exits:
            if driver.this_player() and driver.this_player().query_property("terrain_map_long_jump") and \
               f"{self.query_terrain_map_journey_exit()}{exit}" in self.variable_exits:
                exit = f"{self.query_terrain_map_journey_exit()}{exit}"
            else:
                data[ROOM_DEST] = self.default_exits[exit]
                return data
        if exit in self.variable_exits:
            bing = driver.terrain_handler.find_next_room_from(self.x_coord, self.y_coord, self.z_coord, exit[len(self.query_terrain_map_journey_exit()):])
            if bing:
                if data[ROOM_DEST] != bing[0]:
                    data[ROOM_DEST] = bing[0]
                    bits = []
                    cur_dir = None
                    num = 0
                    for dir in bing[1:]:
                        if dir == cur_dir:
                            num += 1
                        else:
                            if cur_dir:
                                bits.append(self.query_direction_distance_str(num, cur_dir))
                            cur_dir = dir
                            num = 1
                    if cur_dir:
                        bits.append(self.query_direction_distance_str(num, cur_dir))
                    if len(bits) > 1:
                        data[ROOM_MESS] = f"You arrive after having journeyed {', '.join(bits[:-1])}, and {bits[-1]}.\n"
                    else:
                        data[ROOM_MESS] = f"You arrive after having journeyed {bits[0]}.\n"
                    if not data[ROOM_ENTER] or not data[ROOM_ENTER][0]:
                        data[ROOM_ENTER] = f"$N journey$s in from {driver.room_handler.query_opposite_direction(bing[-1])}.\n"
                    if not data[ROOM_EXIT]:
                        data[ROOM_EXIT] = f"$N journey$s to the {bing[1]}.\n"
        return data

    def query_direction_distance_str(self, num: int, dir: str) -> str:
        """Returns a distance string for a direction."""
        dist = driver.terrain_handler.query_direction_distance(dir)
        dist_mess = "section"
        if 0 <= dist <= 2:
            dist_mess = "foot" if dist <= 1 else f"{dist} foot"
        elif 3 <= dist < (TERRAIN_MAP_ONE_MILE / 2):
            dist //= 3
            dist_mess = "yard" if dist <= 1 else f"{dist} yard"
        elif (TERRAIN_MAP_ONE_MILE / 2) <= dist < TERRAIN_MAP_ONE_MILE:
            dist //= (TERRAIN_MAP_ONE_MILE / 2)
            dist_mess = "mile" if dist <= 1 else f"{dist} miles"
        else:
            dist //= TERRAIN_MAP_ONE_MILE
            dist_mess = "mile" if dist <= 1 else f"{dist} miles"
        return f"{self.room.query_num(num)} {dist_mess}{'s' if num > 1 else ''} {dir}"

    def query_terrain_map_walk_exit(self) -> str:
        """Returns the prefix for walk exits."""
        return TERRAIN_MAP_WALK_EXIT

    def query_terrain_map_journey_exit(self) -> str:
        """Returns the prefix for journey exits."""
        return TERRAIN_MAP_JOURNEY_EXIT

    def add_variable_exit(self, exit: str):
        """Adds a variable exit."""
        self.variable_exits.append(exit)

    def add_default_exit(self, exit: str, location: str):
        """Adds a default exit."""
        self.default_exits[exit] = location

    def query_default_exits(self) -> Dict[str, str]:
        """Returns the default exits mapping."""
        return self.default_exits.copy()

    def set_terrain_map_block(self, blocking: int):
        """Sets the blocking flag."""
        self.blocking_flag = 1 if blocking else 0

    def query_terrain_map_block(self) -> int:
        """Returns the blocking flag."""
        return self.blocking_flag

    def set_terrain_map_character(self, terr: str):
        """Sets the terrain map character."""
        self.terrain_char = terr

    def query_terrain_map_character(self) -> str:
        """Returns the terrain map character."""
        return self.terrain_char

    def destruct_shadow(self):
        """Removes terrain effects and destroys the shadow."""
        if self.room:
            self.room.attrs.pop("move_speed", None)
            self.room.attrs.pop("visibility", None)
            self.room.attrs.pop("track_difficulty", None)
            if "extra_look" in TERRAIN_TYPES.get(self.terrain_name, {}):
                self.room.remove_extra_look(TERRAIN_TYPES[self.terrain_name]["extra_look"])
            for zone in self.zones:
                self.room.remove_zone(zone)
            driver.event_handler.remove_listener("weather_change", self._on_weather_change)
            if self.terrain_chatter:
                driver.log_file("CHATTER", f"{time.ctime()[4:19]}: {self.room.oid} dested terrain chatter: {self.terrain_chatter}\n")
                self.terrain_chatter.dest_me()
        self.room = None
        self.destruct()

    def _on_weather_change(self, event_data: Dict):
        """Handles weather change events."""
        if self.room and "coords" in event_data and event_data["coords"] == [self.x_coord, self.y_coord, self.z_coord]:
            self._update_weather_effects()

    async def init(self):
        """Initializes terrain-specific behavior."""
        if driver.this_player() and driver.this_player().query_creator():
            driver.this_player().tell(f"Coords: ({self.x_coord}, {self.y_coord}, {self.z_coord})\n")
            self.room.add_command("cremap", "", lambda: self.do_map())
            self.room.add_command("cremap", "all", lambda: self.do_map_terrain())
        if driver.this_player():
            self.add_effect("/std/effects/terrain_dont_unload", [])

    def do_map(self) -> int:
        """Displays a debug map for the creator."""
        map_data = driver.terrain_handler.query_debug_map(self.x_coord, self.y_coord, 13, self.x_coord, self.y_coord)
        driver.this_player().tell(map_data)
        self.room.add_succeeded_mess("")
        return 1

    def do_map_terrain(self) -> int:
        """Displays a terrain-wide debug map."""
        map_data = driver.terrain_handler.query_debug_map(20, 20, 40, self.x_coord, self.y_coord)
        driver.this_player().tell(map_data)
        self.room.add_succeeded_mess("")
        return 1

async def init(driver_instance):
    driver = driver_instance
    driver.terrain_handler = Terrain  # Simplified handler reference
    driver.terrain_track_handler = MudObject("terrain_track_handler", "terrain_track")  # Placeholder

# Constants from terrain_map.h (assumed values)
TERRAIN_MAP_ONE_MILE = 1000  # Placeholder value
TERRAIN_MAP_WALK_EXIT = "walk_"
TERRAIN_MAP_JOURNEY_EXIT = "journey_"
TERRAIN_MAP_GRID_SIZE = 100  # Placeholder value

# /mnt/home2/mud/systems/terrain_handler.py
from typing import Dict, List, Optional, Tuple
from ..driver import driver, MudObject
import os
import time

# Constants from terrain.h and map.h (assumed values)
RESTORE_PATH = "/data/terrain/"
BACKUP_TIME_OUT = 1000000
TERRAIN_MAP_ONE_MILE = 1000
TERRAIN_MAP_GRID_SIZE = 100
STD_ORDERS = [
    "north", [0, 1, 0], "northeast", [1, 1, 0], "east", [1, 0, 0],
    "southeast", [1, -1, 0], "south", [0, -1, 0], "southwest", [-1, -1, 0],
    "west", [-1, 0, 0], "northwest", [-1, 1, 0], "up", [0, 0, 1],
    "down", [0, 0, -1]
]
STD_TYPES = {
    "north": "path", "south": "path", "east": "path", "west": "path",
    "northeast": "hidden", "southwest": "hidden", "southeast": "hidden",
    "northwest": "hidden", "up": "stair", "down": "stair"
}

class TerrainHandler(MudObject):
    def __init__(self):
        super().__init__("terrain_handler", "terrain_handler")
        self.terrain_name: str = ""
        self.fixed_locations: Dict[str, List[int]] = {}
        self.floating_locations: List[Tuple[str, List[int], int]] = []
        self.cloned_locations: Dict[str, Dict[int, Dict[int, Dict[int, str]]]] = {}
        self.size_cache: Dict[str, int] = {}
        self.float_cache: Dict[str, Dict[int, Dict[int, Dict[int, str]]]] = {}
        self.in_map: int = 0

    def setup(self):
        """Initializes the terrain handler."""
        self.set_name("terrain map")
        self.set_short("terrain map")
        self.add_adjective("terrain")
        self.set_long("This is a large map showing diverse landscapes. Locations of interest are marked.\n")

    def member_cloned_locations(self, co_ords: List[int]) -> Optional[str]:
        """Checks for a cloned location at the given coordinates."""
        terrain_data = self.cloned_locations.get(self.terrain_name)
        if terrain_data and co_ords[0] in terrain_data and co_ords[1] in terrain_data[co_ords[0]] and co_ords[2] in terrain_data[co_ords[0]][co_ords[1]]:
            return terrain_data[co_ords[0]][co_ords[1]][co_ords[2]]
        return None

    def member_fixed_locations(self, co_ords: List[int]) -> Optional[str]:
        """Checks for a fixed location at the given coordinates."""
        for file, loc_co_ords in self.fixed_locations.items():
            if co_ords[0] == loc_co_ords[0] and co_ords[1] == loc_co_ords[1] and co_ords[2] == loc_co_ords[2]:
                return file
        return None

    def between(self, limit1: int, val: int, limit2: int) -> bool:
        """Checks if a value is between two limits."""
        if limit1 < limit2:
            return limit1 <= val <= limit2
        return limit2 <= val <= limit1

    def member_floating_locations(self, co_ords: List[int]) -> List[Tuple[str, int]]:
        """Checks for floating locations at the given coordinates."""
        right_locations = []
        for loc in self.floating_locations:
            data = loc[1]
            if len(data) == 6:  # Bounding box
                if (self.between(data[0], co_ords[0], data[3]) and
                    self.between(data[1], co_ords[1], data[4]) and
                    self.between(data[2], co_ords[2], data[5])):
                    right_locations.append((loc[0], loc[2]))
            elif len(data) == 3:  # Single point
                if co_ords == data:
                    right_locations.append((loc[0], loc[2]))
        return right_locations

    def top_floating_location(self, co_ords: List[int]) -> Optional[str]:
        """Returns the highest priority floating location."""
        locations = self.member_floating_locations(co_ords)
        if not locations:
            return None
        highest_level = -1
        highest_location = None
        for loc, level in locations:
            if level > highest_level:
                highest_level = level
                highest_location = loc
        return None if highest_location == "nothing" else highest_location

    def get_data_file(self, word: str) -> bool:
        """Loads terrain data file."""
        if self.terrain_name != word:
            file_path = f"{RESTORE_PATH}{word}.o"
            if os.path.exists(file_path):
                # Simulated unguarded restore (placeholder for security)
                self.terrain_name = word
                self.fixed_locations.clear()
                self.floating_locations.clear()
                # Assume restore_object logic here
            else:
                self.init_data(word)
                return False
        return True

    def init_data(self, word: str):
        """Initializes terrain data."""
        self.terrain_name = word
        self.fixed_locations = {}
        self.floating_locations = []

    def save_data_file(self, word: str):
        """Saves terrain data file with backup."""
        if os.path.exists(f"{RESTORE_PATH}{word}.o"):
            backup_path = f"{RESTORE_PATH}backups/{word}.{time.time()}"
            # Simulated unguarded rename
            if os.path.exists(backup_path):
                # Cleanup old backups (simplified)
                pass
        # Simulated unguarded save
        pass

    def query_cloned_locations(self, terrain: str) -> Dict:
        """Returns cloned locations for a terrain."""
        return self.cloned_locations.get(terrain, {})

    def query_fixed_locations(self, word: str) -> Dict[str, List[int]]:
        """Returns fixed locations."""
        self.get_data_file(word)
        return self.fixed_locations.copy()

    def query_floating_locations(self, word: str) -> List[Tuple[str, List[int], int]]:
        """Returns floating locations."""
        self.get_data_file(word)
        return self.floating_locations.copy()

    def query_co_ord(self, terrain: str, file: str) -> Optional[List[int]]:
        """Returns coordinates for a file."""
        self.get_data_file(terrain)
        return self.fixed_locations.get(file)

    def query_connection(self, terrain: str, co_ords: List[int], direc: str) -> Optional[str]:
        """Returns the connecting room for a direction."""
        if not self.float_cache.get(terrain) or co_ords[0] not in self.float_cache[terrain]:
            # Simulated file read (placeholder)
            pass
        data = self.float_cache.get(terrain, {}).get(co_ords[0], {}).get(co_ords[1], {}).get(co_ords[2], {})
        return data.get(direc)

    def query_connected(self, terrain: str, co_ords: List[int]) -> bool:
        """Checks if coordinates are connected."""
        return bool(self.query_connection(terrain, co_ords, STD_ORDERS[0]))

    def add_fixed_location(self, terrain: str, file: str, co_ords: List[int]) -> bool:
        """Adds a fixed location."""
        self.get_data_file(terrain)
        if file in self.fixed_locations or len(co_ords) != 3:
            return False
        self.fixed_locations[file] = co_ords
        self.save_data_file(terrain)
        return True

    def add_floating_location(self, terrain: str, file: str, co_ords: List[int], level: int) -> bool:
        """Adds a floating location."""
        self.get_data_file(terrain)
        if (len(co_ords) not in (3, 6) or any(loc in [f[0] for f in self.floating_locations] for loc in [file])):
            return False
        self.floating_locations.append((file, co_ords, level))
        self.save_data_file(terrain)
        return True

    def add_cloned_location(self, terrain: str, file: str, co_ords: List[int]):
        """Adds a cloned location."""
        if terrain not in self.cloned_locations:
            self.cloned_locations[terrain] = {co_ords[0]: {co_ords[1]: {co_ords[2]: file}}}
        else:
            loc_data = self.cloned_locations[terrain]
            loc_data.setdefault(co_ords[0], {}).setdefault(co_ords[1], {})[co_ords[2]] = file

    def modify_fixed_location(self, terrain: str, file: str, co_ords: List[int]) -> bool:
        """Modifies a fixed location."""
        self.get_data_file(terrain)
        if file not in self.fixed_locations or len(co_ords) != 3:
            return False
        self.fixed_locations[file] = co_ords
        self.save_data_file(terrain)
        return True

    def delete_cloned_location(self, terrain: str, file: str) -> bool:
        """Deletes a cloned location."""
        if terrain in self.cloned_locations and file in self.cloned_locations[terrain]:
            co_ords = self.cloned_locations[terrain][file]
            del self.cloned_locations[terrain][file]
            if co_ords[0] in self.cloned_locations[terrain] and co_ords[1] in self.cloned_locations[terrain][co_ords[0]]:
                del self.cloned_locations[terrain][co_ords[0]][co_ords[1]][co_ords[2]]
            return True
        return False

    def delete_fixed_location(self, terrain: str, file: str) -> bool:
        """Deletes a fixed location."""
        self.get_data_file(terrain)
        if file not in self.fixed_locations:
            return False
        del self.fixed_locations[file]
        self.save_data_file(terrain)
        return True

    def delete_floating_location(self, terrain: str, file: str, co_ords: List[int]) -> bool:
        """Deletes a floating location."""
        self.get_data_file(terrain)
        for i, (f, c, _) in enumerate(self.floating_locations):
            if f == file and c == co_ords:
                self.floating_locations.pop(i)
                self.save_data_file(terrain)
                return True
        return False

    def clear_cloned_locations(self, terrain: str):
        """Clears cloned locations cache."""
        if terrain in self.cloned_locations:
            del self.cloned_locations[terrain]

    def clear_connections(self, terrain: str):
        """Clears all connections for a terrain."""
        if terrain in self.float_cache:
            del self.float_cache[terrain]
        # Simulated file cleanup
        pass

    def get_room_size(self, file: str, level: int = 0) -> int:
        """Returns the room size with caching."""
        bname = file.replace(".c", "")
        if bname in self.size_cache:
            return self.size_cache[bname]
        obj = driver.find_object(file)
        if obj:
            self.size_cache[bname] = obj.query_room_size()
            return self.size_cache[bname]
        if not self.in_map:
            self.in_map = 1
            mapsize = driver.map_handler.query_room_size(bname) if driver.map_handler else [10]
            self.in_map = 0
            if mapsize:
                self.size_cache[bname] = mapsize[0]
                return mapsize[0]
        if os.path.exists(f"{bname}.c"):  # Simulated file parsing
            self.size_cache[bname] = 10  # Default size
            return 10
        return 10

    def add_exit(self, place: MudObject, direc: str, dest: str):
        """Adds an exit to the room."""
        type = place.query_exit_type(direc, dest) or STD_TYPES.get(direc, "path")
        if type != "none":
            place.add_exit(direc, dest, type)

    def calculate_exits(self, place: MudObject, co_ords: List[int]):
        """Calculates and adds exits based on terrain connections."""
        connected = self.query_connected(self.terrain_name, co_ords)
        exit_dirs = place.query_direc()
        for i in range(0, len(STD_ORDERS), 2):
            if STD_ORDERS[i] in exit_dirs:
                continue
            actual = self.query_connection(self.terrain_name, co_ords, STD_ORDERS[i])
            if actual:
                self.add_exit(place, STD_ORDERS[i], actual)
                continue
            if connected:
                continue
            new_co_ords = [c - place.query_room_size() * v for c, v in zip(co_ords, STD_ORDERS[i + 1])]
            for _ in range(100):
                new_co_ords = [c - 5 * v for c, v in zip(new_co_ords, STD_ORDERS[i + 1])]
                actual = (self.member_fixed_locations(new_co_ords) or
                          self.member_cloned_locations(new_co_ords) or
                          self.top_floating_location(new_co_ords))
                if actual:
                    delta = place.query_room_size() + self.get_room_size(actual)
                    if all(n + delta * v == c for n, v, c in zip(new_co_ords, STD_ORDERS[i + 1], co_ords)):
                        self.add_connection(self.terrain_name, co_ords, STD_ORDERS[i], actual)
                        self.add_exit(place, STD_ORDERS[i], actual)
                        break

    def find_location(self, terrain: str, co_ords: List[int]) -> Optional[MudObject]:
        """Finds or loads a room at the given coordinates."""
        if not self.get_data_file(terrain) or len(co_ords) != 3:
            return None
        dest_name = (self.member_fixed_locations(co_ords) or
                     self.member_cloned_locations(co_ords) or
                     self.top_floating_location(co_ords))
        if not dest_name:
            return None
        destination = driver.find_object(dest_name)
        if not destination and dest_name != "nothing":
            destination = driver.load_object(dest_name)
            if not destination and dest_name == self.top_floating_location(co_ords):
                destination = driver.clone_object(dest_name)
                destination.set_co_ord(co_ords)
                destination.set_terrain(terrain)
                self.calculate_exits(destination, co_ords)
                self.add_cloned_location(terrain, file_name(destination), co_ords)
        return destination

    def setup_location(self, place: MudObject, terrain: str):
        """Sets up a fixed location with exits."""
        if base_name(place) not in self.fixed_locations:
            return
        co_ords = self.fixed_locations[base_name(place)]
        place.set_co_ord(co_ords)
        self.calculate_exits(place, co_ords)

    def add_connection(self, terrain: str, co_ords: List[int], direc: str, file: str):
        """Adds a connection between rooms."""
        if not self.float_cache.get(terrain):
            self.float_cache[terrain] = {}
        if co_ords[0] not in self.float_cache[terrain]:
            self.float_cache[terrain][co_ords[0]] = {}
        if co_ords[1] not in self.float_cache[terrain][co_ords[0]]:
            self.float_cache[terrain][co_ords[0]][co_ords[1]] = {}
        self.float_cache[terrain][co_ords[0]][co_ords[1]][co_ords[2]] = {direc: file}

async def init(driver_instance):
    driver = driver_instance
    driver.terrain_handler = TerrainHandler()

# /mnt/home2/mud/systems/wall.py
from typing import List, Optional, Union, Tuple
from ..driver import driver, MudObject, Player

class Wall(MudObject):
    def __init__(self, oid: str, name: str):
        super().__init__(oid, name)
        self.belows: List[str] = []  # Paths to rooms below
        self.bottom: Optional[Union[str, List]] = None  # Destination when falling
        self.ghost_action: Optional[Union[str, List]] = None  # Action for ghosts
        self.moves: List = []  # Movement data (e.g., ["up", "mess", "dest"])
        self.no_drop: int = 0  # Flag to prevent dropping objects
        self.death_mess: Optional[str] = None  # Custom death message
        self.old_here: Optional[str] = None  # Original "here" property
        self.room: Optional[MudObject] = None

    def setup_shadow(self, thing: MudObject):
        """Sets up the wall shadow on the given room."""
        self.room = thing

    def destruct_shadow(self):
        """Destroys the wall shadow and cleans up."""
        if self.room:
            if self.old_here:
                self.room.add_property("here", self.old_here)
            else:
                self.room.remove_property("here")
        self.room = None
        self.destruct()

    def query_belows(self) -> List[str]:
        """Returns the list of rooms below."""
        return self.belows.copy()

    def query_bottom(self) -> Optional[Union[str, List]]:
        """Returns the bottom destination."""
        return self.bottom.copy() if isinstance(self.bottom, list) else self.bottom

    def query_ghost_action(self) -> Optional[Union[str, List]]:
        """Returns the ghost action."""
        return self.ghost_action.copy() if isinstance(self.ghost_action, list) else self.ghost_action

    def query_moves(self) -> List:
        """Returns the movement data."""
        return self.moves.copy()

    def query_no_drop(self) -> int:
        """Returns the no_drop flag."""
        return self.no_drop

    def query_death_mess(self) -> Optional[str]:
        """Returns the custom death message."""
        return self.death_mess

    def query_at_bottom(self) -> bool:
        """Checks if the wall is at the bottom."""
        return self.bottom is None

    def query_move(self, word: str) -> Optional[List]:
        """Queries movement data for a specific direction."""
        try:
            i = self.moves.index(word)
            return self.moves[i + 1:i + 4]
        except ValueError:
            return None

    def calc_co_ord(self):
        """Calculates coordinates based on connected rooms."""
        if not self.room:
            return
        self.room.calc_co_ord()
        co_ord = self.room.query_co_ord()
        if co_ord:
            return
        for word in ["down", "up"]:
            i = self.moves.index(word) if word in self.moves else -1
            if i == -1:
                continue
            other = self.moves[i + 2]
            other_obj = driver.find_object(other)
            if not other_obj:
                continue
            other_co_ord = other_obj.query_co_ord()
            if not other_co_ord:
                continue
            delta = self.room.query_room_size_array()[2] + other_obj.query_room_size_array()[2]
            co_ord = other_co_ord.copy()
            if word == "down":
                co_ord[2] += delta
            else:
                co_ord[2] -= delta
            self.room.set_co_ord(co_ord)
            return

    def set_wall(self, args: List):
        """Configures the wall with provided arguments."""
        for i in range(0, len(args), 2):
            key = args[i]
            value = args[i + 1]
            if key == "bottom":
                self.bottom = value
                if not self.no_drop:
                    self.old_here = self.room.query_property("here")
                    self.room.add_property("here", "falling past you")
            elif key == "below":
                self.belows.extend(value if isinstance(value, list) else [value])
            elif key == "move":
                j = self.moves.index(value[0]) if value[0] in self.moves else -1
                if j == -1:
                    self.moves.extend(value)
                else:
                    self.moves[j + 1:j + 4] = value[1:4]
            elif key in ["death mess", "death_mess"]:
                self.death_mess = value
            elif key in ["ghost action", "ghost_action"]:
                self.ghost_action = value
            elif key in ["no drop", "no_drop"]:
                self.no_drop = value
                if self.bottom:
                    if self.old_here:
                        self.room.add_property("here", self.old_here)
                    else:
                        self.room.remove_property("here")

    def event_enter(self, thing: MudObject, mess: str, from_room: MudObject):
        """Handles an object entering the room with the wall."""
        if not self.room:
            return
        self.room.event_enter(thing, mess, from_room)
        if not thing.query_living() and self.bottom and not self.no_drop:
            driver.call_out(lambda t=thing: self.fall_down(t), 0)

    def fall_down(self, thing: MudObject):
        """Handles an object falling down the wall."""
        if not thing or thing.environment() != self.room:
            return
        damage = self.room.query_room_size_array()[2]
        for below in self.belows:
            below_room = driver.find_object(below)
            if below_room:
                below_room.tell_room(f"{thing.a_short()} falls past you and is gone.\n")
                damage += 2 * below_room.query_room_size_array()[2]
        if isinstance(self.bottom, str):
            if thing.query_living():
                thing.move_with_look(self.bottom,
                                     f"{thing.a_short()} falls from above with a loud thump.",
                                     f"{thing.a_short()} drops downwards out of sight.")
            else:
                thing.move(self.bottom,
                           f"{thing.a_short()} falls from above with a loud thump.",
                           f"{thing.a_short()} drops downwards out of sight.")
            return
        word = self.bottom[0]
        damage += driver.find_object(word).query_room_size_array()[2]
        if len(self.bottom) > 1 and isinstance(self.bottom[1], str):
            if thing.query_living():
                thing.move_with_look(word,
                                     getattr(driver.find_object(word), self.bottom[1])(thing, self.room),
                                     f"{thing.a_short()} drops downwards out of sight.")
            else:
                thing.move(word,
                           getattr(driver.find_object(word), self.bottom[1])(thing, self.room),
                           f"{thing.a_short()} drops downwards out of sight.")
        else:
            if thing.query_living():
                thing.move_with_look(word,
                                     f"{thing.a_short()} falls from above with a loud crunch.",
                                     f"{thing.a_short()} drops downwards out of sight.")
                damage *= self.bottom[1] * thing.query_complete_weight()
                damage //= 10000
                damage -= thing.query_ac("blunt", damage)
                if damage > 0:
                    if damage > thing.query_hp():
                        thing.tell(self.death_mess or "You hit the ground with a sickening crunch.\n")
                        thing.attack_by(self.room)
                        thing.adjust_hp(-damage, self.room)
                    else:
                        thing.adjust_hp(-damage, self.room)
                        thing.tell("Ouch, that hurt!\n")
            else:
                thing.move(word,
                           f"{thing.a_short()} falls from above with a loud thump.",
                           f"{thing.a_short()} drops downwards out of sight.")

async def init(driver_instance):
    driver = driver_instance

# /mnt/home2/mud/systems/weapon_logic.py
from typing import Dict, Optional, List
from ..driver import driver, Player, MudObject
import asyncio
import random
import math

class Weapon:
    def __init__(self, oid: str, name: str, damage: int, weight: int, length: int, damage_type: str, condition: int = 100):
        self.oid = oid
        self.name = name
        self.attrs: Dict = {
            "damage": damage,  # Base damage (e.g., 25 per category jump from "extremely low")
            "weight": weight,  # In pounds, affects AP cost
            "length": length,  # In units, affects distance combat
            "damage_type": damage_type,  # slashing, piercing, bludgeoning, magic, blunt
            "condition": condition,  # 0-100, degrades with use
            "enchantment": 0,  # Bonus damage from magic (Forgotten Realms)
            "is_weapon": True,
            "is_shield": False,
            "category": self.determine_category(damage)  # e.g., "extremely low" = 1
        }

    def determine_category(self, damage: int) -> str:
        categories = ["extremely low", "very low", "rather low", "low", "fair", "moderate", "high", "very high", "extremely high"]
        index = min(max(0, (damage - 1) // 25), len(categories) - 1)
        return categories[index]

    def query_damage(self) -> int:
        base_damage = self.attrs["damage"]
        enchantment_bonus = self.attrs["enchantment"]
        condition_factor = max(0, min(1, self.attrs["condition"] / 100))
        return int((base_damage + enchantment_bonus) * condition_factor)

    def query_weight(self) -> int:
        return self.attrs["weight"]

    def query_length(self) -> int:
        return self.attrs["length"]

    def query_damage_type(self) -> str:
        return self.attrs["damage_type"]

    def query_condition(self) -> int:
        return self.attrs["condition"]

    def adjust_condition(self, damage_dealt: int) -> bool:
        if self.attrs["condition"] <= 0:
            return False
        degradation = random.randint(1, max(1, damage_dealt // 10))
        self.attrs["condition"] = max(0, self.attrs["condition"] - degradation)
        self.driver.save_object(self)
        return self.attrs["condition"] > 0

    def apply_enchantment(self, bonus: int) -> bool:
        if bonus < 0 or self.attrs["condition"] <= 0:
            return False
        self.attrs["enchantment"] = max(0, self.attrs["enchantment"] + bonus)
        self.driver.save_object(self)
        return True

    def query_ap_cost(self, wielder: MudObject) -> int:
        weight = self.attrs["weight"]
        melee_bonus = wielder.attrs.get("skills", {}).get("fighting.combat.melee", 10) + \
                      wielder.attrs.get("skills", {}).get("fighting.combat.tactics", 10)
        base_ap = 4  # Base AP per round
        if weight > 17:  # Max weight for 4 AP per Pokey’s data
            return base_ap + int(math.sqrt(weight - 17))
        return base_ap - min(2, melee_bonus // 25)  # Reduction with skill

    def apply_focus_modifier(self, focus_zone: str) -> float:
        modifiers = {
            "none": 1.0,
            "upper body": 1.0,
            "lower body": 1.0,
            "head": 1.2,  # 20% extra per Pokey’s data
            "neck": 1.2,
            "chest": 1.1,
            "arms": 1.0,
            "legs": 1.0
        }
        return modifiers.get(focus_zone, 1.0)

class WeaponLogic:
    def __init__(self):
        self.weapons: Dict[str, Weapon] = {}

    async def init(self, driver_instance):
        self.driver = driver_instance
        for obj in self.driver.objects.values():
            if hasattr(obj, "attrs") and obj.attrs.get("is_weapon", False):
                self.weapons[obj.oid] = Weapon(obj.oid, obj.name, obj.attrs.get("damage", 10),
                                              obj.attrs.get("weight", 5), obj.attrs.get("length", 5),
                                              obj.attrs.get("damage_type", "blunt"), obj.attrs.get("condition", 100))
                obj.add_action("judge", self.judge_weapon)

    async def judge_weapon(self, obj: MudObject, caller: Player, arg: str) -> str:
        if not isinstance(caller, Player) or caller.oid != obj.oid:
            return "You can only judge your own weapon."
        if obj.oid not in self.weapons:
            return "This is not a valid weapon."
        weapon = self.weapons[obj.oid]
        category = weapon.attrs["category"]
        damage = weapon.query_damage()
        return (f"You judge {obj.name} as dealing {category} damage ({damage} points), "
                f"weighing {weapon.query_weight()} lbs, with a length of {weapon.query_length()} units, "
                f"type {weapon.query_damage_type()}, and condition {weapon.query_condition()}%.")

    def query_weapon(self, obj: MudObject) -> Optional[Weapon]:
        return self.weapons.get(obj.oid)

    def register_weapon(self, obj: MudObject, name: str, damage: int, weight: int, length: int,
                       damage_type: str, condition: int = 100) -> Weapon:
        if obj.oid not in self.weapons:
            weapon = Weapon(obj.oid, name, damage, weight, length, damage_type, condition)
            self.weapons[obj.oid] = weapon
            obj.attrs.update(weapon.attrs)
            self.driver.save_object(obj)
        return self.weapons[obj.oid]

    def calculate_damage(self, weapon: Weapon, wielder: MudObject, focus_zone: str) -> int:
        base_damage = weapon.query_damage()
        focus_modifier = weapon.apply_focus_modifier(focus_zone)
        skill_bonus = wielder.attrs.get("skills", {}).get("fighting.combat.melee", 10) // 10
        return int(base_damage * focus_modifier * (1 + skill_bonus / 100))

    def degrade_weapon(self, weapon: Weapon, damage_dealt: int, armor_stopped: int) -> bool:
        effective_damage = max(0, damage_dealt - armor_stopped)
        return weapon.adjust_condition(effective_damage)

# Initialize weapon logic handler
weapon_logic = WeaponLogic()

async def init(driver_instance):
    await weapon_logic.init(driver_instance)

# /mnt/home2/mud/systems/weather.py
from typing import Dict, List, Optional, Tuple
from ..driver import driver, MudObject, Player
import math
import random
import time
import os

# Constants adapted from Forgotten Realms and Discworld MUD mechanics
FILE_NAME = "/save/fr_weather"
UPDATE_SPEED = 300  # 5 minutes
CYCLE_SPEED = 3600  # 1 hour
DAYS_PER_YEAR = 365  # Forgotten Realms year (Calendar of Harptos)
SECONDS_PER_DAY = 86400
MINUTES_PER_HOUR = 60
SECONDS_PER_MINUTE = 60
DEFAULT_CLIMATE = "Temperate"  # Default for Faerûn (e.g., Sword Coast)
CLIMATES = ["Tropical", "Arid", "Temperate", "Continental", "Polar", "Highland"]
NOTIFY_TEMPERATURE = 1
NOTIFY_CLOUD = 2
NOTIFY_RAIN = 4
NOTIFY_DAY = 8
TEMP, CLOUD, WINDSP = 0, 1, 2
WEATHER_NO_RAIN_TYPE, WEATHER_SNOW_TYPE, WEATHER_SLEET_TYPE, WEATHER_RAIN_TYPE = 0, 1, 2, 3

class WeatherHandler(MudObject):
    def __init__(self, oid: str = "weather_handler", name: str = "weather_handler"):
        super().__init__(oid, name)
        self._pattern: Dict[str, List[int]] = {}
        self._current: Dict[str, List[int]] = {}
        self._variance: List[int] = [10, 75, 20]  # Temp, cloud, wind variance
        self._rooms: Dict[MudObject, int] = {}
        self._lastupdate: int = 0
        self._day: int = 0
        self._sunrise: int = 0
        self._sunset: int = 0
        self._toy: int = 0  # Time of year
        self.mooncycle: int = 0  # Selûne’s phases
        self.moonupdate: int = 0

    def setup(self):
        """Initializes the weather handler for Forgotten Realms."""
        self.set_name("weather controller")
        self.set_short("weather controller")
        self.set_long("A mystical device attuned to the weather patterns of Faerûn.\n")
        if os.path.exists(FILE_NAME):
            self.restore_object(FILE_NAME)  # Placeholder for file restore
        for climate in CLIMATES:
            self._pattern.setdefault(climate, [0, 0, 0])
            self._current.setdefault(climate, [0, 0, 0])
        driver.call_out(self.update_weather, UPDATE_SPEED)
        self.set_day()
        self.update_pattern()

    def weather_notify(self, room: MudObject, notifications: int) -> bool:
        """Adds a room to the notification list."""
        if notifications < 0 or notifications > (NOTIFY_TEMPERATURE | NOTIFY_CLOUD | NOTIFY_RAIN | NOTIFY_DAY):
            return False
        self._rooms[room] = notifications
        return True

    def day_number(self) -> int:
        """Returns the day of the Faerûnian year (1-365)."""
        return (int(time.time()) % (DAYS_PER_YEAR * SECONDS_PER_DAY)) // SECONDS_PER_DAY + 1

    def minute_number(self) -> int:
        """Returns the minute of the day (0-1439)."""
        return (int(time.time()) % SECONDS_PER_DAY) // SECONDS_PER_MINUTE

    def query_moon_string(self, env: MudObject) -> str:
        """Returns Selûne’s visibility string."""
        if self.mooncycle > 10:
            return "It is night and Selûne is not visible.\n"
        cloud = self.cloud_index(env)
        if cloud > 70:
            return f"It is night and Selûne’s {self.query_moon_phase()} is shrouded by clouds.\n"
        prefix = "The waters" if env.query_water() else "The land"
        return f"{prefix} glow with the silver light of Selûne’s {self.query_moon_phase()}.\n"

    def query_moon_state(self) -> int:
        """Returns Selûne’s state (0-6)."""
        if self.mooncycle < 6:
            return self.mooncycle + 1
        if self.mooncycle < 11:
            return 11 - self.mooncycle
        return 0

    def query_moon_phase(self) -> str:
        """Returns Selûne’s phase."""
        return ["crescent", "quarter", "half", "three quarter", "gibbous", "full",
                "gibbous", "three quarter", "half", "quarter", "crescent", "", "", ""][self.mooncycle]

    def query_stars(self, env: MudObject) -> int:
        """Returns the percentage of visible stars."""
        if self.query_day(env) or self.cloud_index(env) > 70:
            return 0
        cloud = self.cloud_index(env)
        if cloud == 0:
            return 100
        elif 1 <= cloud <= 39:
            return 80
        elif 40 <= cloud <= 59:
            return 40
        elif 60 <= cloud <= 69:
            return 20
        return 10

    def query_star_string(self, env: MudObject) -> str:
        """Returns a description of visible stars."""
        if self.query_day(env):
            return "The sun’s light drowns out the stars.\n"
        stars = self.query_stars(env)
        if 1 <= stars <= 20:
            return "A few brave stars pierce the night sky.\n"
        elif 21 <= stars <= 40:
            return "A scattering of stars dots the heavens.\n"
        elif 41 <= stars <= 60:
            return "Many stars glimmer above Faerûn.\n"
        elif 61 <= stars <= 80:
            return "A host of stars shines brightly.\n"
        elif 81 <= stars <= 100:
            return "The sky blazes with countless stars.\n"
        return "No stars pierce the darkened sky.\n"

    def query_season(self) -> str:
        """Returns the Faerûnian season."""
        day = self.day_number()
        if 335 <= day <= 365 or 1 <= day <= 59:  # Hammer to Alturiak
            return "winter"
        elif 60 <= day <= 150:  # Ches to Tarsakh
            return "spring"
        elif 151 <= day <= 243:  # Mirtul to Eleasis
            return "summer"
        return "autumn"  # Eleint to Nightal

    def query_tod(self) -> str:
        """Returns the time of day."""
        minute = self.minute_number()
        if minute < self._sunrise or minute > self._sunset:
            return "night"
        if 0 <= minute <= 700:
            return "morning"
        elif 701 <= minute <= 740:
            return "midday"
        elif 741 <= minute <= 1080:
            return "afternoon"
        return "evening"

    def query_day(self, env: MudObject) -> int:
        """Returns the day state (0-10)."""
        return self._day

    def query_darkness(self, env: MudObject) -> int:
        """Returns the light percentage."""
        result = 10
        day = self.query_day(env)
        if day == 10:
            return 100
        if self.mooncycle <= 10:
            result += (self.mooncycle * 10 if self.mooncycle < 6 else (5 - (self.mooncycle % 6)) * 10)
        cloud = self.cloud_index(env)
        if cloud > 0:
            result -= cloud // 15
        if result < 0:
            result = 0
        if day > 0:
            result += (100 - result) // (10 - day)
        return result

    def query_visibility(self, env: MudObject) -> int:
        """Returns the visibility percentage."""
        result = 100
        temp = self.temperature_index(env)
        rain = self.rain_index(env)
        rt = self.query_rain_type(temp, rain)
        if rt == WEATHER_SNOW_TYPE:
            rain += 50
        elif rt == WEATHER_SLEET_TYPE:
            rain += 20
        if rain > 0:
            result = 0 if rain > 100 else (result * (100 - rain)) // 100
        return result

    def calc_actual(self, env: MudObject, type: int) -> int:
        """Calculates the actual weather value."""
        climate = env.query_climate() or DEFAULT_CLIMATE
        clim = env.query_property("climate") or [0, 0, 0]
        return self._current[climate][type] + clim[type]

    def temperature_index(self, env: MudObject) -> int:
        """Calculates the temperature with diurnal effects."""
        temp = self.calc_actual(env, TEMP)
        climate = env.query_climate() or DEFAULT_CLIMATE
        tod = 10 - self.query_day(env)
        if tod:
            diurnal = {
                "Tropical": 10, "Arid": lambda t: 15 + (t // 2),
                "Temperate": 15, "Continental": 15, "Polar": 20, "Highland": 20
            }.get(climate, 15)
            if callable(diurnal):
                diurnal = diurnal(self._pattern[climate][0])
            temp -= (diurnal * tod) // 10
        j = int(math.sqrt(max(0, self._current[climate][CLOUD])))
        if temp < 10 and tod == 10:
            temp += j
        elif temp > 30 and not tod:
            temp -= j
        temp -= int(math.sqrt(self._current[climate][WINDSP]))
        return temp

    def cloud_index(self, env: MudObject) -> int:
        """Calculates the cloud cover."""
        return max(0, self.calc_actual(env, CLOUD))

    def rain_index(self, env: MudObject) -> int:
        """Calculates the rain intensity."""
        rain = self.calc_actual(env, CLOUD) - (self.calc_actual(env, TEMP) // 2) - 100
        return max(0, rain)

    def temp_string(self, temp: int) -> str:
        """Returns a temperature description."""
        if temp >= 51:
            return "blazing beyond mortal endurance"
        elif 46 <= temp <= 50:
            return "scorching like the deserts of Calimshan"
        elif 41 <= temp <= 45:
            return "sweltering as in Chult"
        elif 36 <= temp <= 40:
            return "very hot"
        elif 31 <= temp <= 35:
            return "hot"
        elif 26 <= temp <= 30:
            return "warm as a summer day"
        elif 23 <= temp <= 25:
            return "pleasantly warm"
        elif 20 <= temp <= 22:
            return "mild"
        elif 16 <= temp <= 19:
            return "cool as an autumn breeze"
        elif 13 <= temp <= 15:
            return "chilly"
        elif 10 <= temp <= 12:
            return "brisk"
        elif 7 <= temp <= 9:
            return "cold"
        elif 4 <= temp <= 6:
            return "very cold"
        elif 1 <= temp <= 3:
            return "bitterly cold"
        elif -3 <= temp <= 0:
            return "frigid"
        elif -10 <= temp <= -4:
            return "freezing as in Icewind Dale"
        elif -20 <= temp <= -11:
            return "numbing"
        elif -30 <= temp <= -21:
            return "deadly cold"
        return "glacial like the Reghed wastes"

    def precipitation_string(self, rain: int, rt: int, wind: int) -> str:
        """Returns a precipitation intensity description."""
        if -1000 <= rain <= 20:
            return "lightly"
        elif 21 <= rain <= 40:
            return "steadily" if wind < 20 else "hard"
        elif 41 <= rain <= 60:
            return "heavily"
        return "torrentially" if rt == WEATHER_RAIN_TYPE else "very heavily"

    def rain_string(self, env: MudObject) -> str:
        """Returns the rain description."""
        temp = self.temperature_index(env)
        rain = self.rain_index(env)
        rt = self.query_rain_type(temp, rain)
        wind = self.calc_actual(env, WINDSP)
        return f"Rain falls {self.precipitation_string(rain, rt, wind)} across the land" if rt == WEATHER_RAIN_TYPE else "The skies are dry"

    def snow_string(self, env: MudObject) -> str:
        """Returns the snow description."""
        temp = self.temperature_index(env)
        rain = self.rain_index(env)
        rt = self.query_rain_type(temp, rain)
        wind = self.calc_actual(env, WINDSP)
        return f"Snow falls {self.precipitation_string(rain, rt, wind)} from the heavens" if rt == WEATHER_SNOW_TYPE else "No snow blankets the ground"

    def sleet_string(self, env: MudObject) -> str:
        """Returns the sleet description."""
        temp = self.temperature_index(env)
        rain = self.rain_index(env)
        rt = self.query_rain_type(temp, rain)
        wind = self.calc_actual(env, WINDSP)
        return f"Sleet pelts the land {self.precipitation_string(rain, rt, wind)}" if rt == WEATHER_SLEET_TYPE else "The air is free of sleet"

    def cloud_string(self, env: MudObject) -> str:
        """Returns the cloud description."""
        cloud = self.cloud_index(env)
        if -1000 <= cloud <= 5:
            return "a clear Faerûnian sky"
        elif 6 <= cloud <= 10:
            return " wisps of cirrus clouds"
        elif 11 <= cloud <= 25:
            return "scattered clouds like those over Waterdeep"
        elif 26 <= cloud <= 40:
            return "light cloud cover"
        elif 41 <= cloud <= 60:
            return "a canopy of clouds"
        elif 61 <= cloud <= 80:
            return "thick clouds"
        elif 81 <= cloud <= 110:
            return "dense, brooding clouds"
        elif 111 <= cloud <= 130:
            return "ominous gray cover"
        elif 131 <= cloud <= 160:
            return "dark storm clouds"
        return "tempestuous storm clouds"

    def weather_string(self, env: MudObject, obscured: Optional[str] = None) -> str:
        """Returns the full weather description for Forgotten Realms."""
        temp = self.temperature_index(env)
        cloud = self.cloud_index(env)
        wind = self.calc_actual(env, WINDSP)
        rain = self.rain_index(env)
        if hasattr(env, "room_weather"):
            temp, cloud, wind, rain = env.room_weather(temp, cloud, wind, rain)
        rt = self.query_rain_type(temp, rain)

        str_ = "The air is "
        tstr = self.temp_string(temp)
        str_ += f"an {tstr} " if tstr[0] in "aeiou" else f"a {tstr} "
        str_ += f"{self.query_season()}’s {self.query_tod()} with "
        str_ += {
            range(-1000, 6): "calm stillness",
            range(6, 11): "a gentle breeze",
            range(11, 16): "a steady wind",
            range(16, 21): "a strong gust",
            range(21, 31): "a howling wind",
            range(31, 41): "fierce gusts",
            range(41, 51): "storm winds",
            range(51, 61): "gale-force winds",
            range(61, 1001): "a roaring tempest"
        }.get(next(r for r in [range(-1000, 6), range(6, 11), range(11, 16), range(16, 21),
                              range(21, 31), range(31, 41), range(41, 51), range(51, 61),
                              range(61, 1001)] if wind in r), "no wind")

        if not obscured:
            str_ += ", " if rain else " beneath "
            str_ += self.cloud_string(env)

        if rain:
            str_ += " and "
            intensity = "light" if rain <= 20 else ("steady" if rain <= 40 and wind < 20 else "driving" if rain <= 40 else "heavy" if rain <= 60 else "torrential" if rt == WEATHER_RAIN_TYPE else "very heavy")
            str_ += f"{intensity} {['', 'snow', 'sleet', 'rain'][rt]}"

        if obscured:
            str_ += f". {obscured}"
        if rain > 20 and wind > 30:
            str_ += ".\nThunder rumbles across the sky" if obscured else ".\nLightning splits the heavens with thunderous roars"
        return str_

    def query_rain_type(self, temp: int, rain: int) -> int:
        """Determines the precipitation type."""
        if rain <= 0:
            return WEATHER_NO_RAIN_TYPE
        if temp <= -2:
            return WEATHER_SNOW_TYPE
        elif -1 <= temp <= 3:
            return WEATHER_SLEET_TYPE
        return WEATHER_RAIN_TYPE

    def query_snowing(self, env: MudObject) -> bool:
        """Checks if it’s snowing."""
        temp, rain = self._get_weather_values(env)
        return self.query_rain_type(temp, rain) == WEATHER_SNOW_TYPE

    def query_raining(self, env: MudObject) -> bool:
        """Checks if it’s raining."""
        temp, rain = self._get_weather_values(env)
        return self.query_rain_type(temp, rain) > WEATHER_SNOW_TYPE

    def query_temperature(self, env: MudObject) -> int:
        """Returns the temperature."""
        return self._get_weather_values(env)[0]

    def query_cloud(self, env: MudObject) -> int:
        """Returns the cloud cover."""
        return self._get_weather_values(env)[1]

    def query_windsp(self, env: MudObject) -> int:
        """Returns the wind speed."""
        return self._get_weather_values(env)[2]

    def _get_weather_values(self, env: MudObject) -> Tuple[int, int, int]:
        """Helper to get weather values with room overrides."""
        temp = self.temperature_index(env)
        cloud = self.cloud_index(env)
        wind = self.calc_actual(env, WINDSP)
        rain = self.rain_index(env)
        if hasattr(env, "room_weather"):
            temp, cloud, wind, rain = env.room_weather(temp, cloud, wind, rain)
        return temp, cloud, wind

    def calc_variance(self, climate: str, type: int, seasonal: int) -> int:
        """Calculates weather variance."""
        diff = seasonal - self._pattern[climate][type]
        ret = random.randint(0, diff * 2) * (-1 if diff < 0 else 1)
        ret += random.randint(0, self._variance[type]) if random.randint(0, 2) else -random.randint(0, self._variance[type])
        return ret

    def set_day(self):
        """Sets the day state based on Faerûnian time."""
        self._toy = self.day_number()
        min_ = self.minute_number()
        self._sunrise = 6 * MINUTES_PER_HOUR + (182 - self._toy if self._toy < 183 else self._toy - 182) // 2
        self._sunset = 18 * MINUTES_PER_HOUR - (182 - self._toy if self._toy < 183 else self._toy - 182) // 2
        if min_ <= self._sunrise or min_ >= self._sunset:
            self._day = 0
        else:
            self._day = (min_ - self._sunrise) // 3 if self._sunrise < min_ < self._sunrise + 30 else \
                        (self._sunset - min_) // 3 if self._sunset - 30 < min_ < self._sunset else 10

    def migrate(self, climate: str, type: int):
        """Migrates current weather towards the pattern."""
        diff = self._pattern[climate][type] - self._current[climate][type]
        if diff > self._variance[type] // 2:
            diff = self._variance[type] // 2
        self._current[climate][type] += -random.randint(0, -diff) if diff < 0 else random.randint(0, diff)

    def update_pattern(self):
        """Updates the weather pattern hourly for Forgotten Realms."""
        driver.call_out(self.update_pattern, CYCLE_SPEED)
        toy = self._toy
        for climate in CLIMATES:
            temp, cloud, wind = {
                "Tropical": (30 + (toy // 36), 50 + random.randint(0, 100), random.randint(0, 10)),  # Chult-like
                "Arid": (35 + (toy // 36), (100 - toy // 4) - 50, random.randint(0, 15)),  # Calimshan
                "Temperate": (toy // 6 - 5, (182 - toy if toy < 183 else toy - 182) // 2 - 25, 10 - (toy // 36)),  # Sword Coast
                "Continental": (toy // 5 - 10, (365 - toy) // 4 + 50, 15 - (toy // 36)),  # Damara
                "Polar": (toy // 36 - 20, (182 - toy if toy < 183 else toy - 182) // 2 - 25, 20 - (toy // 36)),  # Icewind Dale
                "Highland": (toy // 10 - 15, (182 - toy if toy < 183 else toy - 182) // 2, 25 - (toy // 36))  # Spine of the World
            }[climate]
            tvar, cvar, wvar = [self.calc_variance(climate, i, v) for i, v in enumerate([temp, cloud, wind])]
            self._pattern[climate] = [temp + tvar, cloud + cvar, wind + wvar]
        self.save_object(FILE_NAME)

    def update_weather(self):
        """Updates the current weather every 5 minutes."""
        self._lastupdate = int(time.time())
        driver.call_out(self.update_weather, UPDATE_SPEED)
        list_ = {}
        roomlist = {}
        for user in [u for u in driver.users() if u and u.environment() and u.environment().query_property("location") == "outside"]:
            temp, cloud, wind = self._get_weather_values(user.environment())
            list_[user] = [temp, cloud, self.rain_index(user.environment()), self._day]
        newrooms = {r: n for r, n in self._rooms.items() if r}
        self._rooms = newrooms
        for room, notifications in self._rooms.items():
            temp, cloud, wind = self._get_weather_values(room)
            roomlist[room] = [temp, cloud, self.rain_index(room), self._day]

        if self.moonupdate + (SECONDS_PER_DAY * 2) < int(time.time()):
            self.mooncycle = (self.mooncycle + 1) % 14  # Selûne’s 28-day cycle, approximated
            self.moonupdate = int(time.time())

        for climate in CLIMATES:
            for type_ in [TEMP, CLOUD, WINDSP]:
                self.migrate(climate, type_)
        self.set_day()
        self.save_object(FILE_NAME)

        for user, warray in list_.items():
            self.do_inform(user, *warray)
        for room, notifications in self._rooms.items():
            self.do_room_inform(room, *roomlist[room], notifications)

    def do_inform(self, who: Player, old_temp: int, old_cloud: int, old_rain: int, old_day: int):
        """Informs players of weather changes."""
        temp, cloud, wind = self._get_weather_values(who.environment())
        new_rain = self.rain_index(who.environment())
        old_rt = self.query_rain_type(old_temp, old_rain)
        new_rt = self.query_rain_type(temp, new_rain)
        str_ = ""
        if self._day != old_day:
            where = self.sun_direction(1)  # Sunset
            if old_day == 10 and self._day < 10:
                str_ += f"The sun dips toward the {where} horizon.\n"
            elif old_day > 0 and self._day == 0:
                str_ += f"Darkness falls as the sun sets {where}.\n"
            elif old_day > self._day and 0 < self._day < 9:
                str_ += f"The sun sinks lower in the {where} sky.\n"
            where = self.sun_direction(0)  # Sunrise
            if self._day > 0 and old_day == 0:
                str_ += f"A faint glow rises {where} as dawn nears.\n"
            elif self._day == 10 and old_day < 10:
                str_ += f"The sun climbs {where}, heralding day.\n"
            elif self._day > old_day and 0 < self._day < 9:
                str_ += f"Light strengthens {where} with morning’s advance.\n"
        if self._day and old_cloud != cloud:
            if old_cloud < 60 and cloud > 20 and not cloud % 2:
                str_ += f"The {self.query_tod()} sun vanishes behind clouds.\n"
            elif old_cloud > 20 and cloud < 60 and cloud % 2:
                str_ += f"The {self.query_tod()} sun breaks through the clouds.\n"
        if old_rt != new_rt:
            str_ += ["", "The snow ceases", "The sleet stops", "The rain ends"][old_rt]
            str_ += " and " if old_rt and new_rt else " " if new_rt else ""
            str_ += ["", "snow begins to fall", "sleet starts", "rain begins"][new_rt] + ".\n"
        elif new_rt > 0:
            str_ += f"The {['', 'snow', 'sleet', 'rain'][new_rt]} persists.\n"
        if new_rt and not any(o.query_property("umbrella") for o in who.query_holding() + who.query_wearing()) or not random.randint(0, 50):
            who.add_effect("/std/effects/other/wetness", (new_rain * new_rt // 2) * (UPDATE_SPEED // 60))
        if str_:
            who.tell(f"ORANGE: {str_}\n")

    def do_room_inform(self, room: MudObject, old_temp: int, old_cloud: int, old_rain: int, old_day: int, notifications: int):
        """Informs rooms of weather changes."""
        temp, cloud, wind = self._get_weather_values(room)
        new_rain = self.rain_index(room)
        has_changed = 0
        if self._day != old_day and notifications & NOTIFY_DAY:
            has_changed |= NOTIFY_DAY
        if old_temp != temp and notifications & NOTIFY_TEMPERATURE:
            has_changed |= NOTIFY_TEMPERATURE
        if old_cloud != cloud and notifications & NOTIFY_CLOUD:
            has_changed |= NOTIFY_CLOUD
        if old_rain != new_rain and notifications & NOTIFY_RAIN:
            has_changed |= NOTIFY_RAIN
        if has_changed:
            driver.call_out(lambda: self.notify_room(room, has_changed, self._day, temp, cloud, new_rain), 1)

    def notify_room(self, room: MudObject, has_changed: int, day: int, temp: int, cloud: int, rain: int):
        """Notifies a room of weather changes."""
        if room:
            room.event_weather(has_changed, day, temp, cloud, rain)

    def sun_direction(self, which: int) -> str:
        """Returns the sun direction (0 for sunrise, 1 for sunset)."""
        day = self.day_number()
        # Simplified directions based on Faerûn’s geography
        if 1 <= day <= 91 or 275 <= day <= 365:  # Winter
            return "eastern" if which == 0 else "western"
        elif 92 <= day <= 182:  # Spring
            return "northeastern" if which == 0 else "southwestern"
        elif 183 <= day <= 274:  # Summer
            return "northern" if which == 0 else "southern"
        return "southeastern" if which == 0 else "northwestern"  # Autumn

    def query_sunrise(self, doy: int) -> int:
        """Returns sunrise time in seconds past midnight."""
        adjust = (182 - doy if doy < 183 else doy - 182) // 2
        return (6 * MINUTES_PER_HOUR) + adjust

    def query_sunset(self, doy: int) -> int:
        """Returns sunset time in seconds past midnight."""
        adjust = (182 - doy if doy < 183 else doy - 182) // 2
        return (18 * MINUTES_PER_HOUR) - adjust

    def save_object(self, filename: str):
        """Placeholder for saving state."""
        pass

    def restore_object(self, filename: str):
        """Placeholder for restoring state."""
        pass

async def init(driver_instance):
    driver = driver_instance
    driver.weather_handler = WeatherHandler()
    driver.weather_handler.setup()